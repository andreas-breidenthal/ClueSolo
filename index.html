<!doctype html>
<html lang="en">
<!--
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                        üîç CLUE SOLO - v4.0.0                              ‚ïë
‚ïë                     Human + AI Detective Board Game                        ‚ïë
‚ïë                   Refactored Logic - Consistent Terminology                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìñ QUICK START GUIDE FOR NON-CODERS:

1. OPENING THE GAME:
   ‚Ä¢ Double-click this .html file to open it in your web browser
   ‚Ä¢ Works best in Chrome, Firefox, or Edge (latest versions)

2. FINDING THINGS IN THIS FILE:
   ‚Ä¢ Open this file in a text editor (Notepad++, VS Code, or even Notepad)
   ‚Ä¢ Press Ctrl+F (Windows) or Cmd+F (Mac) to search
   ‚Ä¢ Search for section tags like "[SECTION 5]" to jump to specific parts

3. COMMON CUSTOMIZATIONS:

   üé® CHANGE COLORS:
      ‚Üí Search for "COLOR CUSTOMIZATION" (around line 10)
      ‚Üí Edit hex color codes like #0f172a
      ‚Üí Use https://htmlcolorcodes.com/color-picker/ to pick colors

   üìù CHANGE TEXT/LABELS:
      ‚Üí Search for the exact text you want to change
      ‚Üí Example: Search for "New Game" to change button text

   üé≤ ADJUST AI DIFFICULTY:
      ‚Üí Search for "[SECTION 5]" to find AI logic
      ‚Üí Look for difficulty settings (Easy, Medium, Hard)

4. TROUBLESHOOTING:
   ‚Ä¢ If game doesn't load: Press F12 to open browser console, check for errors
   ‚Ä¢ If you broke something: Use Ctrl+Z to undo your last changes
   ‚Ä¢ Keep a backup copy of this file before making changes!

5. SAVING YOUR CHANGES:
   ‚Ä¢ File ‚Üí Save (or Ctrl+S)
   ‚Ä¢ Refresh your browser (F5) to see changes

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-->
<head>
<meta charset="utf-8" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Cinzel:wght@400;600;700&family=EB+Garamond:ital,wght@0,400;0,500;1,400;1,500&display=swap" rel="stylesheet">
<meta property="og:title" content="ClueSolo - Hapless Hall">
<meta property="og:description" content="A solo mystery of deduction at Hapless Hall.">
<meta property="og:url" content="https://andreas-breidenthal.github.io/ClueSolo/">
<meta property="og:type" content="website">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ClueSolo ‚Äî Hapless Hall</title>

<style>
  /* ========================================================================
   * COLOR CUSTOMIZATION
   * ========================================================================
   * Authentic Vintage Cluedo Board Theme
   * Based on classic 1949-era Cluedo box design
   * ======================================================================== */
  :root{
    /* Authentic Cluedo Box Colors */
    --cluedo-red:#8B2E2B;      /* Main logo red */
    --cluedo-cream:#E2D5B6;    /* Banner background cream */
    --cluedo-charcoal:#262624; /* Banner text charcoal */
    --cluedo-forest:#3F5E4A;    /* Forest border accent */
    
    /* Main interface colors */
    --bg:#E2D5B6;          /* Cluedo banner cream as main background */
    --panel:#faf6ed;       /* Lighter cream for panels */
    --text:var(--cluedo-charcoal);  /* Dark charcoal for text */
    --muted:#5a5a58;       /* Grey for dimmed text */
    --accent:var(--cluedo-red);     /* Cluedo red accent */
    --bad:#6b1f1c;         /* Deep red for errors */
    --good:var(--cluedo-forest);     /* Cluedo forest for success */
    --warn:#d4a127;        /* Golden yellow for warnings */
    --border:var(--cluedo-red);     /* Red borders like box */
    --timber:var(--cluedo-charcoal); /* Dark charcoal for strong accents */
    --gold:#d4a127;        /* Gold highlight */
    --cream:var(--cluedo-cream);    /* Cluedo cream */

    /* Guest colors - each guest has their own color */
    --gst-forest:#2D6A2D;--gst-brimstone:#C8A000;--gst-sapphire:#1A7FD4;--gst-lavender:#9966CC;--gst-rouge:#EE0000;--gst-weisse:#f0f0f0;
    /* Treasure colors - each treasure has its own color */
    --tsr-portrait:#90C878;--tsr-ornaments:#E87820;--tsr-documents:#E8D9B0;--tsr-coins:#FFD700;--tsr-necklace:#F0EDE8;--tsr-watch:#A8A8B0;
  }
  body{
    margin:0;
    font-family:'EB Garamond',Georgia,serif;
    background: linear-gradient(135deg, #ede3ca 0%, #e0d2b0 100%);
    color:var(--text);
  }
  header{
    padding:14px 24px;
    display:flex;
    align-items:center;
    gap:16px;
    border-bottom:2px solid #c9973a;
    background:#0d0a07;
    color:#f5edd6;
    box-shadow:0 4px 16px rgba(0,0,0,0.5);
  }
  header::after { display:none; }
  header h1{
    margin:0;
    font-size:22px;
    font-weight:700;
    font-family:'Cinzel Decorative','Cinzel',serif;
    letter-spacing:0.08em;
    color:#c9973a;
    text-shadow:0 0 20px rgba(201,151,58,0.4);
  }
  header .sub{
    display:flex;
    gap:8px;
    align-items:center;
    color:#9a8a6a;
    font-size:11px;
    font-family:'Cinzel',serif;
    letter-spacing:0.12em;
    text-transform:uppercase;
  }
  header .fullscreen-btn{
    margin-left:auto;
    padding:6px 10px;
    background:transparent;
    border:1px solid rgba(201,151,58,0.4);
    border-radius:2px;
    color:#c9973a;
    font-size:18px;
    cursor:pointer;
    transition:background 0.2s ease, border-color 0.2s ease;
    line-height:1;
    font-family:inherit;
    text-transform:none;
    letter-spacing:0;
    font-weight:normal;
  }
  header .fullscreen-btn:hover{
    background:rgba(201,151,58,0.1);
    border-color:rgba(201,151,58,0.7);
  }
  /* Hide fullscreen button on small screens (below 1200px) */
  @media (max-width: 1199px) {
    header .fullscreen-btn{
      display:none;
    }
  }
  .layout{display:grid;grid-template-columns:360px 1fr 420px;gap:8px;padding:8px;align-items:start}
  .panel{
    background:var(--panel);
    border:1px solid rgba(201,151,58,0.35);
    border-radius:4px;
    overflow:hidden;
    box-shadow:0 4px 16px rgba(13,10,7,0.12);
    position: relative;
  }
  .panel::before { display: none; }
  .panel h2{
    margin:0;
    padding:8px 12px;
    font-size:10px;
    letter-spacing:.28em;
    text-transform:uppercase;
    background:#0d0a07;
    border-bottom:1px solid rgba(201,151,58,0.35);
    color:#c9973a;
    font-weight:600;
    font-family:'Cinzel',serif;
    position: relative;
  }
  .panel h2::after { display: none; }
  .panel .content{padding:8px}
  .leftStack{display:grid;gap:8px;grid-template-rows:auto auto 1fr}
  .rightStack{display:grid;gap:8px;grid-template-rows:auto auto 1fr}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .row.between{justify-content:space-between}
  .pill{font-size:12px;padding:4px 8px;border-radius:2px;border:1px solid rgba(201,151,58,0.4);background:#faf6ec;color:var(--text);box-shadow:none}
  .pill.good{color:var(--good);border-color:var(--good);background:#e8f5e9}
  .pill.bad{color:var(--bad);border-color:var(--bad);background:#ffebee}
  .pill.warn{color:var(--warn);border-color:var(--warn);background:#fff8e1}
  button{cursor:pointer;border:1px solid #8B2E2B;background:#8B2E2B;color:#f5edd6;padding:8px 16px;border-radius:2px;font-weight:600;font-family:'Cinzel',serif;font-size:11px;letter-spacing:0.12em;text-transform:uppercase;box-shadow:none;transition:background 0.15s ease,border-color 0.15s ease;text-shadow:none}
  button:hover{background:#a03835;border-color:#a03835}
  button:active{background:#6b1f1c;border-color:#6b1f1c}
  button.secondary{background:transparent;color:#5a4a2a;border-color:rgba(201,151,58,0.5)}
  button.secondary:hover{background:rgba(201,151,58,0.1);border-color:rgba(201,151,58,0.8)}
  button.danger{background:#6b1f1c;border-color:#6b1f1c;color:#f5edd6}
  button.danger:hover{background:#8B2E2B;border-color:#8B2E2B}
  button:disabled{opacity:.45;cursor:not-allowed}
  select{padding:8px 10px;border-radius:2px;border:1px solid rgba(201,151,58,0.5);background:#fff;color:var(--text);font-family:inherit}
  .board{
    display:grid;
    grid-template-columns:repeat(12,minmax(0,1fr));
    grid-auto-rows:72px;
    gap:5px;
    padding:8px;
    position:relative;
  }
  .room{
    border:1px solid rgba(201,151,58,0.3);
    border-radius:2px;
    padding:8px 6px 6px;
    background: linear-gradient(135deg, #fefcf7 0%, #faf5e8 100%);
    min-height:90px;
    position:relative;
    cursor:default;
    transition: box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    overflow:hidden;
  }
  .room .title{
    font-family:'Cinzel',serif;
    font-size:9px;
    font-weight:600;
    letter-spacing:0.12em;
    text-transform:uppercase;
    color:#8a6220;
    line-height:1.2;
    margin-bottom:4px;
  }
  .room .tokens{
    display:flex;
    flex-wrap:wrap;
    gap:3px;
    align-items:flex-start;
    align-content:flex-start;
  }
  /* Reachable ‚Äî gold pulse, cursor pointer */
  .room.reachable{
    border-color:rgba(201,151,58,0.8);
    background: linear-gradient(135deg, #fffbef 0%, #fff5d0 100%);
    box-shadow: 0 0 0 2px rgba(201,151,58,0.3), inset 0 0 20px rgba(201,151,58,0.08);
    cursor:pointer;
    animation: room-pulse 1.4s ease-in-out infinite;
  }
  @keyframes room-pulse {
    0%,100%{ box-shadow: 0 0 0 2px rgba(201,151,58,0.3); }
    50%    { box-shadow: 0 0 0 4px rgba(201,151,58,0.5); }
  }
  /* Current location ‚Äî subtle green tint */
  .room.here{
    border-color:rgba(45,106,45,0.6);
    background: linear-gradient(135deg, #f4fbf4 0%, #eaf5ea 100%);
    box-shadow: 0 0 0 2px rgba(45,106,45,0.2);
  }
  /* Centre tile */
  .room.center{
    background: linear-gradient(135deg, #f5efe0 0%, #ede3ca 100%);
    border:1px solid rgba(201,151,58,0.5);
  }
  .room.center.convicted{
    background:linear-gradient(135deg,rgba(232,184,75,0.15),rgba(201,151,58,0.08));
    border-color:rgba(201,151,58,0.8);
  }
  .room.center.accused{
    background:linear-gradient(135deg,rgba(212,161,39,0.15),rgba(255,248,220,0.3));
    border-color:rgba(212,161,39,0.7);
  }
  .room.center.notguilty{
    background:linear-gradient(135deg,rgba(100,120,160,0.1),rgba(200,210,230,0.15));
    border-color:rgba(100,130,180,0.5);
  }
  /* Hide old Move button ‚Äî rooms are clickable */
  .room button{ display:none; }
  .log{height:200px;overflow:auto;font-family:'EB Garamond',Georgia,serif;font-size:12px;line-height:1.5;background:#faf6ec;border:1px solid rgba(201,151,58,0.3);border-radius:2px;padding:10px;white-space:pre-wrap;color:var(--text);box-shadow:inset 0 1px 3px rgba(13,10,7,0.06)}

  .probWrap{
    position:relative;
    height:10px;
    border-radius:2px;
    border:1px solid rgba(201,151,58,0.3);
    background:#faf6ec;
    overflow:hidden;
  }
  .probBar{
    height:100%;
    background:linear-gradient(90deg, var(--accent), var(--gold));
  }
  .probPct{
    position:absolute;
    top:-18px;
    right:0;
    font-size:10px;
    color:var(--muted);
    font-weight:600;
  }
  
/* Ensure centre room-token doesn't inflate compared to other tokens */
  .room.center .tokens .token.room{ line-height:1.1; padding:3px 7px; }

/* ‚Äî‚Äî Checklist (with per-item single-line notes) ‚Äî‚Äî */
/* Wide / default: [checkbox] [label] [note input] on one line */
.noteitem{
  display:grid;
  grid-template-columns: auto auto 1fr; /* checkbox | name | input (flex) */
  column-gap:8px;
  align-items:center;         /* single-line alignment */
  padding:2px 0;
  color:var(--muted);
  font-size:11px;
}
.noteitem input[type="checkbox"]{
  grid-column:1;
  margin-top:0;
}
.noteitem .name{
  grid-column:2;
  color:var(--text);
  margin:0;
  white-space:nowrap;         /* keep the label from wrapping on wide screens */
}
.noteitem.cleared .name{
  text-decoration:line-through;
  color:#94a3b8;
}
.noteText{
  grid-column:3;              /* sits to the right of the label on wide screens */
  display:block;
  width:100%;
  box-sizing:border-box;
  margin:0;
  padding:3px 6px;
  border-radius:8px;
  border:1px solid var(--border);
  background:rgba(0,0,0,.18);
  color:var(--text);
  font-size:11px;
  min-width:160px;            /* comfortable min size next to short labels */
}

/* Hide Sherlock probability bar when an item is crossed off */
.noteitem.cleared .probWrap,
.noteitem.cleared .probPct{
  display:none !important;
}

/* Small screens: revert to stacked layout (input drops below the label) */
@media (max-width: 540px){
  .noteitem{
    grid-template-columns: auto 1fr;  /* checkbox | label on row 1 ‚Ä¶ */
    align-items:start;                /* let the input have its own row */
  }
  .noteitem .name{
    grid-column:2;
    white-space:normal;               /* allow wrapping on small screens */
  }
  .noteText{
    grid-column:1 / -1;               /* ‚Ä¶and input spans full width on row 2 */
    margin-top:6px;
  }
}

/* Container for each list (unchanged) */
.checklistStack{ display:grid; grid-template-columns:1fr; gap:10px }

/* ========================================================================
 * CLUE-STYLE DEDUCTION GRID
 * ======================================================================== */
.clueGrid {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
  margin-top: 0px;
  background: 
    repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(184,151,111,0.02) 2px,
      rgba(184,151,111,0.02) 4px
    ),
    #fffef8;
  box-shadow: inset 0 1px 3px rgba(61,40,23,0.1);
}

.clueGrid th {
  background: linear-gradient(180deg, var(--timber), #2c1810);
  padding: 0px 0px;
  border: 1px solid var(--timber);
  font-weight: 700;
  text-align: center;
  color: #f4e4c1;
  font-size: 10px;
  text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
}

.clueGrid td {
  border: 1px solid var(--border);
  padding: 0;
  text-align: center;
  background: #fff;
  height: 20px;  /* Reduced from 24px */
}

.clueGrid td.cardName {
  text-align: left;
  padding: 0px 0px;  /* Reduced padding */
  font-weight: 600;
  white-space: nowrap;
  background: linear-gradient(90deg, #faf5e8, #fff);
  font-size: 11px;
}

.clueGrid td.notesRow {
  padding: 0px 0px;  /* Minimal padding */
  background: #fff8e7;
  height: auto;
}

.clueGrid .noteInput {
  width: 97%;
  background: #fff;
  border: 0px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  font-size: 10px;
  padding: 0px 0px;
  font-style: italic;
}

.clueGrid .noteInput:focus {
  outline: 0px solid var(--accent);
  background: #fff8e7;
  color: var(--text);
}

.clueGrid .noteDisplay {
  font-size: 10px;
  color: var(--muted);
  font-style: italic;
  padding: 1px 1px;
  text-align: left;
}

.clueGrid select {
  width: 100%;
  height: 100%;
  border: none;
  background: transparent;
  color: var(--text);
  text-align: center;
  font-size: 11px;
  padding: 1px;
  cursor: pointer;
  appearance: none;
}

.clueGrid select:focus {
  outline: 1px solid var(--accent);
  background: rgba(184,37,44,0.1);
}

.clueGrid .sectionHeader {
  background: linear-gradient(90deg, rgba(184,37,44,0.15), rgba(212,161,39,0.1));
  font-weight: 800;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 1px;
  text-align: left;
  color: var(--accent);
  font-size: 11px;
  border-top: 1px solid var(--timber);
  border-bottom: 1px solid var(--border);
}

/* Compact view for small screens */
@media (max-width: 540px){
  .clueGrid {
    font-size: 10px;
  }
  .clueGrid th {
    padding: 4px 2px;
    font-size: 9px;
  }
  .clueGrid td.cardName {
    font-size: 10px;
    padding: 3px 5px;
  }
  .clueGrid .noteInput,
  .clueGrid .noteDisplay {
    font-size: 9px;
    padding: 2px 3px;
  }
}

  .promptBox{
    border:1px solid rgba(201,151,58,0.35);
    border-left:3px solid #c9973a;
    border-radius:2px;
    background: linear-gradient(135deg, #fefdfb 0%, #faf5ed 100%);
    padding:16px;
    box-shadow: 0 4px 16px rgba(13,10,7,0.1);
  }
  .promptTitle{
    font-weight:600;
    margin-bottom:10px;
    color:#2a1f0e;
    font-size:14px;
    letter-spacing:0.18em;
    text-transform:uppercase;
    font-family:'Cinzel',serif;
  }
  .promptBody{margin:6px 0 10px 0}
  .promptActions{display:flex;flex-wrap:wrap;gap:8px}
  .placeholder{color:var(--muted);font-size:12px}

  .rightPanel,.leftPanel{position:sticky;top:12px;height:calc(100vh - 96px);overflow:auto}
  @media (max-width:1200px){.layout{grid-template-columns:1fr}.leftPanel,.rightPanel{position:static;height:auto;overflow:visible}}

  /* Token ‚Äî emoji-only chip */
  .token{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:36px;
    height:36px;
    border-radius:50%;
    border:2px solid rgba(201,151,58,0.4);
    background:#faf6ec;
    font-size:20px;
    line-height:1;
    cursor:default;
    box-shadow: 0 2px 6px rgba(13,10,7,0.15);
    transition: transform 0.15s ease, box-shadow 0.15s ease;
    position:relative;
    flex-shrink:0;
  }
  .token:hover{ transform:scale(1.1); box-shadow:0 4px 10px rgba(13,10,7,0.25); }
  .token[data-color]{
    border-color: color-mix(in srgb, var(--token-color) 60%, rgba(201,151,58,0.4));
    background: color-mix(in srgb, var(--token-color) 18%, #faf6ec);
  }
  .token.inactive{ opacity:0.38; }
  /* Hide the text label inside tokens ‚Äî icon only */
  .token .ico{ font-size:20px; line-height:1; }
  .token > :not(.ico){ display:none; }
  /* Room token in centre tile ‚Äî slightly different */
  .token.roomtok{
    width:auto; height:auto;
    border-radius:2px;
    padding:4px 10px;
    font-size:12px;
    background:rgba(201,151,58,0.12);
    border-color:rgba(201,151,58,0.4);
  }
  .token.roomtok > :not(.ico){ display:inline; font-size:11px; }
  .token.inactive{ border-style:dashed; opacity:0.38; }
.token .ico {
  margin-right: 0;
}
  .token.guest.forest{--token-color:var(--gst-forest)}.token.guest.brimstone{--token-color:var(--gst-brimstone)}.token.guest.sapphire{--token-color:var(--gst-sapphire)}.token.guest.lavender{--token-color:var(--gst-lavender)}.token.guest.rouge{--token-color:var(--gst-rouge)}.token.guest.weisse{--token-color:var(--gst-weisse)}
  .token.treasure.portrait{--token-color:var(--tsr-portrait)}.token.treasure.ornaments{--token-color:var(--tsr-ornaments)}.token.treasure.documents{--token-color:var(--tsr-documents)}.token.treasure.coins{--token-color:var(--tsr-coins)}.token.treasure.necklace{--token-color:var(--tsr-necklace)}.token.treasure.watch{--token-color:var(--tsr-watch)}
.ico{ display:inline-block; margin-right:6px; line-height:1; }
/* --- Mobile stacked layout for Rooms --- */
/* Mobile-only New Game button row in the right panel */
.mobileNewGameRow {
  display: none;              /* hidden by default (desktop/tablet) */
  padding: 8px 10px 0 10px;   /* a little breathing room under the Casebook header */
}

/* On small screens, move New Game from left panel to right panel */
@media (max-width: 540px) {
  #btnNewGame {               /* hide the original always-visible button */
    display: none !important;
  }

  .mobileNewGameRow {         /* show the right-panel version */
    display: block;
  }

  #btnNewGameMobile {
    width: 100%;              /* big easy tap target */
  }
}

/* ========================================================================
 * MODAL OVERLAY for critical confirmations
 * ======================================================================== */
.modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  backdrop-filter: blur(3px);
}

.modalDialog {
  background: var(--panel);
  border: 4px solid var(--cluedo-red);
  border-radius: 8px;
  padding: 0;
  max-width: 500px;
  width: 90%;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  animation: modalSlideIn 0.2s ease-out;
}

@keyframes modalSlideIn {
  from {
    opacity: 0;
    transform: translateY(-50px) scale(0.9);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.modalHeader {
  background: linear-gradient(180deg, var(--cluedo-red), #6b1f1c);
  color: #fff;
  padding: 16px 20px;
  border-bottom: 3px solid var(--cluedo-charcoal);
  font-weight: 900;
  font-size: 18px;
  letter-spacing: 0.05em;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.modalBody {
  padding: 24px 20px;
  color: var(--text);
  font-size: 14px;
  line-height: 1.6;
}

.modalActions {
  padding: 12px 20px 20px 20px;
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

.modalActions button {
  min-width: 100px;
}

@media (max-width: 540px){
  /* Turn the board into a simple stacked layout */
  .board{
    display:grid;
    gap:12px;
    grid-template-columns: 1fr;   /* single column on mobile */
    grid-auto-rows: auto;
  }

  /* Override the JS inline grid placement */
  .board .room{
    grid-column: auto !important;
    grid-row: auto !important;
    min-height: 120px;
  }

  /* Center ‚ÄúCase File / Convicted‚Äù tile should also stack */
  .board .room.center{
    grid-column: auto !important;
    grid-row: auto !important;
  }
}

/* ============================================================
   GAME UI VISIBILITY
   ============================================================ */
#gameUI { display: none; }
#gameUI.active { display: block; }

/* ============================================================
   TITLE PAGE STYLES
   ============================================================ */
:root {
  --tp-ink:#0d0a07; --tp-gold:#c9973a; --tp-gold-dim:#8a6220; --tp-gold-glow:#e8b84b;
  --tp-candle:#fff4c2; --tp-muted:#9a8a6a;
}
#titlePages { min-height:100vh; background-color:var(--tp-ink); color:#f5edd6; font-family:'EB Garamond',Georgia,serif; font-size:17px; line-height:1.8; overflow-x:hidden; position:relative; }
#titlePages.hidden { display:none; }
#titlePages::before { content:''; position:fixed; inset:0; background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E"); pointer-events:none; z-index:999; opacity:0.4; }
#titlePages::after { content:''; position:fixed; inset:0; background:radial-gradient(ellipse at 50% 0%,rgba(201,151,58,0.08) 0%,transparent 60%),radial-gradient(ellipse at 50% 100%,rgba(13,10,7,0.6) 0%,transparent 70%); pointer-events:none; z-index:998; }
.tp-page { display:none; max-width:820px; margin:0 auto; padding:60px 32px 80px; position:relative; z-index:1; }
.tp-page.active { display:block; animation:tp-fadeIn 0.7s ease both; }
@keyframes tp-fadeIn { from{opacity:0;transform:translateY(16px)} to{opacity:1;transform:translateY(0)} }
.tp-masthead { text-align:center; margin-bottom:56px; }
.tp-eyebrow { font-family:'Cinzel',serif; font-size:11px; letter-spacing:0.35em; text-transform:uppercase; color:var(--tp-gold-dim); margin-bottom:16px; }
.tp-masthead h1 { font-family:'Cinzel Decorative',serif; font-size:clamp(2.4rem,6vw,4rem); font-weight:700; color:var(--tp-gold); text-shadow:0 0 40px rgba(201,151,58,0.4),0 2px 4px rgba(0,0,0,0.8); letter-spacing:0.05em; line-height:1.1; margin-bottom:10px; }
.tp-sub { font-family:'Cinzel',serif; font-size:13px; letter-spacing:0.2em; color:var(--tp-muted); text-transform:uppercase; }
.tp-rule { display:flex; align-items:center; gap:16px; margin:40px 0; }
.tp-rule::before,.tp-rule::after { content:''; flex:1; height:1px; background:linear-gradient(90deg,transparent,var(--tp-gold-dim),transparent); }
.tp-diamond { width:8px; height:8px; background:var(--tp-gold); transform:rotate(45deg); flex-shrink:0; box-shadow:0 0 8px rgba(201,151,58,0.6); }
.tp-act { margin-bottom:48px; }
.tp-act-label { font-family:'Cinzel',serif; font-size:10px; letter-spacing:0.4em; text-transform:uppercase; color:var(--tp-gold-dim); margin-bottom:6px; }
.tp-act h2 { font-family:'Cinzel',serif; font-size:1.25rem; font-weight:600; color:var(--tp-gold); margin-bottom:18px; letter-spacing:0.05em; }
.tp-act p { color:#d4c4a0; margin-bottom:14px; font-size:1rem; }
.tp-act p em { color:var(--tp-candle); font-style:italic; }
.tp-guests-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(230px,1fr)); gap:16px; margin-top:20px; }
.tp-guest-card { background:linear-gradient(160deg,#1a1408,#120e06); border:1px solid rgba(201,151,58,0.3); border-radius:6px; padding:18px 16px; position:relative; overflow:hidden; transition:border-color 0.3s,transform 0.2s; }
.tp-guest-card::before { content:''; position:absolute; top:0;left:0;right:0; height:2px; background:linear-gradient(90deg,transparent,var(--tp-gold-dim),transparent); opacity:0; transition:opacity 0.3s; }
.tp-guest-card:hover { border-color:rgba(201,151,58,0.5); transform:translateY(-2px); }
.tp-guest-card:hover::before { opacity:1; }
.tp-guest-icon { font-size:1.6rem; margin-bottom:8px; display:block; }
.tp-guest-name { font-family:'Cinzel',serif; font-size:0.85rem; font-weight:600; color:var(--tp-gold); margin-bottom:6px; letter-spacing:0.05em; }
.tp-guest-desc { font-size:0.85rem; color:var(--tp-muted); line-height:1.6; font-style:italic; }
.tp-items-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:14px; margin-top:20px; }
.tp-item-card { background:#120e06; border:1px solid rgba(201,151,58,0.3); border-radius:6px; padding:14px; transition:border-color 0.3s; }
.tp-item-card:hover { border-color:rgba(201,151,58,0.4); }
.tp-item-icon { font-size:1.4rem; margin-bottom:6px; display:block; }
.tp-item-name { font-family:'Cinzel',serif; font-size:0.8rem; color:var(--tp-gold); margin-bottom:5px; }
.tp-item-desc { font-size:0.82rem; color:var(--tp-muted); font-style:italic; line-height:1.55; }
.tp-rooms-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:14px; margin-top:20px; }
.tp-room-card { background:#120e06; border:1px solid rgba(201,151,58,0.3); border-left:2px solid var(--tp-gold-dim); border-radius:4px; padding:14px; transition:border-left-color 0.3s; }
.tp-room-card:hover { border-left-color:var(--tp-gold); }
.tp-room-icon { font-size:1.2rem; margin-bottom:5px; display:block; }
.tp-room-name { font-family:'Cinzel',serif; font-size:0.8rem; color:var(--tp-gold); margin-bottom:5px; }
.tp-room-desc { font-size:0.82rem; color:var(--tp-muted); font-style:italic; line-height:1.55; }
.tp-butler { border:1px solid rgba(201,151,58,0.3); border-left:3px solid var(--tp-gold); background:linear-gradient(135deg,#1a1408,#0f0c07); border-radius:4px; padding:24px 28px; margin:40px 0 0; position:relative; }
.tp-butler-text { color:#d4c4a0; font-size:1rem; font-style:italic; padding-left:12px; line-height:1.8; }
.tp-butler-attr { margin-top:10px; padding-left:12px; font-family:'Cinzel',serif; font-size:0.75rem; color:var(--tp-gold-dim); letter-spacing:0.1em; }
.tp-char-section { margin-top:48px; }
.tp-char-label { font-family:'Cinzel',serif; font-size:0.85rem; letter-spacing:0.2em; text-transform:uppercase; color:var(--tp-gold); margin-bottom:20px; display:block; }
.tp-char-buttons { display:flex; flex-wrap:wrap; gap:12px; }
.tp-char-btn { font-family:'Cinzel',serif; font-size:0.82rem; letter-spacing:0.06em; color:#c8b88a; background:#120e06; border:1px solid rgba(201,151,58,0.3); border-radius:5px; padding:12px 18px; cursor:pointer; transition:all 0.2s ease; display:flex; align-items:center; gap:8px; white-space:nowrap; }
.tp-char-btn:hover { border-color:var(--tp-gold); color:var(--tp-candle); background:#1a1408; box-shadow:0 0 16px rgba(201,151,58,0.15); transform:translateY(-2px); }
.tp-char-btn:active { transform:translateY(0); }
.tp-p2-head { text-align:center; margin-bottom:48px; }
.tp-p2-char { font-family:'Cinzel',serif; font-size:1rem; color:var(--tp-gold); margin-bottom:6px; letter-spacing:0.1em; }
.tp-p2-head h2 { font-family:'Cinzel Decorative',serif; font-size:clamp(1.6rem,4vw,2.4rem); color:var(--tp-gold); text-shadow:0 0 30px rgba(201,151,58,0.3); margin-bottom:8px; }
.tp-p2-head p { color:var(--tp-muted); font-style:italic; font-size:0.95rem; }
.tp-options-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:28px; margin-top:32px; }
@media(max-width:640px){ .tp-options-grid{grid-template-columns:1fr;} }
.tp-opt-col { background:#120e06; border:1px solid rgba(201,151,58,0.3); border-radius:6px; padding:22px 20px; }
.tp-opt-title { font-family:'Cinzel',serif; font-size:0.78rem; letter-spacing:0.22em; text-transform:uppercase; color:var(--tp-gold); padding-bottom:10px; border-bottom:1px solid rgba(201,151,58,0.3); margin-bottom:6px; }
.tp-opt-intro { font-size:0.82rem; color:var(--tp-muted); font-style:italic; line-height:1.6; margin-bottom:16px; margin-top:10px; }
.tp-opt-list { list-style:none; display:flex; flex-direction:column; gap:10px; }
.tp-opt-list li label { display:flex; align-items:flex-start; gap:10px; cursor:pointer; width:100%; }
.tp-opt-list input[type="radio"] { position:absolute; opacity:0; width:0; height:0; }
.tp-radio { width:14px; height:14px; border-radius:50%; border:1px solid var(--tp-gold-dim); background:transparent; flex-shrink:0; margin-top:3px; position:relative; transition:border-color 0.2s; }
.tp-radio::after { content:''; position:absolute; inset:3px; border-radius:50%; background:var(--tp-gold); opacity:0; transition:opacity 0.2s; }
.tp-opt-list input[type="radio"]:checked + .tp-radio { border-color:var(--tp-gold); }
.tp-opt-list input[type="radio"]:checked + .tp-radio::after { opacity:1; }
.tp-opt-wrap { display:flex; flex-direction:column; }
.tp-opt-name { font-family:'Cinzel',serif; font-size:0.82rem; color:#c8b88a; transition:color 0.2s; letter-spacing:0.04em; }
.tp-opt-desc { font-size:0.78rem; color:var(--tp-muted); font-style:italic; line-height:1.5; margin-top:2px; }
.tp-opt-list li:hover .tp-opt-name { color:var(--tp-candle); }
.tp-cta-wrap { text-align:center; margin-top:56px; }
.tp-cta-btn { display:inline-block; font-family:'Cinzel',serif; font-size:1rem; letter-spacing:0.18em; text-transform:uppercase; color:#0d0a07; background:linear-gradient(160deg,#e8b84b 0%,#c9973a 50%,#8a6220 100%); border:none; padding:18px 52px; border-radius:3px; cursor:pointer; position:relative; overflow:hidden; box-shadow:0 0 30px rgba(201,151,58,0.25),0 4px 16px rgba(0,0,0,0.6); transition:box-shadow 0.3s,transform 0.15s; }
.tp-cta-btn::before { content:''; position:absolute; inset:0; background:linear-gradient(160deg,rgba(255,255,255,0.2) 0%,transparent 60%); pointer-events:none; }
.tp-cta-btn:hover { box-shadow:0 0 50px rgba(201,151,58,0.45),0 6px 24px rgba(0,0,0,0.7); transform:translateY(-2px); }
.tp-cta-btn:active { transform:translateY(0); }
.tp-cta-note { margin-top:14px; font-size:0.8rem; color:var(--tp-muted); font-style:italic; }
.tp-foot { text-align:center; margin-top:60px; font-size:0.75rem; color:#4a3e28; letter-spacing:0.1em; font-family:'Cinzel',serif; }

/* ============================================================
   ACCUSATION OVERLAY
   ============================================================ */
.acc-overlay {
  position: fixed;
  inset: 0;
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 24px;
  transition: background 0.8s ease, opacity 0.4s ease;
  /* Default: ACCUSED state ‚Äî dark and tense */
  background: radial-gradient(ellipse at 50% 30%, #1a1206 0%, #0d0a07 100%);
}
.acc-overlay.hidden { display: none; }
.acc-overlay.state-notguilty {
  background: radial-gradient(ellipse at 50% 30%, #0e1520 0%, #080c14 100%);
}
.acc-overlay.state-convicted {
  background: radial-gradient(ellipse at 50% 20%, #1e1506 0%, #0d0a07 100%);
}

.acc-inner {
  max-width: 620px;
  width: 100%;
  text-align: center;
  color: #f5edd6;
  font-family: 'EB Garamond', Georgia, serif;
  animation: acc-rise 0.6s ease both;
}
@keyframes acc-rise {
  from { opacity:0; transform:translateY(24px); }
  to   { opacity:1; transform:translateY(0); }
}

.acc-eyebrow {
  font-family: 'Cinzel', serif;
  font-size: 10px;
  letter-spacing: 0.4em;
  text-transform: uppercase;
  color: #8a6220;
  margin-bottom: 20px;
  transition: color 0.8s ease;
}
.state-notguilty .acc-eyebrow { color: #4a6080; }
.state-convicted .acc-eyebrow { color: #c9973a; }

.acc-rule {
  display: flex;
  align-items: center;
  gap: 16px;
  margin: 0 auto 32px;
  max-width: 320px;
}
.acc-rule::before,.acc-rule::after {
  content: '';
  flex: 1;
  height: 1px;
  transition: background 0.8s ease;
  background: linear-gradient(90deg, transparent, #4a3010, transparent);
}
.state-notguilty .acc-rule::before,
.state-notguilty .acc-rule::after {
  background: linear-gradient(90deg, transparent, #2a3a50, transparent);
}
.state-convicted .acc-rule::before,
.state-convicted .acc-rule::after {
  background: linear-gradient(90deg, transparent, #c9973a, transparent);
}
.acc-diamond {
  width: 8px;
  height: 8px;
  transform: rotate(45deg);
  flex-shrink: 0;
  transition: background 0.8s ease, box-shadow 0.8s ease;
  background: #8a6220;
  box-shadow: 0 0 6px rgba(138,98,32,0.5);
}
.state-notguilty .acc-diamond { background: #2a3a50; box-shadow: 0 0 6px rgba(42,58,80,0.5); }
.state-convicted .acc-diamond { background: #c9973a; box-shadow: 0 0 12px rgba(201,151,58,0.8); }

.acc-headline {
  font-family: 'Cinzel Decorative', 'Cinzel', serif;
  font-size: clamp(1.8rem, 5vw, 3rem);
  font-weight: 700;
  margin-bottom: 28px;
  line-height: 1.1;
  transition: color 0.8s ease, text-shadow 0.8s ease;
  color: #c9973a;
  text-shadow: 0 0 40px rgba(201,151,58,0.3);
}
.state-notguilty .acc-headline {
  color: #7090b0;
  text-shadow: 0 0 30px rgba(112,144,176,0.3);
}
.state-convicted .acc-headline {
  color: #e8b84b;
  text-shadow: 0 0 60px rgba(232,184,75,0.5), 0 2px 4px rgba(0,0,0,0.8);
}

/* The three accusation cards */
.acc-cards {
  margin: 0 auto 28px;
  max-width: 480px;
}
.acc-declaration {
  font-family: 'EB Garamond', Georgia, serif;
  font-size: clamp(1.1rem, 2.5vw, 1.35rem);
  font-style: italic;
  color: #d4c4a0;
  line-height: 1.9;
  border-left: 3px solid rgba(201,151,58,0.4);
  padding: 16px 24px;
  background: rgba(255,255,255,0.03);
  text-align: left;
}
.state-convicted .acc-declaration {
  border-left-color: #c9973a;
  color: #e8dfc0;
}
.state-notguilty .acc-declaration {
  border-left-color: #2a3a50;
  color: #8090a8;
}
.acc-declaration em {
  font-style: normal;
  color: #f5edd6;
  font-weight: 500;
}
.state-convicted .acc-declaration em { color: #e8b84b; }
.state-notguilty .acc-declaration em { color: #7090b0; }

/* Verdict banner */
.acc-verdict {
  font-family: 'Cinzel', serif;
  font-size: clamp(1rem, 3vw, 1.5rem);
  letter-spacing: 0.2em;
  text-transform: uppercase;
  margin-bottom: 20px;
  min-height: 2rem;
  transition: color 0.8s ease;
}
.state-notguilty .acc-verdict { color: #7090b0; }
.state-convicted .acc-verdict { color: #e8b84b; }

.acc-body {
  font-size: 1rem;
  color: #9a8a6a;
  font-style: italic;
  line-height: 1.8;
  margin-bottom: 36px;
  min-height: 1.8rem;
  transition: color 0.8s ease;
}
.state-notguilty .acc-body { color: #4a6080; }
.state-convicted .acc-body { color: #c8b88a; }

.acc-actions {
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}
/* Overlay buttons ‚Äî override game button style */
.acc-btn {
  font-family: 'Cinzel', serif !important;
  font-size: 11px !important;
  letter-spacing: 0.2em !important;
  text-transform: uppercase !important;
  padding: 14px 36px !important;
  border-radius: 2px !important;
  cursor: pointer;
  transition: all 0.2s ease !important;
  border: 1px solid rgba(201,151,58,0.5) !important;
  background: transparent !important;
  color: #c9973a !important;
}
.acc-btn:hover {
  background: rgba(201,151,58,0.1) !important;
  border-color: #c9973a !important;
  color: #e8b84b !important;
}
.acc-btn.acc-btn-primary {
  background: linear-gradient(160deg, #e8b84b 0%, #c9973a 50%, #8a6220 100%) !important;
  color: #0d0a07 !important;
  border-color: transparent !important;
  box-shadow: 0 0 30px rgba(201,151,58,0.25) !important;
}
.acc-btn.acc-btn-primary:hover {
  box-shadow: 0 0 50px rgba(201,151,58,0.45) !important;
  transform: translateY(-2px);
}

/* Token entrance animation removed ‚Äî caused flicker on every board redraw */
/* Room title icon hidden ‚Äî text only, keep clean */
.room .title .ico { display:none; }

/* Room watermark icons */
.room[data-watermark] { overflow: hidden; }
.room[data-watermark]::before {
  content: attr(data-watermark);
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4.5rem;
  line-height: 1;
  opacity: 0.1;
  pointer-events: none;
  user-select: none;
  z-index: 0;
}
.room.reachable[data-watermark]::before,
.room.here[data-watermark]::before { opacity: 0.16; }
.room.center[data-watermark]::before { font-size: 5.5rem; opacity: 0.07; }
.room .title, .room .tokens { position: relative; z-index: 1; }
</style>
<script>
/* Title page functions ‚Äî must be defined before the HTML buttons that call them */
var tpState = { guest: null, diff: 'basic', opp: 2, observer: false };
var tpResolveSetup = null;
var tpResolveGuest = null;

function tpSelectCharacter(guestKey, displayName, emoji) {
  tpState.guest = guestKey;
  document.getElementById('tpCharDisplay').textContent = emoji + '  ' + displayName;
  document.getElementById('tpPage1').classList.remove('active');
  var p2 = document.getElementById('tpPage2');
  p2.classList.add('active');
  window.scrollTo({ top: 0, behavior: 'instant' });
}

function tpBeginInvestigation() {
  var diffEl  = document.querySelector('input[name="tpDiff"]:checked');
  var oppEl   = document.querySelector('input[name="tpOpp"]:checked');
  var modeEl  = document.querySelector('input[name="tpMode"]:checked');
  var diffRaw = diffEl  ? diffEl.value  : 'basic';
  var oppRaw  = oppEl   ? oppEl.value   : '2';
  var modeRaw = modeEl  ? modeEl.value  : 'normal';
  tpState.diff     = (diffRaw === 'deep' ? 'smart' : diffRaw);
  tpState.opp      = Math.min(5, Math.max(2, parseInt(oppRaw, 10) || 2));
  tpState.observer = (modeRaw === 'coach');

  document.getElementById('titlePages').classList.add('hidden');
  document.getElementById('gameUI').classList.add('active');
  window.scrollTo({ top: 0, behavior: 'instant' });

  if (tpResolveSetup) {
    var resolve = tpResolveSetup;
    tpResolveSetup = null;
    resolve({ diff: tpState.diff, opp: tpState.opp, observer: tpState.observer });
  }
}
</script>
</head>
<body>
<div id="titlePages">

  <!-- PAGE 1: THE STORY -->
  <div class="tp-page active" id="tpPage1">
    <div class="tp-masthead">
      <div class="tp-eyebrow">A Solo Mystery of Deduction</div>
      <h1>ClueSolo</h1>
      <div class="tp-sub">Hapless Hall &nbsp;&middot;&nbsp; An Evening Gone Terribly Wrong</div>
    </div>

    <div class="tp-rule"><div class="tp-diamond"></div></div>

    <div class="tp-act">
      <div class="tp-act-label">Act the First</div>
      <h2>An Evening at Hapless Hall</h2>
      <p>It was Sir Henry Hapless, 13th Duke of Misfortune, who had the singular idea of hosting a dinner party. His friends had advised strongly against it. The Hapless family name had not accumulated thirteen generations of ill fortune by accident. And yet Sir Henry persisted, as Hapless men always do: with magnificent optimism and catastrophic results.</p>
      <p>The evening began promisingly enough. Cook had outdone herself. The silver gleamed. The six guests arrived in fine spirits and finer clothes. By the time the port was poured, however, something had gone <em>terribly, irreversibly wrong.</em></p>
      <p>Somewhere between the fish course and the retiring to the drawing room, one of Sir Henry's most cherished possessions had vanished from the Hall entirely. Several other items were discovered displaced, found in rooms where they had no business being.</p>
      <p>Sir Henry, to the surprise of no one, had not noticed until it was far too late. <em>It never does to be the 13th of anything.</em></p>
    </div>

    <div class="tp-rule"><div class="tp-diamond"></div></div>

    <div class="tp-act">
      <div class="tp-act-label">Act the Second</div>
      <h2>The Guests of Hapless Hall</h2>
      <p>Six guests sat at Sir Henry's table that evening. Each arrived with impeccable manners and, it would seem, rather more impeccable motives.</p>
      <div class="tp-guests-grid">
        <div class="tp-guest-card" onclick="tpSelectCharacter('Forest','Mr Forest','üé©')" style="cursor:pointer"><span class="tp-guest-icon">üé©</span><div class="tp-guest-name">Mr Forest</div><div class="tp-guest-desc">A gentleman of the old school. His finances are considerably less well maintained than his charm.</div></div>
        <div class="tp-guest-card" onclick="tpSelectCharacter('Brimstone','Maj. Brimstone','üéñÔ∏è')" style="cursor:pointer"><span class="tp-guest-icon">üéñÔ∏è</span><div class="tp-guest-name">Maj. Brimstone</div><div class="tp-guest-desc">Retired military, distinction largely self-assessed. He has always admired Sir Henry's collection rather too openly.</div></div>
        <div class="tp-guest-card" onclick="tpSelectCharacter('Lavender','Dr Lavender','üéì')" style="cursor:pointer"><span class="tp-guest-icon">üéì</span><div class="tp-guest-name">Dr Lavender</div><div class="tp-guest-desc">A scholar of antiquities, quiet and precise. His gaze catalogues everything in a room before he has even removed his coat.</div></div>
        <div class="tp-guest-card" onclick="tpSelectCharacter('Sapphire','Lady Sapphire','üíé')" style="cursor:pointer"><span class="tp-guest-icon">üíé</span><div class="tp-guest-name">Lady Sapphire</div><div class="tp-guest-desc">Aristocratic, immaculate, possessed of a smile that has never once reached her eyes.</div></div>
        <div class="tp-guest-card" onclick="tpSelectCharacter('Rouge','Madame Rouge','üíã')" style="cursor:pointer"><span class="tp-guest-icon">üíã</span><div class="tp-guest-name">Madame Rouge</div><div class="tp-guest-desc">Continental, dramatic, entirely impossible to read. Charming in four languages and evasive in all of them.</div></div>
        <div class="tp-guest-card" onclick="tpSelectCharacter('Weisse','Mrs Weisse','üëí')" style="cursor:pointer"><span class="tp-guest-icon">üëí</span><div class="tp-guest-name">Mrs Weisse</div><div class="tp-guest-desc">The very picture of respectable widowhood. She sees considerably more than she lets on.</div></div>
      </div>
    </div>

    <div class="tp-rule"><div class="tp-diamond"></div></div>

    <div class="tp-act">
      <div class="tp-act-label">Act the Third</div>
      <h2>The Treasures of the Hall</h2>
      <p>One treasure is now missing entirely. Five others were discovered displaced. <em>One cannot be found at all.</em></p>
      <div class="tp-items-grid">
        <div class="tp-item-card"><span class="tp-item-icon">üñºÔ∏è</span><div class="tp-item-name">The Portrait</div><div class="tp-item-desc">A small oil painting of the 3rd Duchess. Last seen above the mantelpiece. It is not there now.</div></div>
        <div class="tp-item-card"><span class="tp-item-icon">‚öîÔ∏è</span><div class="tp-item-name">The Ornamental Weapons</div><div class="tp-item-desc">A matched pair of ceremonial swords. One has been recovered. The other remains at large.</div></div>
        <div class="tp-item-card"><span class="tp-item-icon">üìú</span><div class="tp-item-name">The Ancient Documents</div><div class="tp-item-desc">Manuscripts in Latin and older tongues. The portfolio was found. The documents inside were not.</div></div>
        <div class="tp-item-card"><span class="tp-item-icon">ü™ô</span><div class="tp-item-name">The Rare Coins</div><div class="tp-item-desc">A velvet-lined case of Roman aurei. The case was recovered. Its contents are another matter.</div></div>
        <div class="tp-item-card"><span class="tp-item-icon">üìø</span><div class="tp-item-name">The Necklace</div><div class="tp-item-desc">Three strands of matched pearls. Missing from its case in Sir Henry's study.</div></div>
        <div class="tp-item-card"><span class="tp-item-icon">‚è±Ô∏è</span><div class="tp-item-name">The Pocket Watch</div><div class="tp-item-desc">A silver hunter-case timepiece engraved with the Hapless family crest. The chain was found. The watch was not.</div></div>
      </div>
    </div>

    <div class="tp-rule"><div class="tp-diamond"></div></div>

    <div class="tp-act">
      <div class="tp-act-label">Act the Fourth</div>
      <h2>The Rooms Under Suspicion</h2>
      <p>Every room in Hapless Hall has something to answer for this evening.</p>
      <div class="tp-rooms-grid">
        <div class="tp-room-card"><span class="tp-room-icon">üìù</span><div class="tp-room-name">The Study</div><div class="tp-room-desc">The desk drawers were found open.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">üß•</span><div class="tp-room-name">The Hall</div><div class="tp-room-desc">The first room entered, the last room left.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">üõãÔ∏è</span><div class="tp-room-name">The Lounge</div><div class="tp-room-desc">A cushion displaced. A glass, overturned.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">üìñ</span><div class="tp-room-name">The Library</div><div class="tp-room-desc">The hidden compartment behind Debrett's was found ajar.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">üé±</span><div class="tp-room-name">The Billiard Room</div><div class="tp-room-desc">Chalk dust on a cuff. Footprints on the baize.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">üçΩÔ∏è</span><div class="tp-room-name">The Dining Room</div><div class="tp-room-desc">Someone had returned here after dinner.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">ü™¥</span><div class="tp-room-name">The Conservatory</div><div class="tp-room-desc">Ideal for a private conversation, or a private transaction.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">üíÉ</span><div class="tp-room-name">The Ballroom</div><div class="tp-room-desc">The dust cover on the piano had been disturbed.</div></div>
        <div class="tp-room-card"><span class="tp-room-icon">ü•©</span><div class="tp-room-name">The Kitchen</div><div class="tp-room-desc">The scullery door was found unlocked. Cook swears she saw nothing.</div></div>
      </div>
    </div>

    <div class="tp-rule"><div class="tp-diamond"></div></div>

    <div class="tp-act">
      <div class="tp-butler">
        <p class="tp-butler-text">Ladies and gentlemen, I have been instructed to inform you that the doors of Hapless Hall have been secured for the evening. Nobody is to leave the premises until this matter is resolved. Sir Henry asks only that you endeavour not to make things any worse than they already are.</p>
        <div class="tp-butler-attr">&mdash; Grimshaw, Butler to Sir Henry Hapless, 13th Duke of Misfortune</div>
      </div>
    </div>

    <div class="tp-char-section">
      <span class="tp-char-label">Select your character to enter the Hall:</span>
      <div class="tp-char-buttons">
        <button class="tp-char-btn" onclick="tpSelectCharacter('Forest','Mr Forest','üé©')">üé© Mr Forest</button>
        <button class="tp-char-btn" onclick="tpSelectCharacter('Brimstone','Maj. Brimstone','üéñÔ∏è')">üéñÔ∏è Maj. Brimstone</button>
        <button class="tp-char-btn" onclick="tpSelectCharacter('Lavender','Dr Lavender','üéì')">üéì Dr Lavender</button>
        <button class="tp-char-btn" onclick="tpSelectCharacter('Sapphire','Lady Sapphire','üíé')">üíé Lady Sapphire</button>
        <button class="tp-char-btn" onclick="tpSelectCharacter('Rouge','Madame Rouge','üíã')">üíã Madame Rouge</button>
        <button class="tp-char-btn" onclick="tpSelectCharacter('Weisse','Mrs Weisse','üëí')">üëí Mrs Weisse</button>
      </div>
    </div>

    <div class="tp-foot">ClueSolo &nbsp;&middot;&nbsp; Hapless Hall</div>
  </div><!-- /#tpPage1 -->

  <!-- PAGE 2: OPTIONS -->
  <div class="tp-page" id="tpPage2">
    <div class="tp-p2-head">
      <div class="tp-p2-char" id="tpCharDisplay">&mdash;</div>
      <h2>Terms of the Investigation</h2>
      <p>Before you proceed, settle the conditions under which this matter will be investigated.</p>
    </div>

    <div class="tp-rule"><div class="tp-diamond"></div></div>

    <div class="tp-options-grid">
      <div class="tp-opt-col">
        <div class="tp-opt-title">Difficulty</div>
        <p class="tp-opt-intro">How shrewdly will your fellow guests pursue the truth?</p>
        <ul class="tp-opt-list">
          <li><label><input type="radio" name="tpDiff" value="basic" checked><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">Beginner</span><span class="tp-opt-desc">Guests make naive deductions. Recommended for new investigators.</span></span></label></li>
          <li><label><input type="radio" name="tpDiff" value="smart"><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">Smart</span><span class="tp-opt-desc">Guests reason carefully and will press their advantage.</span></span></label></li>
          <li><label><input type="radio" name="tpDiff" value="sherlock"><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">Sherlock</span><span class="tp-opt-desc">Rigorous logical deduction. Only for the genuinely gifted.</span></span></label></li>
        </ul>
      </div>
      <div class="tp-opt-col">
        <div class="tp-opt-title">Opponents</div>
        <p class="tp-opt-intro">How many fellow guests will be investigating alongside you?</p>
        <ul class="tp-opt-list">
          <li><label><input type="radio" name="tpOpp" value="2" checked><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">2 opponents</span><span class="tp-opt-desc">Three investigators. More breathing room.</span></span></label></li>
          <li><label><input type="radio" name="tpOpp" value="3"><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">3 opponents</span><span class="tp-opt-desc">Four investigators. The pace quickens.</span></span></label></li>
          <li><label><input type="radio" name="tpOpp" value="4"><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">4 opponents</span><span class="tp-opt-desc">Five investigators. Deductions fly.</span></span></label></li>
          <li><label><input type="radio" name="tpOpp" value="5"><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">5 opponents</span><span class="tp-opt-desc">The full complement. Very little margin for error.</span></span></label></li>
        </ul>
      </div>
      <div class="tp-opt-col">
        <div class="tp-opt-title">Mode</div>
        <p class="tp-opt-intro">Will you investigate alone, or with quiet counsel?</p>
        <ul class="tp-opt-list">
          <li><label><input type="radio" name="tpMode" value="normal" checked><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">Normal</span><span class="tp-opt-desc">Every deduction and accusation is yours alone.</span></span></label></li>
          <li><label><input type="radio" name="tpMode" value="coach"><span class="tp-radio"></span><span class="tp-opt-wrap"><span class="tp-opt-name">Coach</span><span class="tp-opt-desc">A silent adviser offers guidance without giving the game away.</span></span></label></li>
        </ul>
      </div>
    </div>

    <div class="tp-cta-wrap">
      <button class="tp-cta-btn" onclick="tpBeginInvestigation()">Begin the Investigation</button>
      <div class="tp-cta-note">The truth is somewhere within these walls.</div>
    </div>

    <div class="tp-foot">ClueSolo &nbsp;&middot;&nbsp; Hapless Hall</div>
  </div><!-- /#tpPage2 -->

</div><!-- /#titlePages -->

<!-- GAME UI -->
<div id="gameUI">
<header>
  <h1>üîç ClueSolo</h1>
  <div class="sub">The Classic Detective Game ... alone!</div>
  <button class="fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen (F11)" aria-label="Toggle Fullscreen">‚õ∂</button>
</header>
<div class="layout">
  <div class="panel leftPanel">
    <h2>Controls</h2>
    <div class="content leftStack">
      <div class="row between" style="margin-bottom:4px;">
        <div class="row">
          <span class="pill" id="turnPill">Turn: ‚Äî</span>
          <span class="pill" id="locPill">Location: ‚Äî</span>
        </div>
        <button id="btnNewGame" class="secondary" style="font-size:10px;padding:6px 12px;">New Game</button>
      </div>
      <div class="panel">
        <h2>Your Cards</h2>
        <div class="content" id="handBox"></div>
      </div>
      <div class="panel">
        <h2>Players</h2>
        <div class="content" id="playersBox"></div>
      </div>
      <div class="panel">
        <h2>Game Log</h2>
        <div class="content"><div class="log" id="log"></div></div>
      </div>
    </div>
  </div>

  <div class="panel centerPanel">
    <h2>Rooms</h2>
    <div class="content">
      <div class="board" id="board"></div>
      <div class="panel" style="margin-top:12px;">
        <div class="content">
          <div id="gameplayPromptBox" class="promptBox">
            <div class="placeholder">Game-play prompts will appear here</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel rightPanel">
    <h2>Casebook</h2>

    <!-- Mobile-only New Game button (appears on small screens only) -->
    <div class="mobileNewGameRow">
      <button id="btnNewGameMobile" class="secondary">New Game</button>
    </div>

    <div class="content rightStack">
          <div class="checklistStack">
            <div class="notebox"><div id="noteUnified"></div></div>
          </div>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     ACCUSATION OVERLAY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="accusationOverlay" class="acc-overlay hidden" aria-modal="true" role="dialog">
  <div class="acc-inner">
    <div class="acc-eyebrow" id="accEyebrow">An Accusation Has Been Made</div>
    <div class="acc-rule"><div class="acc-diamond"></div></div>
    <div class="acc-headline" id="accHeadline"></div>
    <div class="acc-cards" id="accCards"></div>
    <div class="acc-verdict" id="accVerdict"></div>
    <div class="acc-body" id="accBody"></div>
    <div class="acc-actions" id="accActions"></div>
  </div>
</div>
</div><!-- /#gameUI -->

<script>
/* ================================================================================
 * üîç CLUE SOLO - HUMAN + AI BOARD GAME
 * ================================================================================
 * 
 * HOW TO NAVIGATE THIS FILE:
 * Use your editor's Find function (Ctrl+F or Cmd+F) and search for section tags
 * Example: Search for "[SECTION 3]" to jump to AI Logic
 * 
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * TABLE OF CONTENTS
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * 
 * [SECTION 1] UTILITIES & ERROR HANDLING ........... Line ~254
 *   ‚Ä¢ Global error handlers
 *   ‚Ä¢ Random number utilities
 *   ‚Ä¢ Array shuffling
 *   ‚Ä¢ Sleep/delay functions
 * 
 * [SECTION 2] GAME CONSTANTS ....................... Line ~330
 *   ‚Ä¢ Guests, Treasures, Rooms lists
 *   ‚Ä¢ Board layout definitions
 *   ‚Ä¢ Room connections and positions
 * 
 * [SECTION 3] PLAYER CLASS ......................... Line ~500
 *   ‚Ä¢ Player state management
 *   ‚Ä¢ Card tracking (own, seen, innocent)
 *   ‚Ä¢ Sherlock probability calculations
 * 
 * [SECTION 4] MAIN GAME CLASS ...................... Line ~800
 *   ‚Ä¢ Game state initialization
 *   ‚Ä¢ Card dealing
 *   ‚Ä¢ Turn management
 *   ‚Ä¢ Win/lose conditions
 * 
 * [SECTION 5] AI LOGIC ............................. Line ~1100
 *   ‚Ä¢ Difficulty levels (Easy, Medium, Hard)
 *   ‚Ä¢ AI move selection
 *   ‚Ä¢ AI suggestion logic
 *   ‚Ä¢ AI accusation decisions
 * 
 * [SECTION 6] GAME FLOW FUNCTIONS .................. Line ~1400
 *   ‚Ä¢ Turn execution
 *   ‚Ä¢ Movement handling
 *   ‚Ä¢ Suggestion/refutation
 *   ‚Ä¢ Accusation/trial
 * 
 * [SECTION 7] USER INTERFACE PROMPTS ............... Line ~1700
 *   ‚Ä¢ Game setup dialog
 *   ‚Ä¢ Move selection prompts
 *   ‚Ä¢ Refutation prompts
 *   ‚Ä¢ Information dialogs
 * 
 * [SECTION 8] UI RENDERING - PLAYERS & CARDS ....... Line ~2000
 *   ‚Ä¢ Player display
 *   ‚Ä¢ Hand rendering
 *   ‚Ä¢ Card visuals
 * 
 * [SECTION 9] UI RENDERING - NOTEBOOK .............. Line ~2100
 *   ‚Ä¢ Checklist rendering
 *   ‚Ä¢ Note-taking interface
 *   ‚Ä¢ Probability displays
 * 
 * [SECTION 10] UI RENDERING - BOARD ................ Line ~2300
 *   ‚Ä¢ Room rendering
 *   ‚Ä¢ Token placement
 *   ‚Ä¢ Movement indicators
 * 
 * [SECTION 11] GAME INITIALIZATION ................. Line ~2570
 *   ‚Ä¢ Startup sequence
 *   ‚Ä¢ New game function
 *   ‚Ä¢ UI reset
 * 
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * QUICK TIPS FOR NON-CODERS:
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * 
 * ‚è±Ô∏è TO MODIFY GAME DIFFICULTY:
 *    Search for "[SECTION 5]" ‚Üí Find "AI LOGIC" section
 * 
 * üé® TO CHANGE COLORS:
 *    Scroll to top of file ‚Üí Find the <style> section ‚Üí Look for ":root" variables
 * 
 * üìù TO ADJUST TEXT/LABELS:
 *    Search for the exact text you want to change (e.g., "New Game")
 * 
 * üêõ TO DEBUG ISSUES:
 *    Open browser console (F12) and check for error messages
 * 
 * ================================================================================ */

/* ================================================================================
 * [SECTION 1] UTILITIES & ERROR HANDLING
 * ================================================================================ */

// --- Global error surface: log to the in-app Game Log panel ---
window.onerror = function (msg, url, line, col, err) {
  try {
    const box = document.getElementById('log');
    const where = (line != null && col != null) ? ` @ ${line}:${col}` : '';
    const text = `[BOOT ERR] ${msg}${where}\n`;
    if (box) {
      box.textContent += text;
      box.scrollTop = box.scrollHeight;
    } else {
      console.error(text);
    }
  } catch (e) {
    console.error('Error in window.onerror:', e);
  }
};
// (Optional) also surface unhandled Promise rejections
window.addEventListener('unhandledrejection', (event) => {
  try {
    const box = document.getElementById('log');
    const reason = (event.reason && (event.reason.message || event.reason)) || 'Unhandled rejection';
    const text = `[BOOT ERR] Unhandled promise rejection: ${reason}\n`;
    if (box) {
      box.textContent += text;
      box.scrollTop = box.scrollHeight;
    } else {
      console.error(text);
    }
  } catch (e) {
    console.error('Error in unhandledrejection handler:', e);
  }
});

/* Utilities */
const randInt=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const choice=arr=>arr[Math.floor(Math.random()*arr.length)];
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
// --- Sherlock helper: pick least-informative refute card (adversarial refuter) ---
function pickLeastInformativeRefuteCard(refuter, matches, suggester){
  // Lower score = less NEW information revealed to the suggester
  if(!matches || !matches.length) return null;
  if(!suggester) return choice(matches);

  const scoreCard = (c) => {
    const key = suggester.cardKey(c.type, c.name);

    // If suggester already owns it, showing it is extremely uninformative
    if(suggester.own && suggester.own.has(key)) return -100;

    // If suggester already knows refuter owns it, also extremely uninformative
    if(suggester.knownOwners && suggester.knownOwners.get(key) === refuter.id) return -90;

    // If suggester has it "seen/innocent", showing owner is usually less useful
    if(suggester.seen && suggester.seen.has(key)) return -50;

    // If suggester has Sherlock beliefs, use them to pick the least informative card
    if(suggester.ownerWeights && typeof suggester._pOwner === 'function'){
      const pOwn  = suggester._pOwner(c, refuter.id); // how likely suggester already thinks refuter owns it
      const pCase = (typeof suggester._pCaseNorm === 'function') ? suggester._pCaseNorm(c) : 0; // how "hot" it is as solution

      // Less informative if:
      // - suggester already expects refuter to own it (high pOwn)
      // - it's unlikely to be in the case file (low pCase)
      return (1 - pOwn) + (pCase * 0.5);
    }

    // Fallback
    return 10;
  };

  let best = [], bestScore = Infinity;
  for(const c of matches){
    const s = scoreCard(c);
    if(s < bestScore){ best = [c]; bestScore = s; }
    else if(s === bestScore){ best.push(c); }
  }
  return choice(best.length ? best : matches);
}

// --- Sherlock helper: hand-size constraints (capacity) ---
function applyHandSizeConstraints(observer, players){
  // Only useful for AIs that track owners
  if(!observer || observer.isHuman) return;
  if(!observer.knownOwners || !observer.markNotOwner) return;

  // Build a quick key->card map once
  if(!applyHandSizeConstraints._keyToCard){
    applyHandSizeConstraints._keyToCard = new Map(ALL_CARDS.map(c => [`${c.type}:${c.name}`, c]));
  }
  const keyToCard = applyHandSizeConstraints._keyToCard;

  // For each player, if we already "know" they own as many cards as their hand size,
  // then they cannot own any other unknown cards.
  for(const p of players){
    if(!p) continue;
    const pid = p.id;
    const capacity = (p.hand && p.hand.length) ? p.hand.length : 0;
    if(capacity <= 0) continue;

    // All card keys observer believes are owned by pid
    const ownedKeys = [];
    for(const [k, ownerId] of observer.knownOwners.entries()){
      if(ownerId === pid) ownedKeys.push(k);
    }

    // If at capacity, mark NOT owner for every other card not already assigned to them
    if(ownedKeys.length >= capacity){
      const ownedSet = new Set(ownedKeys);
      let newlyExcluded = 0;

      for(const c of ALL_CARDS){
        const key = `${c.type}:${c.name}`;
        if(ownedSet.has(key)) continue;

        // If already known owned by someone else, ignore
        const knownOwner = observer.knownOwners.get(key);
        if(knownOwner !== undefined && knownOwner !== null && knownOwner !== pid) continue;

        // Mark "cannot own"
        // Only count/log if this is a NEW "not owner" fact
        const ckey = observer.cardKey(c.type, c.name);
        const existing = observer.notOwners.get(ckey);
        if(!existing || !existing.has(pid)){
          observer.markNotOwner(c, pid);
          newlyExcluded++;
        }

        // If Sherlock beliefs exist, also downweight pid for this card
        const w = observer.ownerWeights && observer.ownerWeights.get(key);
        if(w){
          w.set(pid, AI_CFG.sherlock.weightFloor);
          if(typeof observer.clampAndNormalizeWeights === 'function'){
            observer.clampAndNormalizeWeights(key);
          }
        }
      }

      // Log only when this capacity inference affected OTHER players (not self), and only if it created new exclusions
      if(newlyExcluded > 0 &&
         pid !== observer.id &&
         observer.gameRef &&
         observer.gameRef.observerMode &&
         observer.gameRef.aiDifficulty === 'sherlock' &&
         observer.id === observer.gameRef.observerFocusId){
        const who = players[pid]?.name ?? `P${pid}`;
        observer.gameRef.obs(`üìö Capacity inference: ${who}'s hand is full ‚Üí ruled out ${newlyExcluded} other cards for them.`, { byPlayerId: observer.id });
      }
    }
  }
}
const clampInt=(n,min,max,def)=>{const x=Number.parseInt(n,10); if(Number.isNaN(x)) return def; return Math.max(min,Math.min(max,x));};
const slug = s => String(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');


/* ============================================================
   ACCUSATION OVERLAY CONTROLLER
   ============================================================ */


const PLURAL_TREASURES = new Set(['Ornaments', 'Documents', 'Coins']);
function treasurePronoun(t) { return PLURAL_TREASURES.has(t) ? 'them' : 'it'; }

function accOverlay() { return document.getElementById('accusationOverlay'); }

function showAccusationOverlay({ accuser, guest, treasure, room, onReveal }) {
  const ov = accOverlay();
  ov.className = 'acc-overlay state-accused';

  document.getElementById('accEyebrow').textContent  = 'An Accusation Has Been Made';
  document.getElementById('accHeadline').textContent = accuser + ' has lodged an accusation.';
  document.getElementById('accVerdict').textContent  = '';
  document.getElementById('accBody').textContent     = '';

  document.getElementById('accCards').innerHTML = `
    <div class="acc-declaration">
      &ldquo;I solemnly declare that the crime was committed by
      <em>${displayGuest(guest)}</em>, who stole the
      <em>${treasure}</em> and concealed ${treasurePronoun(treasure)} in the
      <em>${room}</em>.&rdquo;
    </div>`;

  const btn = document.createElement('button');
  btn.className = 'acc-btn acc-btn-primary';
  btn.textContent = 'Reveal the Verdict';
  btn.onclick = () => { btn.remove(); onReveal(); };
  const actions = document.getElementById('accActions');
  actions.innerHTML = '';
  actions.appendChild(btn);

  ov.classList.remove('hidden');
}

function transitionOverlayNotGuilty({ accuser, onDismiss }) {
  const ov = accOverlay();
  ov.className = 'acc-overlay state-notguilty';

  document.getElementById('accEyebrow').textContent  = 'The Verdict Is In';
  document.getElementById('accHeadline').textContent = 'Not Guilty';
  document.getElementById('accVerdict').textContent  = '';
  document.getElementById('accBody').textContent     =
    accuser + ' has been eliminated from the investigation, but may still be called upon to refute a theory.';

  const btn = document.createElement('button');
  btn.className = 'acc-btn';
  btn.textContent = 'Return to the Investigation';
  btn.onclick = () => { hideAccusationOverlay(); onDismiss(); };
  const actions = document.getElementById('accActions');
  actions.innerHTML = '';
  actions.appendChild(btn);
}

function transitionOverlayConvicted({ winner, guest, treasure, room, onRestart, onRestartSame }) {
  const ov = accOverlay();
  ov.className = 'acc-overlay state-convicted';

  document.getElementById('accEyebrow').textContent  = 'The Mystery Is Solved';
  document.getElementById('accHeadline').textContent = winner + ' Wins';
  document.getElementById('accVerdict').textContent  = 'Convicted';
  document.getElementById('accBody').textContent     =
    displayGuest(guest) + ' concealed the ' + treasure + ' in the ' + room + '.';

  document.getElementById('accCards').innerHTML = `
    <div class="acc-declaration">
      <em>${displayGuest(guest)}</em> stole the
      <em>${treasure}</em> and concealed ${treasurePronoun(treasure)} in the
      <em>${room}</em>.
    </div>`;

  const actions = document.getElementById('accActions');
  actions.innerHTML = '';

  const restartBtn = document.createElement('button');
  restartBtn.className = 'acc-btn';
  restartBtn.textContent = 'Restart';
  restartBtn.title = 'Play again with the same character and settings';
  restartBtn.onclick = onRestartSame;
  actions.appendChild(restartBtn);

  const hallBtn = document.createElement('button');
  hallBtn.className = 'acc-btn acc-btn-primary';
  hallBtn.textContent = 'Return to Hapless Hall';
  hallBtn.onclick = onRestart;
  actions.appendChild(hallBtn);
}

function hideAccusationOverlay() {
  accOverlay().classList.add('hidden');
}

/* Data */
/* ================================================================================
 * [SECTION 2] GAME CONSTANTS
 * ================================================================================ */

const GUESTS=["Forest","Brimstone","Sapphire","Lavender","Rouge","Weisse"];
const GUEST_TITLES={Forest:"Mr. Forest",Brimstone:"Maj. Brimstone",Sapphire:"Lady Sapphire",Lavender:"Dr. Lavender",Rouge:"Madame Rouge",Weisse:"Mrs. Weisse"};
const TREASURES=["Portrait","Ornaments","Documents","Coins","Necklace","Watch"];
const ROOMS=["Study","Hall","Lounge","Library","Billiard Room","Dining Room","Conservatory","Ballroom","Kitchen"];
const START_ROOMS=["Study","Lounge","Kitchen","Conservatory","Billiard Room","Hall"];

const displayGuest=id=>GUEST_TITLES[id]||id;
const displayCardName=(type,name)=> type==='Guest'?displayGuest(name):name;

// Room icons for the board and casebook
const ROOM_ICON = {
  "Study": "üìù",
  "Hall": "üß•",
  "Lounge": "üõãÔ∏è",
  "Library": "üìñ",
  "Billiard Room": "üé±",
  "Dining Room": "üçΩÔ∏è",
  "Conservatory": "ü™¥",
  "Ballroom": "üíÉ",
  "Kitchen": "ü•©",
  "Case File": "üïµÔ∏è‚Äç‚ôÇÔ∏è"
};

/* Movement (kept as in your current build, including passages on any dice) */
const ROOM_DICE={
  "Study":{1:["Kitchen","Hall"],2:["Kitchen","Hall","Library"],3:["Kitchen","Hall","Library","Lounge"],4:["Kitchen","Hall","Library","Lounge","Billiard Room"],5:["Kitchen","Hall","Library","Lounge","Billiard Room","Dining Room"],6:["Kitchen","Hall","Library","Lounge","Billiard Room","Dining Room","Conservatory"]},
  "Hall":{1:["Study"],2:["Study","Lounge"],3:["Study","Lounge","Library"],4:["Study","Lounge","Library","Dining Room"],5:["Study","Lounge","Library","Dining Room","Billiard Room"],6:["Study","Lounge","Library","Dining Room","Billiard Room","Kitchen"]},
  "Lounge":{1:["Conservatory","Dining Room"],2:["Conservatory","Dining Room","Hall"],3:["Conservatory","Dining Room","Hall","Kitchen"],4:["Conservatory","Dining Room","Hall","Kitchen","Study"],5:["Conservatory","Dining Room","Hall","Kitchen","Study","Ballroom"],6:["Conservatory","Dining Room","Hall","Kitchen","Study","Ballroom","Library"]},
  "Dining Room":{1:["Lounge"],2:["Lounge","Kitchen"],3:["Lounge","Kitchen","Hall"],4:["Lounge","Kitchen","Hall","Ballroom"],5:["Lounge","Kitchen","Hall","Ballroom","Study"],6:["Lounge","Kitchen","Hall","Ballroom","Study","Conservatory"]},
  "Kitchen":{1:["Study","Ballroom"],2:["Study","Ballroom","Dining Room"],3:["Study","Ballroom","Dining Room","Conservatory"],4:["Study","Ballroom","Dining Room","Conservatory","Lounge"],5:["Study","Ballroom","Dining Room","Conservatory","Lounge","Billiard Room"],6:["Study","Ballroom","Dining Room","Conservatory","Lounge","Billiard Room","Hall"]},
  "Ballroom":{1:["Kitchen"],2:["Kitchen","Conservatory"],3:["Kitchen","Conservatory","Dining Room"],4:["Kitchen","Conservatory","Dining Room","Billiard Room"],5:["Kitchen","Conservatory","Dining Room","Billiard Room","Lounge"],6:["Kitchen","Conservatory","Dining Room","Billiard Room","Lounge","Library"]},
  "Conservatory":{1:["Lounge","Billiard Room"],2:["Lounge","Billiard Room","Ballroom"],3:["Lounge","Billiard Room","Ballroom","Library"],4:["Lounge","Billiard Room","Ballroom","Library","Kitchen"],5:["Lounge","Billiard Room","Ballroom","Library","Kitchen","Study"],6:["Lounge","Billiard Room","Ballroom","Library","Kitchen","Study","Dining Room"]},
  "Billiard Room":{1:["Conservatory","Library"],2:["Conservatory","Library","Ballroom"],3:["Conservatory","Library","Ballroom","Study"],4:["Conservatory","Library","Ballroom","Study","Kitchen"],5:["Conservatory","Library","Ballroom","Study","Kitchen","Hall"],6:["Conservatory","Library","Ballroom","Study","Kitchen","Hall","Dining Room"]},
  "Library":{1:["Billiard Room"],2:["Billiard Room","Study"],3:["Billiard Room","Study","Conservatory"],4:["Billiard Room","Study","Conservatory","Hall"],5:["Billiard Room","Study","Conservatory","Hall","Ballroom"],6:["Billiard Room","Study","Conservatory","Hall","Ballroom","Lounge"]}
};
function diceReachable(room,dice){
  const d=Math.max(1,Math.min(6,dice|0));
  const t=ROOM_DICE[room];
  return new Set((t&&t[d])?t[d]:[]);
}

/* DOM */
const el=id=>document.getElementById(id);
function log(msg){
  const box=el('log');
  const t=new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  box.textContent+=`[${t}] ${msg}\n`;
  box.scrollTop=box.scrollHeight;
}

/* Prompt helpers */
/* ================================================================================
 * [SECTION 7] USER INTERFACE PROMPTS
 * ================================================================================ */

function renderPrompt({title="",bodyHTML="",actions=[]}){
  return new Promise(resolve=>{
    const box=el('gameplayPromptBox');if(!box){resolve(null);return;}
    box.innerHTML="";
    const t=document.createElement('div');t.className='promptTitle';t.textContent=title;box.appendChild(t);
    const b=document.createElement('div');b.className='promptBody';b.innerHTML=bodyHTML;box.appendChild(b);
    const a=document.createElement('div');a.className='promptActions';
    actions.forEach(act=>{
      const btn=document.createElement('button');
      btn.textContent=act.label||'OK';
      if(act.className) btn.className=act.className;
      btn.onclick=()=>resolve(act.value!==undefined?act.value:true);
      a.appendChild(btn);
    });
    box.appendChild(a);
  });
}

/* ========================================================================
 * MODAL CONFIRMATION (for critical actions like New Game)
 * ======================================================================== */
function showModalConfirm({title="Confirm", bodyHTML="", confirmLabel="Confirm", cancelLabel="Cancel"}){
  return new Promise(resolve=>{
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'modalOverlay';
    
    // Create dialog
    const dialog = document.createElement('div');
    dialog.className = 'modalDialog';
    
    // Header
    const header = document.createElement('div');
    header.className = 'modalHeader';
    header.textContent = title;
    
    // Body
    const body = document.createElement('div');
    body.className = 'modalBody';
    body.innerHTML = bodyHTML;
    
    // Actions
    const actions = document.createElement('div');
    actions.className = 'modalActions';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'secondary';
    cancelBtn.textContent = cancelLabel;
    cancelBtn.onclick = () => {
      document.body.removeChild(overlay);
      resolve(false);
    };
    
    const confirmBtn = document.createElement('button');
    confirmBtn.className = 'danger';
    confirmBtn.textContent = confirmLabel;
    confirmBtn.onclick = () => {
      document.body.removeChild(overlay);
      resolve(true);
    };
    
    actions.appendChild(cancelBtn);
    actions.appendChild(confirmBtn);
    
    // Assemble
    dialog.appendChild(header);
    dialog.appendChild(body);
    dialog.appendChild(actions);
    overlay.appendChild(dialog);
    
    // Add to page
    document.body.appendChild(overlay);
    
    // ESC key to cancel
    const escHandler = (e) => {
      if(e.key === 'Escape'){
        document.body.removeChild(overlay);
        document.removeEventListener('keydown', escHandler);
        resolve(false);
      }
    };
    document.addEventListener('keydown', escHandler);
    
    // Click overlay background to cancel (optional - comment out if too sensitive)
    overlay.onclick = (e) => {
      if(e.target === overlay){
        document.body.removeChild(overlay);
        resolve(false);
      }
    };
    
    // Prevent clicks inside dialog from closing
    dialog.onclick = (e) => {
      e.stopPropagation();
    };
  });
}
function setPromptMessage(title, bodyHTML){
  const box=el('gameplayPromptBox');if(!box) return;
  box.innerHTML="";
  const t=document.createElement('div');t.className='promptTitle';t.textContent=title;box.appendChild(t);
  const b=document.createElement('div');b.className='promptBody';b.innerHTML=bodyHTML;box.appendChild(b);
  const a=document.createElement('div');a.className='promptActions';box.appendChild(a);
}
function clearGameplayPrompt(){
  const box=el('gameplayPromptBox');
  if(box) box.innerHTML='<div class="placeholder">Game-play prompts will appear here</div>';
}
async function showInfoPrompt(title,html){
  const r=await renderPrompt({title,bodyHTML:html,actions:[{label:'OK',value:true}]});
  clearGameplayPrompt();return r;
}
async function showChoicePrompt(title, promptHTML, choices, { allowCancel = true } = {}){
  const buttons=choices.map(ch=>({label:ch.label,value:ch.value,className:ch.className||'secondary'}));
  if(allowCancel) buttons.push({label:'Cancel',value:null,className:'secondary'});
  const r=await renderPrompt({title,bodyHTML:promptHTML,actions:buttons});
  clearGameplayPrompt();return r;
}
async function promptPlayAgain(){
  const r=await renderPrompt({
    title:'Play Again?',
    bodyHTML:`<div>Would you like to return to Hapless Hall?</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">You will be taken back to the beginning to choose your character and settings.</div>`,
    actions:[{label:'Return to Hapless Hall',value:true,className:'danger'},{label:'Stay Here',value:false,className:'secondary'}]
  });
  clearGameplayPrompt();
  return !!r;
}

// Difficulty helpers & labels
const DIFF_LABELS = {
  basic   : 'Basic inference',
  smart   : 'Smarter inference',
  sherlock: 'Sherlock (expert + human-like quirks)',
  // Back-compat alias if old saves or code still sets "deep":
  deep    : 'Smarter inference'
};
const normDiff = (d) => (d === 'deep' ? 'smart' : d); // map old "deep" to "smart"
const isAdvancedAI = (d) => (d === 'smart' || d === 'sherlock' || d === 'deep');
const isSherlock   = (d) => (d === 'sherlock');

/* ============================================================
   TITLE PAGE CONTROLLER
   ============================================================ */

// tpState, tpSelectCharacter, tpBeginInvestigation defined in early <script> block in <head>

function tpShowTitlePages() {
  // Reset title pages back to page 1
  document.getElementById('tpPage1').classList.add('active');
  document.getElementById('tpPage2').classList.remove('active');
  // Reset radio buttons to defaults
  const defDiff = document.querySelector('input[name="tpDiff"][value="basic"]');
  const defOpp  = document.querySelector('input[name="tpOpp"][value="2"]');
  const defMode = document.querySelector('input[name="tpMode"][value="normal"]');
  if (defDiff) defDiff.checked = true;
  if (defOpp)  defOpp.checked  = true;
  if (defMode) defMode.checked = true;
  document.getElementById('tpCharDisplay').textContent = '‚Äî';
  // Show title pages, hide game
  document.getElementById('titlePages').classList.remove('hidden');
  document.getElementById('gameUI').classList.remove('active');
  window.scrollTo({ top: 0, behavior: 'instant' });
}

/* Setup prompts ‚Äî now driven by title pages */
async function promptGameSetup(){
  const tp = document.getElementById('titlePages');
  if (tp && !tp.classList.contains('hidden')) {
    // Title pages are visible ‚Äî wait for Begin the Investigation
    return new Promise(resolve => { tpResolveSetup = resolve; });
  }
  // Title pages already dismissed ‚Äî use stored state
  return { diff: tpState.diff, opp: tpState.opp, observer: tpState.observer };
}

async function promptHumanGuest(available){
  // By the time this is called, tpBeginInvestigation has already run
  // and stored the guest in tpState. Just return it.
  return tpState.guest || available[0];
}

/* Manual Checklist: ticks + per-item text notes */
const CHECKLIST_KEY='cluedo_checklist_v1'; // ticked items
const CHECK_NOTES_KEY='cluedo_checkitem_notes_v1'; // per-item note text
function loadChecklist(){try{return JSON.parse(localStorage.getItem(CHECKLIST_KEY)||'{}')}catch{return {}}}
function saveChecklist(state){localStorage.setItem(CHECKLIST_KEY,JSON.stringify(state))}
function clearChecklist(){localStorage.removeItem(CHECKLIST_KEY)}
function loadCheckNotes(){try{return JSON.parse(localStorage.getItem(CHECK_NOTES_KEY)||'{}')}catch{return {}}}
function saveCheckNotes(state){localStorage.setItem(CHECK_NOTES_KEY,JSON.stringify(state))}
function clearCheckNotes(){localStorage.removeItem(CHECK_NOTES_KEY)}

/* --- Sherlock++ tuning --- */
const AI_CFG = {
  sherlock: {
    // Learning strengths
    weightBoostShow: 3.5,           // when a specific shown card is known
    weightBoostRefutePattern: 0.35, // when someone refutes a triple containing a card
    weightPenaltyNoRefute: 0.60,    // when someone fails to refute a triple
    decay: 0.985,                   // slow belief decay

    // Weight bounds
    weightFloor: 0.01,
    weightCeil:  4.00,

    // Decision-making & mistakes
    mistakeRate: 0.00,              // never intentionally throw
    earlyAccuseMinConfidence: 0.90, // still earlier than "certain", but much smarter
    earlyAccuseChance: 1.00,        // will be controlled by smarter logic in Patch 2 (not randomness)
    explorationEpsilon: 0.12,       // randomness in suggestion targets
    pickSecondBestChance: 0.03      // fewer "human quirks" that reduce strength
  }
};

// Flattened list of all cards (for belief initialization)
const ALL_CARDS = [
  ...GUESTS.map(n => ({type:'Guest', name:n})),
  ...TREASURES.map(n => ({type:'Treasure', name:n})),
  ...ROOMS.map(n => ({type:'Room', name:n}))
];

// Case file / envelope is treated as an additional "owner" in Sherlock beliefs
const CASE_FILE_ID = -1;
const CASE_FILE_NAME = 'Case File';

/* Game Model */
/* ================================================================================
 * [SECTION 3] PLAYER CLASS
 * ================================================================================
 * Manages individual player state, card tracking, and Sherlock probability logic
 * ================================================================================ */

class Player{
  constructor(id,isHuman=false,guest=null){
    this.id=id;this.isHuman=isHuman;this.guest=guest;
    this.name=guest?displayGuest(guest):(isHuman?'You':`AI-${id}`);
    this.hand=[];this.location='Hall';this.eliminated=false;
    this.seen=new Set();this.own=new Set();
    this.knownOwners=new Map(); // cardKey -> playerId
    this.knowledgeMeta = new Map(); // cardKey -> { status:'own'|'seen'|'deduced'|'innocent', ownerId?:number }
    this.gameRef = null; // set by Game.resetPlayers so Player can log in Sherlock
    this.constraints=[];this.unrefuted=[];
    this.arrivedByOpponentSuggestion=false;

    // Sherlock++ state
    this.ownerWeights = new Map();     // cardKey -> Map(playerId -> weight/prob (normalized))
    this.refutationCounts = new Map(); // cardKey -> Map(playerId -> count)
    this.notOwners = new Map();        // cardKey -> Set(playerId) known NOT to own
    this.playerCount = 0;
    this.randomJitter = Math.random() * 0.02;
  }

  cardKey(type,name){return `${type}:${name}`;}

  initKnowledge(){
  // Mark own cards
  for(const c of this.hand){
    const k=this.cardKey(c.type,c.name);
    this.own.add(k);
    this.seen.add(k);
    this.knownOwners.set(k,this.id);
    this.knowledgeMeta.set(k, { status:'own', ownerId:this.id });
  }
  
  // For Smart/Sherlock: Mark notOwners for cards NOT in hand
  if(this.gameRef && (this.gameRef.aiDifficulty === 'smart' || this.gameRef.aiDifficulty === 'sherlock')) {
    // Mark self as notOwner for cards not in hand
    for(const c of ALL_CARDS){
      const k=this.cardKey(c.type,c.name);
      if(!this.own.has(k)){
        this.markNotOwner(c, this.id);
      }
    }
    
    // AUTO-GUILTY: Check each category after marking own cards
    // If I own all but one card in a category, the last one must be GUILTY
    this.checkAndMarkGuiltyIfLastRemaining('Guest');
    this.checkAndMarkGuiltyIfLastRemaining('Treasure');
    this.checkAndMarkGuiltyIfLastRemaining('Room');
  }
}

  // --- Sherlock++ belief init (called after dealing)
  initBeliefs(players){
    this.playerCount = players.length;
    // uniform weights initially
    for(const c of ALL_CARDS){
      const key=this.cardKey(c.type,c.name);
      const w=new Map();

      // All players start equally likely to own the card...
      for(const p of players) w.set(p.id, 1.0);

      // ...and the case file is also a possible "owner"
      w.set(CASE_FILE_ID, 1.0);

      this.ownerWeights.set(key, w);
      this.clampAndNormalizeWeights(key);
    }

    // I own my cards with certainty (others near-floor)
    for(const c of this.hand){
      const key=this.cardKey(c.type,c.name);
      const w = this.ownerWeights.get(key);
      if (!w) continue;
      for(const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
      w.set(this.id, AI_CFG.sherlock.weightCeil);
      this.clampAndNormalizeWeights(key);
    }
  }

  clampAndNormalizeWeights(key){
    const w=this.ownerWeights.get(key); if(!w) return;
    let sum=0;
    for(const [pid,val] of w){
      const clamped=Math.max(AI_CFG.sherlock.weightFloor,Math.min(AI_CFG.sherlock.weightCeil,val));
      w.set(pid,clamped); sum+=clamped;
    }
    if(sum>0){for(const [pid,val] of w) w.set(pid,val/sum);}
  }

  decayBeliefs(){
    for(const [key,w] of this.ownerWeights){
      for(const [pid,val] of w) w.set(pid, val*AI_CFG.sherlock.decay);
      this.clampAndNormalizeWeights(key);
    }
  }

  // Mark a card as INNOCENT (‚úì owned by someone, so not in CF)
  // If ownerId is provided, mark which player owns it (‚úì in their column, ‚úó in all others)
  markSeen(card,ownerId=null){
    const k=this.cardKey(card.type,card.name);
    this.seen.add(k); // Card is INNOCENT (not in case file)
    
    if(ownerId!==null&&ownerId!==undefined) this.knownOwners.set(k,ownerId);

    // Update knowledge metadata for provenance tracking
    if(this.own.has(k)){
      // This is my own card (‚úì in my OWN column)
      this.knowledgeMeta.set(k,{status:'own',ownerId:this.id});
    }else if(ownerId!==null && ownerId!==undefined){
      // Someone else owns it (‚úì in their column)
      this.knowledgeMeta.set(k,{status:'seen',ownerId});
      
      // Smart/Sherlock: Mark ‚úó (not owned) for all other players
      if(this.gameRef && (this.gameRef.aiDifficulty === 'smart' || this.gameRef.aiDifficulty === 'sherlock')) {
        for(const player of this.gameRef.players){
          if(player.id !== ownerId){
            this.markNotOwner(card, player.id);
          }
        }
        // Also mark CF as not owning it (card is INNOCENT)
        this.markNotOwner(card, CASE_FILE_ID);
      }
    }else{
      // Card is INNOCENT but owner unknown
      this.knowledgeMeta.set(k,{status:'innocent'});
    }
    
    // AUTO-GUILTY: If this was the second-to-last card in the category,
    // the last remaining card must be GUILTY (100% probability)
    this.checkAndMarkGuiltyIfLastRemaining(card.type);
  }

  // Mark ‚úó (not owned) - this player does NOT own this card
  markNotOwner(card, playerId){
    const key=this.cardKey(card.type,card.name);
    let set=this.notOwners.get(key);
    if(!set){set=new Set(); this.notOwners.set(key,set);}
    set.add(playerId);
  }

  // Mark a card as GUILTY (üö© in CF column = is in the case file)
  markGuilty(type, name) {
    const key = this.cardKey(type, name);
    
    // Can't mark own cards as GUILTY
    if (this.own.has(key)) {
      return;
    }

    // Mark this card as the case-file card (üö© in CF column)
    this.knowledgeMeta.set(key, { status: 'guilty' });

    // Update Sherlock beliefs: this card is in CF with certainty
    const w = this.ownerWeights?.get(key);
    if (w) {
      for (const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
      w.set(CASE_FILE_ID, AI_CFG.sherlock.weightCeil);
      this.clampAndNormalizeWeights(key);
    }

    // üîí LOCK THE CATEGORY:
    // All other cards in this category are NOT in the case file (they're INNOCENT as solutions)
    const list = (type === 'Guest') ? GUESTS : (type === 'Treasure') ? TREASURES : ROOMS;

    for (const otherName of list) {
      if (otherName === name) continue;

      const otherKey = this.cardKey(type, otherName);
      const meta = this.knowledgeMeta.get(otherKey);

      // Don't overwrite cards we already have strong knowledge about
      const protectedStatus = meta && (
        meta.status === 'own' ||
        meta.status === 'seen' ||
        meta.status === 'deduced' ||
        meta.status === 'guilty'
      );

      // Mark as INNOCENT (as solution) if not already cleared
      if (!protectedStatus) {
        this.seen.add(otherKey);
        this.knowledgeMeta.set(otherKey, { status: 'innocent' });
      }

      // Update Sherlock beliefs: not in case file
      const ow = this.ownerWeights?.get(otherKey);
      if (ow) {
        ow.set(CASE_FILE_ID, AI_CFG.sherlock.weightFloor);
        this.clampAndNormalizeWeights(otherKey);
      }
    }
  }

  // Mark a card as INNOCENT (not in case file) without knowing who owns it
  markInnocent(type,name){
    const key=this.cardKey(type,name);
    if(this.own.has(key)) return; // own cards are already INNOCENT
    
    this.seen.add(key); // Card is INNOCENT
    
    if(!this.knownOwners.has(key)){
      this.knowledgeMeta.set(key,{status:'innocent'});
      
      // When a card is confirmed INNOCENT, mark ‚úó (not owned) for CF
      if(this.gameRef && (this.gameRef.aiDifficulty === 'smart' || this.gameRef.aiDifficulty === 'sherlock')) {
        const categoryList = type === 'Guest' ? GUESTS : (type === 'Treasure' ? TREASURES : ROOMS);
        categoryList.forEach(otherName => {
          if(otherName !== name) {
            const otherKey = this.cardKey(type, otherName);
            // Mark ‚úó in CF column (but don't mark as INNOCENT - they may still be owned by players)
            if(this.ownerWeights) {
              const w = this.ownerWeights.get(otherKey);
              if(w) {
                w.set(CASE_FILE_ID, AI_CFG.sherlock.weightFloor);
                this.clampAndNormalizeWeights(otherKey);
              }
            }
          }
        });
      }
    }

    // Update Sherlock beliefs: mark ‚úó for CF (not in case file)
    const w = this.ownerWeights?.get(key);
    if(w){
      w.set(CASE_FILE_ID, AI_CFG.sherlock.weightFloor);
      this.clampAndNormalizeWeights(key);
    }
    
    // AUTO-GUILTY: If this was the second-to-last card in the category,
    // the last remaining card must be GUILTY (100% probability)
    this.checkAndMarkGuiltyIfLastRemaining(type);
  }

  // Check if only one card remains unmarked in a category, and mark it GUILTY
  checkAndMarkGuiltyIfLastRemaining(type) {
    const list = (type === 'Guest') ? GUESTS : (type === 'Treasure') ? TREASURES : ROOMS;
    
    // Find cards that are not INNOCENT (not marked ‚úì in any player column)
    const notInnocent = [];
    for (const name of list) {
      const key = this.cardKey(type, name);
      // Skip if INNOCENT (in seen set) or GUILTY (already marked)
      if (this.seen.has(key)) continue; // INNOCENT
      const meta = this.knowledgeMeta.get(key);
      if (meta?.status === 'guilty') continue; // Already GUILTY
      
      notInnocent.push(name);
    }
    
    // If exactly one card remains, it must be GUILTY (100% probability)
    if (notInnocent.length === 1) {
      const guiltyCard = notInnocent[0];
      this.markGuilty(type, guiltyCard);
      
      // Log this auto-deduction in observer mode
      if (this.gameRef?.observerMode && this.gameRef.aiDifficulty !== 'basic') {
        const cardKey = this.cardKey(type, guiltyCard);
        this.gameRef.obs(`üí° Deduction: ${cardKey} is the only ${type} not marked INNOCENT ‚Üí must be GUILTY!`, { byPlayerId: this.id });
      }
    }
  }

  // --- Card Status Helpers (using consistent terminology) ---
  
  // Check if a card is marked INNOCENT (has ‚úì in any player column = not in case file)
  isCardInnocent(type,name){
    return this.seen.has(this.cardKey(type,name));
  }
  
  // Legacy alias for backwards compatibility
  isCleared(type,name){
    return this.isCardInnocent(type,name);
  }
  
  // Check if a card is marked GUILTY (has üö© in CF column = is in case file)
  isCardGuilty(type, name) {
    const key = this.cardKey(type, name);
    const meta = this.knowledgeMeta.get(key);
    return meta?.status === 'guilty';
  }
  
  // Get the GUILTY card for a category (if any)
  getGuiltyCard(type) {
    const list = type === 'Guest' ? GUESTS : (type === 'Treasure' ? TREASURES : ROOMS);
    for (const name of list) {
      if (this.isCardGuilty(type, name)) return name;
    }
    return null;
  }
  
  possibleSet(type){
    const list=type==='Guest'?GUESTS:type==='Treasure'?TREASURES:ROOMS;
    
    // In Smart/Sherlock modes: if one card in category is GUILTY (üö© in CF), 
    // return ONLY that card (it's the solution for this category)
    if(this.gameRef && (this.gameRef.aiDifficulty === 'smart' || this.gameRef.aiDifficulty === 'sherlock')) {
      const guiltyCard = this.getGuiltyCard(type);
      if(guiltyCard) {
        return [guiltyCard]; // Only the GUILTY card is a possibility
      }
    }
    
    // Otherwise, return all cards not marked INNOCENT (not ‚úì in any player column)
    return list.filter(n=>!this.isCardInnocent(type,n));
  }
  hasAnyOf(triple){
    return triple.filter(t=>this.hand.some(c=>c.type===t.type&&c.name===t.name));
  }

  addRefuteConstraint(refuterId,cards){
    const keys=new Set(cards.map(c=>this.cardKey(c.type,c.name)));
    this.constraints.push({refuterId,keys});

    // üß† Smart-level reasoning log (observer mode): "X has one of these"
    if(this.gameRef?.observerMode){
      const me = this.gameRef.players?.[this.id]?.name ?? `P${this.id}`;
      const who = this.gameRef.players?.[refuterId]?.name ?? `P${refuterId}`;
      const list = [...keys].join(', ');
      this.gameRef.obs(`üí≠ Hmm! ${who} has one of ${list}`, { byPlayerId: this.id });
    }

    this.propagateConstraints();
  }

  propagateConstraints(){
    let changed=true;
    while(changed){
      changed=false;
      for(let i=this.constraints.length-1;i>=0;i--){
        const c=this.constraints[i];
        // If we already know a card owned by refuter, satisfied
        let satisfied=false;
        for(const k of c.keys){
          const owner=this.knownOwners.get(k);
          if(owner===c.refuterId){satisfied=true;break;}
        }
        if(satisfied){ this.constraints.splice(i,1); changed=true; continue; }

        // Prune keys that are owned by others, or cannot be owned by refuter (negative knowledge)
        for(const k of [...c.keys]){
          const owner=this.knownOwners.get(k);
          if(owner!==undefined&&owner!==null&&owner!==c.refuterId){
            c.keys.delete(k); changed=true; continue;
          }
          const noSet = this.notOwners.get(k);
          if (noSet && noSet.has(c.refuterId)) {
            c.keys.delete(k); changed = true;
          }
        }

        // If only one remains -> deduce ownership
        if(c.keys.size===1){
          const [onlyKey]=c.keys;

          this.seen.add(onlyKey);
          this.knownOwners.set(onlyKey,c.refuterId);

          // provenance: deduced
          if(!this.own.has(onlyKey)){
            this.knowledgeMeta.set(onlyKey,{status:'deduced',ownerId:c.refuterId});
          }
          
          // Smart/Sherlock: Mark all other players as notOwners for this deduced card
          if(this.gameRef && (this.gameRef.aiDifficulty === 'smart' || this.gameRef.aiDifficulty === 'sherlock')) {
            // Find the card object
            const deducedCard = ALL_CARDS.find(card => this.cardKey(card.type, card.name) === onlyKey);
            if(deducedCard){
              for(const player of this.gameRef.players){
                if(player.id !== c.refuterId){
                  this.markNotOwner(deducedCard, player.id);
                }
              }
              // Also mark CF as not owning it
              this.markNotOwner(deducedCard, CASE_FILE_ID);
            }
          }

          // ‚úÖ Smart + Sherlock deduction log (observer mode): collapse -> must own
          if(this.gameRef?.observerMode){
            const me = this.gameRef.players?.[this.id]?.name ?? `P${this.id}`;
            const ownerName = this.gameRef.players?.[c.refuterId]?.name ?? `P${c.refuterId}`;
            this.gameRef.obs(`üí° Aha! ${ownerName} has ${onlyKey}`, { byPlayerId: this.id });
          }

          this.constraints.splice(i,1);
          changed=true; continue;
        }

        // If impossible set -> drop
        if(c.keys.size===0){
          this.constraints.splice(i,1); changed=true;
        }
      }
    }
  }

  // Mild inference (unchanged)
  // If two of a triple are cleared, the third must be solution (mark innocent all others in that category)
  // Implemented in Game.applyMildInference()

  // --- Sherlock++ learning hooks ---
  noteNoRefute(playerId,triple){
    // For each card: downweight that player as a possible owner
    for(const c of triple){
      const beforeCase = this._pCaseNorm(c);
      const beforeOwn  = this._pOwner(c, playerId);
      const key=this.cardKey(c.type,c.name);
      const w=this.ownerWeights.get(key);
      if(!w) continue;
      const cur=w.get(playerId) ?? 0;
      w.set(playerId, cur*AI_CFG.sherlock.weightPenaltyNoRefute);
      this.clampAndNormalizeWeights(key);

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[playerId]?.name ?? `P${playerId}`;
        const afterCase = this._pCaseNorm(c);
        const afterOwn  = this._pOwner(c, playerId);
      }

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[playerId]?.name ?? `P${playerId}`;
      }
    }
  }

  noteRefutePattern(refuterId,triple){
    for(const c of triple){
      const key=this.cardKey(c.type,c.name);
      const beforeCase = this._pCaseNorm(c);
      const beforeOwn  = this._pOwner(c, refuterId);
      const w=this.ownerWeights.get(key);
      if(!w) continue;
      // pattern memory
      const cntMap = this.refutationCounts.get(key) || new Map();
      cntMap.set(refuterId, (cntMap.get(refuterId) || 0) + 1);
      this.refutationCounts.set(key, cntMap);

      const cur=w.get(refuterId) ?? 0.0001;
      w.set(refuterId, cur + AI_CFG.sherlock.weightBoostRefutePattern);
      this.clampAndNormalizeWeights(key);

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[refuterId]?.name ?? `P${refuterId}`;
        const afterCase = this._pCaseNorm(c);
        const afterOwn  = this._pOwner(c, refuterId);
      }

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[refuterId]?.name ?? `P${refuterId}`;
        // We log per-card after update, but need "before" ‚Äì so compute before at top of loop:
        // (Handled below by capturing before values per card.)
      }

    }
  }

  noteCardShown(card,ownerId){
    const key=this.cardKey(card.type,card.name);
    this.seen.add(key);
    this.knownOwners.set(key,ownerId);
    const w=this.ownerWeights.get(key);
    if(w){
      for(const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
      w.set(CASE_FILE_ID, AI_CFG.sherlock.weightFloor); // ‚úÖ cannot be in case file if shown by a player
      w.set(ownerId, AI_CFG.sherlock.weightCeil);
      this.clampAndNormalizeWeights(key);
    }

    if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
      const ownerName = this.gameRef.players[ownerId]?.name ?? `P${ownerId}`;
      const who = this.gameRef.players[ownerId]?.name ?? `P${ownerId}`;
      const afterCase = this._pCaseNorm(card);
      const afterOwn  = this._pOwner(card, ownerId);
    }
  }

  // Sherlock beliefs: lock a specific card into the case file with near-certainty
  noteCaseFileCard(card){
    const key = this.cardKey(card.type,card.name);
    const w = this.ownerWeights.get(key);
    if(!w) return;

    // Set all owners (players) to floor, and case-file to ceil
    for(const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
    w.set(CASE_FILE_ID, AI_CFG.sherlock.weightCeil);
    this.clampAndNormalizeWeights(key);

    // CRITICAL: Set metadata status to 'guilty' so possibleSet can detect it
    this.knowledgeMeta.set(key, { status: 'guilty' });
    console.log(`[DEBUG noteCaseFileCard] Marked ${key} as guilty in knowledgeMeta`);

    if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
      this.gameRef.obs(`üïµÔ∏è‚Äç‚ôÇÔ∏è Right! ${key} is guilty`, { byPlayerId: this.id });
    }

    // CRITICAL: Force probabilities to lock onto guilty card
    this.forceGuiltyProbabilities(card);
  }

  // Force all probabilities in a category to focus on the guilty card
  forceGuiltyProbabilities(guiltyCard){
    const { type, name } = guiltyCard;
    const list = (type==='Guest'?GUESTS : type==='Treasure'?TREASURES : ROOMS);

    console.log(`[DEBUG forceGuiltyProbabilities] Forcing ${type} probabilities, guilty card: ${name}`);

    // For guests and treasures: 100% guilty, 0% everything else
    if(type === 'Guest' || type === 'Treasure'){
      for(const cardName of list){
        const key = this.cardKey(type, cardName);
        const w = this.ownerWeights.get(key);
        if(!w) continue;

        if(cardName === name){
          // This is the guilty card - 100% case file (use maximum weight)
          w.set(CASE_FILE_ID, 1.0); // Force to 1.0 (100%)
          for(const [pid] of w) {
            if(pid !== CASE_FILE_ID) w.set(pid, 0.0); // Force all player weights to 0
          }
          console.log(`[DEBUG forceGuiltyProbabilities] ${key} set to 100% case file`);
        } else {
          // All other cards in this category - 0% case file
          w.set(CASE_FILE_ID, 0.0); // Force to 0
          // Mark as innocent if not already owned/seen
          if(!this.own.has(key) && !this.knownOwners.has(key)){
            this.markInnocent(type, cardName);
          }
          console.log(`[DEBUG forceGuiltyProbabilities] ${key} set to 0% case file (innocent)`);
        }
        this.clampAndNormalizeWeights(key);
      }
    }
    // For rooms: use the special probability distribution you specified
    else if(type === 'Room'){
      const myRooms = this.hand.filter(c => c.type === 'Room').map(c => c.name);
      const unknownRooms = list.filter(r => {
        if(r === name) return false; // Skip the guilty room
        if(myRooms.includes(r)) return false; // Skip rooms I own
        // Skip rooms with known owners
        const key = this.cardKey('Room', r);
        return !this.knownOwners.has(key);
      });

      const hasMyRooms = myRooms.length > 0;
      const guiltyProb = hasMyRooms ? 0.93 : 0.99;
      const myRoomsTotal = hasMyRooms ? 0.06 : 0;
      const unknownTotal = 0.01;

      console.log(`[DEBUG forceGuiltyProbabilities] Room distribution: guilty=${guiltyProb}, myRooms=${myRoomsTotal}, unknown=${unknownTotal}`);

      for(const cardName of list){
        const key = this.cardKey('Room', cardName);
        const w = this.ownerWeights.get(key);
        if(!w) continue;

        if(cardName === name){
          // Guilty room: 93% or 99%
          w.set(CASE_FILE_ID, guiltyProb);
          console.log(`[DEBUG forceGuiltyProbabilities] ${key} set to ${guiltyProb*100}% case file`);
        } else if(myRooms.includes(cardName)){
          // My rooms: split 6% total
          const myRoomProb = myRoomsTotal / myRooms.length;
          w.set(CASE_FILE_ID, myRoomProb);
          console.log(`[DEBUG forceGuiltyProbabilities] ${key} (own) set to ${myRoomProb*100}% case file`);
        } else if(unknownRooms.includes(cardName)){
          // Unknown rooms: split 1% total
          const unknownProb = unknownTotal / (unknownRooms.length || 1);
          w.set(CASE_FILE_ID, unknownProb);
          console.log(`[DEBUG forceGuiltyProbabilities] ${key} (unknown) set to ${unknownProb*100}% case file`);
        } else {
          // Known to be owned by others: 0%
          w.set(CASE_FILE_ID, 0.0);
          console.log(`[DEBUG forceGuiltyProbabilities] ${key} (owned by other) set to 0% case file`);
        }
        this.clampAndNormalizeWeights(key);
      }
    }
  }
  // --- Sherlock: category-normalised probability that an item is in the case file ---
  // Ensures probabilities within each category (Guest/Treasure/Room) sum to 1
  // across remaining (not cleared) candidates.
  caseFileProbNormalized(type, name){
    // If already cleared/marked innocent/owned/seen, it cannot be in the case file
    if(this.isCleared(type, name)) return 0;

    const list = (type==='Guest'?GUESTS : type==='Treasure'?TREASURES : ROOMS);

    // Remaining candidates in this category (not cleared)
    const remaining = list.filter(n => !this.isCleared(type, n));

    // If only one remains, it must be the case-file item for this category
    if(remaining.length === 1){
      return (remaining[0] === name) ? 1 : 0;
    }

    // Sum raw P(case file) over remaining candidates
    let sum = 0;
    for(const n of remaining){
      const key = this.cardKey(type, n);
      const w = this.ownerWeights.get(key);
      const pCase = w ? (w.get(CASE_FILE_ID) ?? 0) : 0;
      sum += pCase;
    }

    // If everything collapsed near zero, fall back to uniform over remaining
    if(sum <= 1e-9){
      return 1 / remaining.length;
    }

    // Normalised value for this item
    const key = this.cardKey(type, name);
    const w = this.ownerWeights.get(key);
    const pCase = w ? (w.get(CASE_FILE_ID) ?? 0) : 0;

    return pCase / sum;
  }

  _pct(x){ return `${Math.round(Math.max(0, Math.min(1, x)) * 100)}%`; }

  _pCaseNorm(card){
    return this.caseFileProbNormalized(card.type, card.name);
  }

  _pOwner(card, ownerId){
    const key = this.cardKey(card.type, card.name);
    const w = this.ownerWeights.get(key);
    return w ? (w.get(ownerId) ?? 0) : 0;
  }

  // Entropy of ownership distribution for a card (higher => more uncertain/informative)
  entropyForCardKey(key){
    const w=this.ownerWeights.get(key); if(!w) return 0;
    const vals = Array.from(w.values());
    const sum = vals.reduce((a,b)=>a+b,0)||1;
    const probs = vals.map(v=>v/sum);
    return -probs.reduce((acc,p)=>acc + (p>0 ? p*Math.log(p) : 0), 0);
  }

  // Sherlock++: pick guest & treasure that look most informative (entropy + tiny jitter)
  pickSmartSuggestionParts(){
    const pickFrom=(type)=>{
      const pool=this.possibleSet(type);
      
      // CRITICAL: If pool has exactly 1 card (guilty card identified), ALWAYS use it
      if(pool.length === 1) {
        console.log(`[DEBUG pickSmartSuggestionParts] Only one ${type} in pool (guilty card locked): ${pool[0]}`);
        return pool[0];
      }
      
      // If pool is empty (shouldn't happen), fall back to full list
      const candidates=pool.length ? pool : (type==='Guest'?GUESTS : type==='Treasure'?TREASURES : ROOMS);
      console.log(`[DEBUG pickSmartSuggestionParts] ${type} candidates:`, candidates);
      
      let best=[],bestScore=-Infinity;
      for(const name of candidates){
        if(this.isCleared(type,name)) continue;
        const key=this.cardKey(type,name);
        const jitter=(Math.random()-0.5)*AI_CFG.sherlock.explorationEpsilon + this.randomJitter;
        const score=this.entropyForCardKey(key)+jitter;
        if(score>bestScore){best=[name];bestScore=score;}
        else if(score===bestScore){best.push(name);}
      }
      const pick = best.length ? choice(best) : choice(candidates);
      // Sometimes pick second-best to look human (but NOT for single-card pools or when we have guilty cards)
      if(candidates.length > 1 && Math.random()<AI_CFG.sherlock.pickSecondBestChance){
        const alt = candidates.filter(n => n!==pick);
        if(alt.length) return choice(alt);
      }
      return pick;
    };
    return {
      guest: pickFrom('Guest'),
      treasure : pickFrom('Treasure')
    };
  }

  // Sherlock: pick the most likely case-file item in a category using category-normalised probabilities
  beliefsTopFor(type){
    const list = (type==='Guest'?GUESTS : type==='Treasure'?TREASURES : ROOMS);

    let bestName=null, bestVal=-1, second=-1;

    for(const name of list){
      if(this.isCleared(type, name)) continue;

      const p = this.caseFileProbNormalized(type, name);

      if(p > bestVal){ second = bestVal; bestVal = p; bestName = name; }
      else if(p > second){ second = p; }
    }

    const margin = Math.max(0.0001, bestVal - Math.max(0, second));
    const confidence = Math.max(0, Math.min(1, (bestVal * 0.75) + (margin * 0.25)));

    return { name: bestName, confidence };
  }

  planAccusationWithBeliefs(){
    const s=this.beliefsTopFor('Guest');
    const w=this.beliefsTopFor('Treasure');
    const r=this.beliefsTopFor('Room');
    const combined = Math.pow(s.confidence * w.confidence * r.confidence, 1/3);
    return { acc: { guest:s.name, treasure:w.name, room:r.name }, confidence: combined };
  }
}

// Check if we have enough evidence to make an accusation
// Returns true if there's exactly one card marked GUILTY (üö© in CF) for each category
// OR exactly one card remaining (not INNOCENT) for each category
Player.prototype.isConfidentSolution = function(){
  return this.possibleSet('Guest').length === 1
      && this.possibleSet('Treasure').length  === 1
      && this.possibleSet('Room').length    === 1;
};

// Get the accusation based on current knowledge
// Returns the single remaining/GUILTY card for each category
Player.prototype.inferredAccusation = function(){
  return {
    guest: this.possibleSet('Guest')[0],
    treasure : this.possibleSet('Treasure')[0],
    room   : this.possibleSet('Room')[0]
  };
};

/* ================================================================================
 * [SECTION 4] MAIN GAME CLASS
 * ================================================================================
 * Core game state, card dealing, turn management, and win conditions
 * ================================================================================ */

class Game{
  constructor(){
    this.players=[];this.turnIndex=0;this.solution=null;
    this.guestLoc=new Map();this.treasureLoc=new Map();
    this.dice=null;this.reachable=new Set();
    this.awaitingMove=false;this.awaitingDecision=false;this.stayedInsteadOfRoll=false;
    this.aiDifficulty='basic';this.humanTurnsStarted=0;this.gameOver=false;
    this.trial=null;
    this.observerMode = false;
    this.observerFocusId = 0;
    this.coachMode = false; // Coach mode = observer logging + human executes focus player's choices
    this.obsLog = [];
    this.obsLogMax = 250;
    this.sessionId=0;
    this.turnCounter = 0; // ‚úÖ optional: for readable deduction log grouping
    this.resetPlayers(2);
  }

  obs(msg, { byPlayerId } = {}){
    // Rolling observer deductions log (Smart/Sherlock only)
    if(!this.observerMode) return;
    if(this.aiDifficulty === 'basic') return;

    // ‚úÖ MUST be explicitly attributed to a player
    if(byPlayerId === undefined || byPlayerId === null) return;

    // ‚úÖ Focus-only: only keep logs for the focused player
    if(byPlayerId !== this.observerFocusId) return;

    const t = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    this.obsLog.push(`[${t}] ${msg}`);
    if(this.obsLog.length > this.obsLogMax) this.obsLog.shift();
    // üîÑ Immediately repaint the deductions log so it appears BEFORE the next action/render
    const logBox = document.getElementById('observerDeduceLog');
    if (logBox) {
      logBox.textContent = (this.obsLog && this.obsLog.length)
        ? this.obsLog.slice(-200).join('\n')
        : '(deductions log will appear here)';
      logBox.scrollTop = logBox.scrollHeight;
    }
  }

  newSession(){this.sessionId++;return this.sessionId;}
  isActiveSession(id){return id===this.sessionId;}

  // ... keep the rest of your Game methods here (initAllGuestPawns, setup, makeSuggestion, aiTurn, etc.)
  isActiveSession(id){return id===this.sessionId;}

  initAllGuestPawns(){
    this.guestLoc=new Map();
    GUESTS.forEach((s,i)=>this.guestLoc.set(s,START_ROOMS[i]||'Hall'));
  }
  initTreasuresOnBoard(){
    this.treasureLoc=new Map();
    const rooms=shuffle(ROOMS.slice());
    TREASURES.forEach((w,i)=>this.treasureLoc.set(w,rooms[i%rooms.length]));
  }
  resetPlayers(n){
    n=clampInt(n,2,5,2);
    this.newSession();
    this.initAllGuestPawns();
    this.treasureLoc=new Map();
    this.players=[new Player(0,true,null)];
    for(let i=1;i<=n;i++) this.players.push(new Player(i,false,null));

    // ‚úÖ Link each Player back to this Game (needed for Observer logging)
    this.players.forEach(p => p.gameRef = this);

    this.players.forEach(p=>{
      p.hand=[];p.eliminated=false;p.seen=new Set();p.own=new Set();
      p.knownOwners=new Map();p.knowledgeMeta = new Map();p.constraints=[];p.unrefuted=[];
      p.arrivedByOpponentSuggestion=false;
      p.name=p.guest?displayGuest(p.guest):(p.isHuman?'You':`AI-${p.id}`);
      p.location='Hall';
    });

    this.turnIndex=0;this.solution=null;this.dice=null;this.reachable=new Set();
    this.awaitingMove=false;this.awaitingDecision=false;this.stayedInsteadOfRoll=false;
    this.humanTurnsStarted=0;this.gameOver=false;
    this.trial=null;    
  }
  assignGuests(human){
    const pool=GUESTS.slice();const i=pool.indexOf(human);if(i>=0) pool.splice(i,1);
    shuffle(pool);
    const me=this.players[0];me.guest=human;me.name=displayGuest(human);
    for(let k=1;k<this.players.length;k++){const s=pool.shift();this.players[k].guest=s;this.players[k].name=displayGuest(s);}
    this.players.forEach(p=>{if(p.guest)p.location=this.guestLoc.get(p.guest)||'Hall';});
  }
  buildDeck(){
    const cards=[];
    for(const s of GUESTS) cards.push({type:'Guest',name:s});
    for(const w of TREASURES) cards.push({type:'Treasure',name:w});
    for(const r of ROOMS) cards.push({type:'Room',name:r});
    return cards;
  }

  setup(){
    log('Setting up game‚Ä¶');
    this.solution={guest:choice(GUESTS),treasure:choice(TREASURES),room:choice(ROOMS)};
    const deck=this.buildDeck().filter(c=>{
      return !((c.type==='Guest'&&c.name===this.solution.guest)||
               (c.type==='Treasure'&&c.name===this.solution.treasure)||
               (c.type==='Room'&&c.name===this.solution.room));
    });
    shuffle(deck);
    this.players.forEach(p=>p.hand=[]);
    let p=0; while(deck.length) this.players[p++%this.players.length].hand.push(deck.pop());
    this.players.forEach(pl=>pl.initKnowledge());

    this.initAllGuestPawns();
    this.players.forEach(pl=>{ if(pl.guest) pl.location=this.guestLoc.get(pl.guest)||'Hall'; });
    this.initTreasuresOnBoard();

    // Sherlock++: initialize beliefs after hands are dealt
    this.players.forEach(pl=>pl.initBeliefs(this.players));

    log(`Cards dealt. Playing with ${this.players.length-1} opponents (${this.players.length} total players).`);
    log(`AI difficulty: ${DIFF_LABELS[this.aiDifficulty] || this.aiDifficulty}.`);
    renderAll(this);this.updateTurnUI();
  }

  currentPlayer(){return this.players[this.turnIndex];}
  isCoachFocus(pl){
    return !!this.coachMode && !!this.observerMode && pl && (pl.id === this.observerFocusId);
  }  
  nextTurnIndex(i){
    let x=i;for(let s=0;s<100;s++){x=(x+1)%this.players.length;if(!this.players[x].eliminated) return x;}return i;
  }
  computeReachable(start,steps){return diceReachable(start,steps);}
  updateTurnUI(fullRedraw=true){
    const pl=this.currentPlayer();
    const who = (this.observerMode && pl.id===this.observerFocusId)
      ? `Coach Focus (${pl.name})`
      : (pl.isHuman ? `You (${pl.name})` : pl.name);
    el('turnPill').textContent=`Turn: ${who}${pl.eliminated?' (eliminated)':''}`;
    el('locPill').textContent=`Location: ${pl.location}`;
    if(fullRedraw) renderAll(this);
  }

  // NO-REFUTE DEDUCTION (all opponents cannot refute):
  // Mark all 3 suggested cards ‚úó (not owned) for all opponents (done elsewhere)
  // For each suggested card NOT owned by suggester:
  //   - Mark that card GUILTY (üö© in CF column)
  //   - Mark all other cards in that category INNOCENT (not in CF)
  noRefuteDeduction(pl, { guest, treasure, room }){
    const owns = (type, name) => pl.hand.some(c => c.type === type && c.name === name);
  
    const innocentAllOthers = (type, keepName, list) => {
      for (const n of list) {
        if (n !== keepName) pl.markInnocent(type, n);
      }
    };
  
    // Only mark GUILTY if suggester does NOT own that suggested card
    if (!owns('Guest', guest)) {
      innocentAllOthers('Guest', guest, GUESTS);
      if (pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Guest', name:guest});
      if (pl.markGuilty) pl.markGuilty('Guest', guest); // Mark üö© (GUILTY) in CF column
    }

    if (!owns('Treasure', treasure)) {
      innocentAllOthers('Treasure', treasure, TREASURES);
      if (pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Treasure', name:treasure});
      if (pl.markGuilty) pl.markGuilty('Treasure', treasure); // Mark üö© (GUILTY) in CF column
    }

    if (!owns('Room', room)) {
      innocentAllOthers('Room', room, ROOMS);
      if (pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Room', name:room});
      if (pl.markGuilty) pl.markGuilty('Room', room); // Mark üö© (GUILTY) in CF column
    }
  
    if (this.observerMode){
      this.obs(`üßæ NO-REFUTE deduction: Cards not owned by ${pl.name} are marked GUILTY (üö© in CF); others marked INNOCENT.`, { byPlayerId: pl.id });
    }
  }

  // MILD INFERENCE: If 2 out of 3 cards in an unrefuted suggestion are INNOCENT,
  // the remaining card must be GUILTY (üö© in CF)
  applyMildInference(pl){
    for(const t of pl.unrefuted){
      const s=pl.isCardInnocent('Guest',t.guest),
            w=pl.isCardInnocent('Treasure',t.treasure),
            r=pl.isCardInnocent('Room',t.room);
      if((s?1:0)+(w?1:0)+(r?1:0)===2){
        if(!s){
          GUESTS.forEach(x=>{ if(x!==t.guest) pl.markInnocent('Guest',x); });
          if (pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Guest', name:t.guest});
          if (pl.markGuilty) pl.markGuilty('Guest', t.guest); // Mark üö© (GUILTY) in CF
        }
        if(!w){
          TREASURES.forEach(x=>{ if(x!==t.treasure) pl.markInnocent('Treasure',x); });
          if (pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Treasure', name:t.treasure});
          if (pl.markGuilty) pl.markGuilty('Treasure', t.treasure); // Mark üö© (GUILTY) in CF
        }
        if(!r){
          ROOMS.forEach(x=>{ if(x!==t.room) pl.markInnocent('Room',x); });
          if (pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Room', name:t.room});
          if (pl.markGuilty) pl.markGuilty('Room', t.room); // Mark üö© (GUILTY) in CF
        }
      }
    }
  }

  applyInference(pl){
    if(pl.isHuman) return;
    // BASIC: no inference pipeline at all.
    if(this.aiDifficulty === 'basic') return;

    // SMART / SHERLOCK: normal inference
    pl.propagateConstraints();
    this.applyMildInference(pl);

    // SHERLOCK: add capacity (hand-size) constraints
    if(this.aiDifficulty === 'sherlock'){
      applyHandSizeConstraints(pl, this.players);
      // Re-run propagation because hand-size constraints can unlock deductions
      pl.propagateConstraints();
    }
  }

  coachAccusationPlan(pl){
    if(isSherlock(this.aiDifficulty)){
      const plan = pl.planAccusationWithBeliefs();
      if(plan && plan.confidence >= AI_CFG.sherlock.earlyAccuseMinConfidence){
        return plan.acc;
      }
    } else if(pl.isConfidentSolution()){
      return pl.inferredAccusation();
    }
    return null;
  }

  // Smart room selection: prioritize GUILTY > owned > unknown (for both AI and coach)
  // Room selection logic per specification:
  // Step 3: If GUILTY room exists:
  //   - If reachable ‚Üí move to GUILTY room
  //   - If NOT reachable ‚Üí move to owned room (if any reachable), else any reachable
  // Step 4: If no GUILTY room:
  //   - Remove INNOCENT rooms, select best potential room
  pickBestRoom(pl, reachableRooms){
    if(!reachableRooms || reachableRooms.length === 0) return null;

    const guiltyRoom = pl.getGuiltyCard('Room');
    const myRooms = pl.hand.filter(c => c.type === 'Room').map(c => c.name);

    // Step 3: GUILTY room exists?
    if(guiltyRoom) {
      // Is GUILTY room reachable?
      if(reachableRooms.includes(guiltyRoom)){
        return guiltyRoom; // Move to GUILTY room
      } else {
        // GUILTY room NOT reachable - move to owned room if any reachable
        const reachableOwned = reachableRooms.filter(r => myRooms.includes(r));
        if(reachableOwned.length > 0){
          return choice(reachableOwned);
        }
        // No owned rooms reachable - move to any reachable
        return choice(reachableRooms);
      }
    }

    // Step 4: No GUILTY room - remove INNOCENT rooms, select best potential
    const notInnocent = reachableRooms.filter(r => !pl.isCardInnocent('Room', r));
    const candidates = notInnocent.length > 0 ? notInnocent : reachableRooms;

    // Calculate next-turn potential
    const nextTurnPotential = (fromRoom) => {
      const seen = new Set();
      for(let d=1; d<=6; d++){
        const arr = (ROOM_DICE[fromRoom] && ROOM_DICE[fromRoom][d]) ? ROOM_DICE[fromRoom][d] : [];
        for(const r of arr){
          if(!pl.isCardInnocent('Room', r)) seen.add(r);
        }
      }
      return seen.size;
    };

    let best = [], bestScore = -1;
    for(const r of candidates){
      const s = nextTurnPotential(r);
      if(s > bestScore){ best = [r]; bestScore = s; }
      else if(s === bestScore){ best.push(r); }
    }
    
    return choice(best.length > 0 ? best : reachableRooms);
  }

  coachAccusationPlan(pl){
    if(!pl || pl.eliminated) return null;

    // Certain accusation (all difficulties) ‚Äî matches aiTurn's "certain" branch
    if(pl.isConfidentSolution()) return pl.inferredAccusation();

    // Sherlock: belief-aware early accusation if evidence threshold met
    if(isSherlock(this.aiDifficulty)){
      const hasEvidence =
        (pl.seen.size > pl.own.size) ||
        (pl.constraints && pl.constraints.length > 0) ||
        (pl.unrefuted && pl.unrefuted.length > 0);

      if(hasEvidence && typeof pl.planAccusationWithBeliefs === 'function'){
        const plan = pl.planAccusationWithBeliefs();
        if(plan && plan.acc && plan.confidence >= AI_CFG.sherlock.earlyAccuseMinConfidence){
          return plan.acc;
        }
      }
    }
    return null;
  }

  coachStartRecommendation(pl){
    // Decide: roll / stay / accuse (stay only if arrived by opponent suggestion)
    const acc = this.coachAccusationPlan(pl);
    if(acc) return { action:'accuse', acc };

    const canStay = !!pl.arrivedByOpponentSuggestion;
    if(canStay){
      // If current room is GUILTY (üö© in CF), recommend staying
      if(pl.isCardGuilty('Room', pl.location)) return { action:'stay' };
      
      // If current room is not INNOCENT (not marked yet), recommend staying to gather info
      if(!pl.isCardInnocent('Room', pl.location)) return { action:'stay' };
    }
    return { action:'roll' };
  }

  coachRecommendMove(pl){
    const reach = [...this.reachable];
    if(!reach.length) return pl.location;
    
    const dest = this.pickBestRoom(pl, reach);
    return dest || pl.location;
  }

  async makeSuggestion(pl,guest,treasure,room){
    const triple=[{type:'Guest',name:guest},{type:'Treasure',name:treasure},{type:'Room',name:room}];

    // Step d: Move guest into suggested room and animate
    const wasGst=this.guestLoc.get(guest);
    if(wasGst && wasGst!==room){
      queueTokenMove('.token.guest.' + slug(guest));
      this.guestLoc.set(guest,room);
      log(`${displayGuest(guest)} is moved from ${wasGst} to ${room} due to the suggestion.`);
      renderBoard(this);
      await animatePendingMoves();
    }else if(!wasGst){
      this.guestLoc.set(guest,room);
    }

    const ownerPlayer=this.players.find(p=>p.guest===guest);
    if(ownerPlayer && ownerPlayer.location!==room){
      const prev=ownerPlayer.location;
      // Guest token already animated above; just sync the player location quietly
      ownerPlayer.location=room;
      ownerPlayer.arrivedByOpponentSuggestion=true;
      log(`${ownerPlayer.name} is moved from ${prev} to ${room} due to the suggestion.`);
    }

    // Step e: Move treasure into suggested room and animate
    const wasWeap=this.treasureLoc.get(treasure);
    if(wasWeap && wasWeap!==room){
      queueTokenMove('.token.treasure.' + slug(treasure));
      this.treasureLoc.set(treasure,room);
      log(`${treasure} is moved from ${wasWeap} to ${room} due to the suggestion.`);
      renderBoard(this);
      await animatePendingMoves();
    }else if(!wasWeap){
      this.treasureLoc.set(treasure,room);
    }
    log(`${pl.name} suggests: ${displayGuest(guest)} concealed the ${treasure} in the ${room}.`);

    // Resolve refutations in order
    const order=[];for(let i=1;i<this.players.length;i++) order.push(this.players[(this.turnIndex+i)%this.players.length]);

    for(const other of order){
      const matches=other.hasAnyOf(triple);

      if(matches.length>0){
        let shown;

        // 1) If the refuter is the real human player, give "Coach recommends" when there are multiple matches
        if(other.isHuman){
          let rec = null;

          // Only Sherlock uses adversarial "least informative" logic
          if(this.aiDifficulty === 'sherlock' && matches.length > 1){
            rec = pickLeastInformativeRefuteCard(other, matches, pl);
          }

          const opts = [
            ...(rec ? [{
              label: `Coach recommends: ${rec.type}: ${displayCardName(rec.type, rec.name)}`,
              value: rec,
              className: ''
            }] : []),
            ...matches.map(c => ({
              label: `${c.type}: ${displayCardName(c.type,c.name)}`,
              value: c,
              className: 'secondary'
            }))
          ];

          const pick = await showChoicePrompt(
            'Choose a card to show',
            `<div>You must refute <b>${pl.name}</b> by showing ONE matching card.</div>
             ${rec ? `<div style="margin-top:8px;color:var(--muted);font-size:12px;">
               Coach recommends the least-informative choice.
             </div>` : ``}`,
            opts,
            { allowCancel:false }
          );

          shown = pick;
          log(`You show a card to ${pl.name}.`);
        }

        // 2) If the refuter is the COACH FOCUS player, YOU choose which card they show (with coach advice)
        else if(this.isCoachFocus(other)){
          let rec = null;
          if(this.aiDifficulty === 'sherlock' && matches.length > 1){
            rec = pickLeastInformativeRefuteCard(other, matches, pl);
            if(rec){
              this.obs(`üÇ† Coach recommends showing: ${rec.type}: ${displayCardName(rec.type, rec.name)}`, { byPlayerId: other.id });
            }
          }

          const opts = [
            ...(rec ? [{
              label: `Coach's choice: ${rec.type}: ${displayCardName(rec.type, rec.name)}`,
              value: rec,
              className: ''
            }] : []),
            ...matches.map(c => ({
              label: `${c.type}: ${displayCardName(c.type,c.name)}`,
              value: c,
              className: 'secondary'
            }))
          ];

          const pick = await showChoicePrompt(
            'Choose a card to show',
            `<div>You must refute <b>${pl.name}</b> by showing ONE matching card.</div>
             ${rec ? `<div style="margin-top:8px;color:var(--muted);font-size:12px;">
               Coach's choice is the least-informative option.
             </div>` : ``}`,
            opts,
            { allowCancel:false }
          );

          shown = pick;
          log(`${other.name} refutes the suggestion.`);
        }

        // 3) All other AI refuters: in Sherlock, be adversarial; otherwise keep random behaviour
        else{
          if(this.aiDifficulty === 'sherlock'){
            shown = pickLeastInformativeRefuteCard(other, matches, pl) || choice(matches);
          }else{
            shown = choice(matches);
          }
          log(`${other.name} refutes the suggestion.`);
        }

        // Sherlock++: learning signals
        if(isAdvancedAI(this.aiDifficulty)){
          for(const obs of this.players){
            if(obs.isHuman) continue;
            // Observers learn refuter likely owns one of the triple
            obs.noteRefutePattern(other.id, triple);
          }
          // Suggester AI actually SEES the exact shown card; lock it in
          if(!pl.isHuman && shown){ pl.noteCardShown(shown, other.id); }
        }

        // Coach mode: show the same prompt even though the focus player is not "human"
        if (pl.isHuman || this.isCoachFocus(pl)) {
          await showInfoPrompt(
            'Card Shown',
            `<div><b>${other.name}</b> shows <b>you</b>:</div>
             <div style="margin-top:10px;font-size:18px;">
               <b>${shown.type}: ${displayCardName(shown.type, shown.name)}</b>
             </div>`
          );

          // In Coach mode the focus player is still an AI, so we MUST record the knowledge
          if (!pl.isHuman) {
            pl.markSeen(shown, other.id);
          }
        } else {
          // Legacy knowledge record (still fine)
          pl.markSeen(shown, other.id);
        }

        // Constraint reasoning for Smart/Sherlock observers
        if(isAdvancedAI(this.aiDifficulty)){
          for(const obs of this.players){
            if(obs.id===pl.id) continue; if(obs.id===other.id) continue; if(obs.isHuman) continue;
            obs.addRefuteConstraint(other.id,triple);
          }
        }

        this.applyInference(pl);
        renderWithoutBoard(this);  // board unchanged ‚Äî only notebook/casebook needs update
        return {refuted:true,by:other,card:shown};
      } else {
        // Negative refutation: other could not refute => they do NOT own any of the triple
        if(isAdvancedAI(this.aiDifficulty)){
          for(const obs of this.players){
            if(obs.isHuman) continue;
            for(const c of triple) { obs.markNotOwner(c, other.id); }
            obs.noteNoRefute(other.id, triple);
          }
        }

        // ‚úÖ Smart/Sherlock reasoning log (observer mode): "X could not refute ‚Üí X has none of {A,B,C}"
        if(this.observerMode && (this.aiDifficulty==='smart' || this.aiDifficulty==='sherlock')){
          const cards = triple.map(c=>`${c.type}:${c.name}`).join(', ');
        }

        // continue to next 'other'
      }
    }

    // No one could refute
    log(`No one could refute ${pl.name}'s suggestion.`);
    if(this.observerMode){
      this.obs(`‚úÖ No one refuted ${pl.name}'s suggestion.`);
    }

    // Apply NO-REFUTE deduction for ALL difficulties (AI only).
    if(!pl.isHuman){
      this.noRefuteDeduction(pl, { guest, treasure, room });
    }

    // Smart/Sherlock can still keep unrefuted history for mild inference later.
    // (Basic won't use it, but keeping it doesn't hurt.)
    if(!pl.isHuman){
      pl.unrefuted.push({guest,treasure,room});
    }

        this.applyInference(pl);
        return {refuted:false};
      }

  // === Centre-tile "trial" helpers (ACCUSED ‚Üí NOT GUILTY ‚Üí revert) ===
  beginTrial(pl, acc){
    // Save previous locations so we can revert after NOT GUILTY
    const prevGst = this.guestLoc.get(acc.guest);
    const prevTsr = this.treasureLoc.get(acc.treasure);

    this.trial = {
      stage: 'accused',
      by: pl.name,
      acc: { ...acc },
      prev: { gst: prevGst, tsr: prevTsr }
    };

    // Move accused guest + treasure to the centre (Case File tile)
    this.guestLoc.set(acc.guest, HOLDING_CELL_ID);
    this.treasureLoc.set(acc.treasure, HOLDING_CELL_ID);
  }

  restoreTrial(){
    if(!this.trial) return;
    const { acc, prev } = this.trial;

    // Always restore if we saved anything at all (use != null to allow empty strings, 0, false, etc.)
    if(prev && prev.gst != null) this.guestLoc.set(acc.guest, prev.gst);
    if(prev && prev.tsr != null) this.treasureLoc.set(acc.treasure,  prev.tsr);

    // Clear centre trial state (this removes room token + restores CASE FILE)
    this.trial = null;
  }

  checkAccusation(a){
    return a.guest===this.solution.guest &&
           a.treasure===this.solution.treasure &&
           a.room===this.solution.room;
  }

  async accuse(pl,acc){
    log(`${pl.name} ACCUSES: ${displayGuest(acc.guest)} concealed the ${acc.treasure} in the ${acc.room}!`);

    this.beginTrial(pl, acc);
    renderAll(this);

    if(this.observerMode){
      this.obs(`‚öñÔ∏è ${pl.name} ACCUSES: ${displayGuest(acc.guest)} / ${acc.treasure} / ${acc.room}`);
    }

    // Show overlay ‚Äî human must click to reveal verdict
    await new Promise(resolve => {
      showAccusationOverlay({
        accuser: pl.name,
        guest:    acc.guest,
        treasure: acc.treasure,
        room:     acc.room,
        onReveal: resolve
      });
    });

    // Determine verdict
    const ok = this.checkAccusation(acc);

    if(ok){
      // === CORRECT: CONVICTED ===
      this.gameOver = true;
      this.convicted = { guest:acc.guest, treasure:acc.treasure, room:acc.room, winner:pl.name };
      this.trial = null;
      renderAll(this);

      if(this.observerMode){
        this.obs(`üëÆ‚Äç‚ôÇÔ∏è CONVICTED: ${pl.name} wins.`);
      }

      await new Promise(resolve => {
        transitionOverlayConvicted({
          winner:   pl.name,
          guest:    this.solution.guest,
          treasure: this.solution.treasure,
          room:     this.solution.room,
          onRestart: async () => {
            hideAccusationOverlay();
            resetUIForSetup();
            tpShowTitlePages();
            await startNewGame(game, { skipConfirm:true, fromTitlePage:true });
            resolve();
          },
          onRestartSame: async () => {
            hideAccusationOverlay();
            await restartSameSettings(game);
            resolve();
          }
        });
      });

      return { correct:true };
    }

    // === WRONG: NOT GUILTY ===
    log(`‚ùå Wrong accusation. ${pl.name} is eliminated from taking turns (but can still refute).`);
    pl.eliminated = true;

    if(this.trial) this.trial.stage = 'notguilty';
    renderAll(this);

    if(this.observerMode){
      this.obs(`üïä NOT GUILTY: ${pl.name} eliminated from taking turns.`);
    }

    if(pl.isHuman || this.isCoachFocus(pl)){
      await new Promise(resolve => {
        transitionOverlayNotGuilty({
          accuser: pl.name,
          onDismiss: resolve
        });
      });

      this.restoreTrial();
      renderAll(this);
      return { correct:false };
    }

    // AI wrong accusation ‚Äî no further overlay needed
    return { correct:false, revertAfterSummary:true };
  }

/* ================================================================================
 * [SECTION 6] GAME FLOW FUNCTIONS
 * ================================================================================
 * Turn execution, movement, suggestions, refutations, and accusations
 * ================================================================================ */

  async beginTurn(){
    if(this.gameOver) return;
    const pl=this.currentPlayer();
    this.dice=null;this.reachable=new Set();
    this.awaitingMove=false;this.awaitingDecision=!!pl.arrivedByOpponentSuggestion;
    this.stayedInsteadOfRoll=false;
    this.updateTurnUI();

    if(pl.eliminated){ await this.endTurn(); return; }
    if(pl.isHuman || this.isCoachFocus(pl)){
      this.humanTurnsStarted++;
      await this.showRollPromptForHuman();
    }else {
      await this.aiTurn(pl);
    }
  }

  async showRollPromptForHuman(){
    const pl=this.currentPlayer();
    if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver || pl.eliminated) return;
    const firstEver=(this.humanTurnsStarted===1);
    const movedHere=this.awaitingDecision;
    let actions=[];
    if(movedHere){
      actions=[{label:'Roll Dice',value:'roll'},{label:'Stay',value:'stay',className:'secondary'},{label:'Make Accusation',value:'accuse',className:'danger'}];
    }else if(firstEver){
      actions=[{label:'Roll Dice',value:'roll'}];
    }else{
      actions=[{label:'Roll Dice',value:'roll'},{label:'Make Accusation',value:'accuse',className:'danger'}];
    }
    let body=movedHere?`<div>You were moved to <b>${pl.location}</b> by an opponent's suggestion.</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">Choose what to do this turn.</div>`
                        :`<div>It's your turn in <b>${pl.location}</b>.</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">Roll the dice to move.</div>`;
    // Coach mode: compute & log recommendation, and add a Coach's choice button
    let coachRec = null;
    if(this.isCoachFocus(pl)){
      coachRec = this.coachStartRecommendation(pl);

      const label =
        coachRec.action === 'accuse' ? 'ACCUSE' :
        coachRec.action === 'stay'   ? 'STAY'   : 'ROLL';

      // Log what Coach's choice will do
      this.obs(`üéØ Coach's choice: ${label}`, { byPlayerId: pl.id });

      // Also show it in the prompt body so the user can see it before clicking
      body += `<div style="margin-top:10px;color:var(--accent);font-size:12px;">
                <b>Coach recommends:</b> ${label}
              </div>`;

      // Put Coach's choice first
      actions = [{ label:"Coach's choice", value:'coach' }, ...actions];
    }

    const pick=await renderPrompt({title:'Your Turn',bodyHTML:body,actions});
    clearGameplayPrompt();
    if(pick==='coach' && this.isCoachFocus(pl)){
      const rec = this.coachStartRecommendation(pl);

      if(rec.action === 'accuse'){
        await this.humanAccuse({
          prefill: rec.acc,
          onCancel: () => this.showRollPromptForHuman()
        });
        return;
      }
      if(rec.action === 'stay'){
        await this.humanStayAndSuggest();
        return;
      }
      // default: roll
      await this.humanRollAndMove();
      return;
    }
    if(pick==='accuse'){ await this.humanAccuse({onCancel:()=>this.showRollPromptForHuman()}); return; }
    if(pick==='stay'){ await this.humanStayAndSuggest(); return; }
    if(pick==='roll'){ await this.humanRollAndMove(); return; }
  }

  async humanRollAndMove(){
    const pl=this.currentPlayer();
    if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver || pl.eliminated) return;
    if(this.stayedInsteadOfRoll) return;
    if(this.awaitingDecision){ this.awaitingDecision=false; pl.arrivedByOpponentSuggestion=false; }
    this.dice=randInt(1,6);
    this.reachable=this.computeReachable(pl.location,this.dice);
    this.awaitingMove=true;
    log(`You rolled a ${this.dice}. Choose a reachable room to move.`);
    this.updateTurnUI();
    setPromptMessage('Dice Result',`<div>You rolled a <b>${this.dice}</b>.</div><div style="margin-top:8px;color:var(--muted);">Select a highlighted room to move into.</div>`);
    // Coach mode: recommend a room and provide a Coach's choice button to auto-move
    if(this.isCoachFocus(pl)){
      const dest = this.coachRecommendMove(pl);
      this.obs(`üß≠ Coach's choice: MOVE to ${dest}`, { byPlayerId: pl.id });

      // Add a button into the currently button-less move prompt
      const box = el('gameplayPromptBox');
      const actionsDiv = box ? box.querySelector('.promptActions') : null;
      if(actionsDiv){
        actionsDiv.innerHTML = '';
        const btn = document.createElement('button');
        btn.textContent = "Coach's choice";
        btn.onclick = () => this.humanMoveTo(dest);
        actionsDiv.appendChild(btn);
      }

      // Also show the recommendation in the prompt body
      const bodyDiv = box ? box.querySelector('.promptBody') : null;
      if(bodyDiv){
        bodyDiv.innerHTML += `<div style="margin-top:10px;color:var(--accent);font-size:12px;">
                                <b>Coach recommends:</b> Move to <b>${dest}</b>
                              </div>`;
      }
    }
  }

  async humanStayAndSuggest(){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver || pl.eliminated) return;
    if(!this.awaitingDecision) return;
    this.awaitingDecision=false; this.stayedInsteadOfRoll=true; pl.arrivedByOpponentSuggestion=false;
    log(`You chose to stay in ${pl.location} (no roll).`);
    this.updateTurnUI();
    await this.openSuggestionPromptAuto();
  }

  async humanMoveTo(room){
    const pl=this.currentPlayer();
    if(!(pl.isHuman || this.isCoachFocus(pl)) || !this.awaitingMove) return;
    if(!this.reachable.has(room)) return;
    if(pl.guest) queueTokenMove('.token.guest.' + slug(pl.guest));
    pl.location=room; if(pl.guest) this.guestLoc.set(pl.guest,room);
    this.awaitingMove=false; pl.arrivedByOpponentSuggestion=false;
    log(`You moved to ${room}.`);
    renderBoard(this);
    await animatePendingMoves();
    this.updateTurnUI(false);  // pills only ‚Äî board already painted by animation
    await this.openSuggestionPromptAuto();
  }

  async openSuggestionPromptAuto(){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || pl.eliminated || this.gameOver) return;
    if(this.awaitingMove) return;
    const room = pl.location;

    // Coach mode: compute recommendation and log it
    let coachPick = null;
    if(this.isCoachFocus(pl)){
      if(isSherlock(this.aiDifficulty)){
        // Mirror the same "thinking" text aiTurn uses (so the log stays the same style)
        const rankEntropy = (type, list) => {
          const arr = list.map(n => ({ n, e: pl.entropyForCardKey(pl.cardKey(type, n)) }));
          arr.sort((a,b)=>b.e-a.e);
          return arr.slice(0,3);
        };
        const gstPool = pl.possibleSet('Guest');
        const tsrPool = pl.possibleSet('Treasure');
        const gstCands = gstPool.length ? gstPool : GUESTS;
        const tsrCands = tsrPool.length ? tsrPool : TREASURES;
        const topGst = rankEntropy('Guest', gstCands);
        const topTsr = rankEntropy('Treasure', tsrCands);

        const pick = pl.pickSmartSuggestionParts();
        coachPick = { guest: pick.guest, treasure: pick.treasure };

        this.obs(
          `üîé Let's see... top guests are ${topGst.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')} and top treasures are ${topTsr.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')}. I'll check out ${coachPick.guest} and ${coachPick.treasure} in the ${room}.`,
          { byPlayerId: pl.id }
        );
      } else {
        // Smart/basic style recommendation (same message format as aiTurn uses for smart)
        const sC = pl.possibleSet('Guest');
        const wC = pl.possibleSet('Treasure');
        const gstCands = sC.length ? sC : GUESTS;
        const tsrCands = wC.length ? wC : TREASURES;

        coachPick = { guest: choice(gstCands), treasure: choice(tsrCands) };

        if(this.aiDifficulty==='smart'){
          this.obs(
            `üîé Let's see... guests remaining are ${gstCands.length} and treasures remaining are ${tsrCands.length}. I'll check out ${coachPick.guest} and ${coachPick.treasure} in the ${room}.`,
            { byPlayerId: pl.id }
          );
        }
      }
    }

    const gst = GUESTS.map(s =>
      `<option value="${s}" ${(coachPick && coachPick.guest===s) ? 'selected' : ''}>${displayGuest(s)}</option>`
    ).join("");

    const tsr = TREASURES.map(w =>
      `<option value="${w}" ${(coachPick && coachPick.treasure===w) ? 'selected' : ''}>${w}</option>`
    ).join("");
    const coachNote = coachPick
      ? `<div style="margin-top:10px;color:var(--accent);font-size:12px;"><b>Coach recommends:</b> ${displayGuest(coachPick.guest)} / ${coachPick.treasure}</div>`
      : '';
    const html=`<div><b>Room:</b> ${room}</div>
      <div style="margin-top:10px;" class="row">
        <label>Guest: <select id="selGuest">${gst}</select></label>
        <label>Treasure: <select id="selTreasure">${tsr}</select></label>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px;">Pick a guest and treasure to make a suggestion.</div>
      ${coachNote}`;
    const suggActions = coachPick
      ? [{label:"Coach's choice", value:'coach'}, {label:'Suggest', value:true}]
      : [{label:'Suggest', value:true}];
    const go=await renderPrompt({title:'Make a Suggestion',bodyHTML:html,actions:suggActions});
    const guest = go==='coach' ? coachPick.guest : document.getElementById('selGuest')?.value;
    const treasure = go==='coach' ? coachPick.treasure : document.getElementById('selTreasure')?.value;
    clearGameplayPrompt();
    if(go&&guest&&treasure){
      const result = await this.makeSuggestion(pl,guest,treasure,room);

      // Coach mode: after suggestion resolves (refuted or not), if threshold met then auto-open accusation prompt
      if(this.isCoachFocus(pl)){
        const acc = this.coachAccusationPlan(pl);
        if(acc){
          this.obs(`üõë Coach's choice: ACCUSE ${acc.guest} / ${acc.treasure} / ${acc.room}`, { byPlayerId: pl.id });

          await this.humanAccuse({
            prefill: acc,
            onCancel: () => this.showPostSuggestionPrompt(result,{guest,treasure,room})
          });

          // If the accusation ended the game, stop here
          if(this.gameOver) return;
        }
      }

      await this.showPostSuggestionPrompt(result,{guest,treasure,room});
    }else{
      await this.endTurn();
    }
  }

  async showPostSuggestionPrompt(result,triple){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver) return;
    const title=result.refuted?'Suggestion Result':'No One Could Refute!';
    const body=result.refuted
      ?`<div>Your suggestion has been <b>refuted</b>.</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">What would you like to do next?</div>`
      :`<div><b>No one</b> could refute your suggestion:</div>
        <div style="margin-top:8px;"><b>${displayGuest(triple.guest)}</b> concealed the <b>${triple.treasure}</b> in the <b>${triple.room}</b>.</div>
        <div style="margin-top:8px;color:var(--muted);font-size:12px;">What would you like to do next?</div>`;
    const pick=await renderPrompt({title,bodyHTML:body,actions:[
      {label:'End Turn',value:'end',className:'secondary'},
      {label:'Make Accusation',value:'accuse',className:'danger'}
    ]});
    clearGameplayPrompt();
    if(pick==='accuse'){ await this.humanAccuse({onCancel:()=>this.showPostSuggestionPrompt(result,triple)}); }
    else await this.endTurn();
  }

  async humanAccuse({onCancel, prefill=null}={}){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || pl.eliminated || this.gameOver) return;
    if(this.awaitingMove) return;
    const gst = GUESTS.map(s =>
      `<option value="${s}" ${(prefill && prefill.guest===s) ? 'selected' : ''}>${displayGuest(s)}</option>`
    ).join("");

    const tsr = TREASURES.map(w =>
      `<option value="${w}" ${(prefill && prefill.treasure===w) ? 'selected' : ''}>${w}</option>`
    ).join("");

    const rms = ROOMS.map(r =>
      `<option value="${r}" ${(prefill && prefill.room===r) ? 'selected' : ''}>${r}</option>`
    ).join("");
    const html=`<div style="color:var(--warn)"><b>Warning:</b> If you are wrong, you will be eliminated from taking turns.</div>
      <div style="margin-top:10px;" class="row">
        <label>Guest: <select id="accGst">${gst}</select></label>
        <label>Treasure: <select id="accWeap">${tsr}</select></label>
        <label>Room: <select id="accRoom">${rms}</select></label>
      </div>`;
    const go=await renderPrompt({title:'Make an Accusation',bodyHTML:html,actions:[
      {label:'Cancel',value:false,className:'secondary'},
      {label:'Accuse',value:true,className:'danger'}
    ]});
    const acc={guest:document.getElementById('accGst')?.value,treasure:document.getElementById('accWeap')?.value,room:document.getElementById('accRoom')?.value};
    clearGameplayPrompt();
    if(go&&acc.guest&&acc.treasure&&acc.room){
      await this.accuse(pl,acc);
      if(!this.gameOver) await this.endTurn();
    }else{
      if(this.gameOver) return;
      if(typeof onCancel==='function'){ await onCancel(); return; }
      if(this.awaitingMove){
        setPromptMessage('Choose a Room',`<div style="color:var(--muted);">Select a highlighted room to move into.</div>`);
      }else{
        await this.showRollPromptForHuman();
      }
    }
  }

  roomsOptionsHTML(){ return ROOMS.map(r => `<option value="${r}">${r}</option>`).join(""); }

  async endTurn(){
    if(this.gameOver) return;
    this.turnIndex=this.nextTurnIndex(this.turnIndex);
    this.updateTurnUI();
    await this.beginTurn();
  }

/* ================================================================================
 * [SECTION 5] AI LOGIC
 * ================================================================================
 * AI difficulty levels, move selection, suggestions, and accusation decisions
 * ================================================================================ */

  async aiTurn(pl){
    const sid=this.sessionId;
    if(this.gameOver) return;

    const summary=[];
    log(`${pl.name}'s turn‚Ä¶`);
    summary.push('Turn started.');
    if(!this.isActiveSession(sid)) return;

    let choseStay=false;

    // Stay vs Roll decision - prioritize GUILTY rooms, avoid INNOCENT rooms
    if (pl.arrivedByOpponentSuggestion) {
      const currentRoomInnocent=pl.isCardInnocent('Room',pl.location);
      const currentRoomGuilty=pl.isCardGuilty('Room',pl.location);
      const roomsLeft=pl.possibleSet('Room');
      
      if(currentRoomInnocent){
        // Current room is INNOCENT (‚úì in a player column) ‚Üí definitely roll
        choseStay=false;
      }else if(currentRoomGuilty){
        // Current room is GUILTY (üö© in CF) ‚Üí definitely stay
        choseStay=true;
      }else if(isSherlock(this.aiDifficulty)){
        // Current room status unknown - use probability
        const isKeyRoom=roomsLeft.includes(pl.location);
        choseStay=isKeyRoom?(Math.random()<0.72):(Math.random()<0.28);
      }else if(isAdvancedAI(this.aiDifficulty)){
        const isKeyRoom=roomsLeft.includes(pl.location);
        choseStay=isKeyRoom?(Math.random()<0.65):(Math.random()<0.35);
      }else{
        choseStay=(Math.random()<0.45);
      }
      summary.push(choseStay?`Chose to STAY in ${pl.location} (no roll).`:`Chose to ROLL (was eligible to stay).`);
      pl.arrivedByOpponentSuggestion=false;
      if(!this.isActiveSession(sid)) return;
    }

    if(!choseStay){
      // Step 3: Roll dice and build option list of reachable rooms
      this.dice = randInt(1,6);
      this.reachable = this.computeReachable(pl.location, this.dice);
      log(`${pl.name} rolled ${this.dice}.`);
      summary.push(`Rolled a ${this.dice}.`);
      if(!this.isActiveSession(sid)) return;

      const reach=[...this.reachable];
      
      // Use pickBestRoom which implements the specification logic
      let dest = this.pickBestRoom(pl, reach);

      // Sherlock "second-best" flavor: compute after base dest, before moving
      if(isSherlock(this.aiDifficulty)){
        if(Math.random()<0.12){
          const possibleRooms=new Set(pl.possibleSet('Room'));
          const scored = reach.map(r=>({ r, s:(possibleRooms.has(r)?2:0)+Math.random()*0.5 }))
                              .sort((a,b)=>b.s-a.s);
          if(scored.length>1) dest=scored[1].r;
        }
      }

      // Defensive fallback
      if(!dest) dest=pl.location;

      const from=pl.location;
      if(pl.guest) queueTokenMove('.token.guest.' + slug(pl.guest));
      pl.location=dest;
      if(pl.guest) this.guestLoc.set(pl.guest, dest);

      log(`${pl.name} moved from ${from} to ${dest}.`);
      summary.push(`Moved from ${from} to ${dest}.`);
      renderBoard(this);
      await animatePendingMoves();
      this.updateTurnUI(false);  // pills only ‚Äî board already painted
      if(!this.isActiveSession(sid)) return;
    } else {
      // Chose to stay
      this.dice=null; this.reachable=new Set();
      renderAll(this);
    }

    // Sherlock++: suggestion target selection + thought process logging
    let guest, treasure;
    const room = pl.location;

    if (isSherlock(this.aiDifficulty)) {
      // Compute top entropy candidates (informative picks)
      const rankEntropy = (type, list) => {
        const arr = list.map(n => ({
          n,
          e: pl.entropyForCardKey(pl.cardKey(type, n))
        }));
        arr.sort((a,b)=>b.e-a.e);
        return arr.slice(0,3);
      };

      const gstPool = pl.possibleSet('Guest');
      const tsrPool = pl.possibleSet('Treasure');

      const gstCands = gstPool.length ? gstPool : GUESTS;
      const tsrCands = tsrPool.length ? tsrPool : TREASURES;

      const topGst = rankEntropy('Guest', gstCands);
      const topTsr = rankEntropy('Treasure',  tsrCands);

      const pick = pl.pickSmartSuggestionParts();
      guest = pick.guest;
      treasure  = pick.treasure;

      if(this.observerMode){
        this.obs(`üîé Let's see... top guests are ${topGst.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')} and top treasures are ${topTsr.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')}. I'll check out ${guest} and ${treasure} in the ${room}.`, { byPlayerId: pl.id });
      }

    } else {
      // Smart/basic: pick from remaining (uncleared) candidates
      const sC = pl.possibleSet('Guest');
      const wC = pl.possibleSet('Treasure');

      const gstCands = sC.length ? sC : GUESTS;
      const tsrCands = wC.length ? wC : TREASURES;

      guest = choice(gstCands);
      treasure  = choice(tsrCands);

      if(this.observerMode && this.aiDifficulty==='smart'){
        this.obs(`üîé Let's see... guests remaining are ${gstCands.length} and treasures remaining are ${tsrCands.length}. I'll check out ${guest} and ${treasure} in the ${room}.`, { byPlayerId: pl.id });
      }
    }

    summary.push(`Suggested: ${displayGuest(guest)} concealed the ${treasure} in the ${room}.`);
    const result=await this.makeSuggestion(pl,guest,treasure,room);
    if(!this.isActiveSession(sid)) return;
    summary.push(result.refuted?`Refuted by ${result.by?.isHuman ? 'You' : (result.by?.name ?? 'another player')}.`:'No one could refute the suggestion.');

    // Sherlock++: beliefs decay each AI turn
    if (isSherlock(this.aiDifficulty)) pl.decayBeliefs();

    // === Accusation logic ===
    let accused=false;
    let accOutcome=null; // used to revert NOT GUILTY display after summary (AI only)    

    // A) Certain accusation (all difficulties)
    if(!pl.eliminated && pl.isConfidentSolution()){
      if(!this.isActiveSession(sid)) return;
      const acc=pl.inferredAccusation();

      if(this.observerMode){
        this.obs(`üõë Time to act! Accusing ${acc.guest} of concealing the ${acc.treasure} in the ${acc.room}.`, { byPlayerId: pl.id });
      }

      summary.push(`Accused (certain): ${displayGuest(acc.guest)} concealed the ${acc.treasure} in the ${acc.room}.`);
      accOutcome = await this.accuse(pl,acc);
      accused=true;
      if(accOutcome && accOutcome.correct===false){
        summary.push('Verdict: üïä NOT GUILTY (eliminated).');
      }
    }
    // B) Sherlock++: belief-aware early accusation (bold, sometimes wrong)
    else if(!pl.eliminated && isSherlock(this.aiDifficulty)){
      const plan = pl.planAccusationWithBeliefs();
      if(this.observerMode && plan){
        this.obs(`‚ùì Do I have enough evidence? Did ${plan.acc.guest} conceal the ${plan.acc.treasure} in the ${plan.acc.room}? I'll only accuse if the evidence holds.`, { byPlayerId: pl.id });
      }

      const hasEvidence = (pl.seen.size > pl.own.size) || pl.constraints.length > 0 || pl.unrefuted.length > 0;
      if (hasEvidence && plan && plan.confidence >= AI_CFG.sherlock.earlyAccuseMinConfidence) {
        if (Math.random() < AI_CFG.sherlock.earlyAccuseChance) {
          if(!this.isActiveSession(sid)) return;
          summary.push(`Accused (early, conf=${plan.confidence.toFixed(2)}): ${displayGuest(plan.acc.guest)} concealed the ${plan.acc.treasure} in the ${plan.acc.room}.`);
          accOutcome = await this.accuse(pl, plan.acc);
          accused = true;
          if(accOutcome && accOutcome.correct===false){
            summary.push('Verdict: üïä NOT GUILTY (eliminated).');
          }
        }
      } else if (hasEvidence && Math.random() < AI_CFG.sherlock.mistakeRate) {
        // Rare outright mistake to feel human
        if(!this.isActiveSession(sid)) return;
        const b = pl.planAccusationWithBeliefs();
        summary.push(`Accused (mistake): ${displayGuest(b.acc.guest)} concealed the ${b.acc.treasure} in the ${b.acc.room}.`);
        accOutcome = await this.accuse(pl, b.acc);
        accused = true;
        if(accOutcome && accOutcome.correct===false){
          summary.push('Verdict: üïä NOT GUILTY (eliminated).');
        }
      }
    }

    if (accused) {
      if (!this.isActiveSession(sid)) return;
      if (this.gameOver) return;
    }

    summary.push('Turn ended.');
    await this.showOpponentTurnSummary(pl,summary);
    // If AI made a wrong accusation, revert the centre display AFTER the summary is dismissed
    if(accOutcome && accOutcome.revertAfterSummary){
      this.restoreTrial();
      renderAll(this);
    }

    if(!this.isActiveSession(sid)) return;
    await this.endTurn();
  }

  async showOpponentTurnSummary(player, lines){
    lines.forEach(l => log(`[${player.name}] ${l}`));
    const body = lines
      .filter(l => l !== 'Turn started.' && l !== 'Turn ended.')
      .map(l => `<div style="margin-bottom:5px;">&#x2014; ${l}</div>`)
      .join('');
    await showInfoPrompt(
      player.name + '\u2019s turn',
      `<div style="font-family:'EB Garamond',Georgia,serif;font-size:14px;line-height:1.7;">${body || '<em>Nothing of note.</em>'}</div>`
    );
    clearGameplayPrompt();
  }
}

/* Rendering */
const HOLDING_CELL_ID='HoldingCell';
const BOARD_LAYOUT={
  'Study':{col:[1,5],row:[1,3]},
  'Library':{col:[1,5],row:[3,5]},
  'Billiard Room':{col:[1,5],row:[5,7]},
  'Conservatory':{col:[1,5],row:[7,9]},
  'Hall':{col:[5,9],row:[1,4]},
  'Ballroom':{col:[5,9],row:[6,9]},
  'Lounge':{col:[9,13],row:[1,4]},
  'Dining Room':{col:[9,13],row:[4,7]},
  'Kitchen':{col:[9,13],row:[7,9]}
};
const CENTER_CELL={col:[5,9],row:[4,6]};

/* ================================================================================
 * [SECTION 8] UI RENDERING - PLAYERS & CARDS
 * ================================================================================
 * Display player information, hands, and card visuals
 * ================================================================================ */

function renderPlayers(game){
  const box=el('playersBox');box.innerHTML='';
  game.players.forEach((p,idx)=>{
    const div=document.createElement('div');
    div.style.display='flex';div.style.justifyContent='space-between';
    div.style.alignItems='center';div.style.padding='6px 0';
    div.style.borderBottom='1px solid rgba(255,255,255,.06)';
    const left=document.createElement('div');
    let label;
    if(game.observerMode && p.id===game.observerFocusId) label = `Coach Focus (${p.name})`;
    else label = p.isHuman ? `You (${p.name})` : p.name;
    left.innerHTML =
      '<b>' + label + '</b> ' +
      '<span style="color:var(--muted);font-size:12px;">@ ' + p.location + '</span>' +
      (game.aiDifficulty === 'sherlock'
        ? ' <span style="color:var(--muted);font-size:12px;margin-left:8px;">Cards: ' + (p.hand ? p.hand.length : 0) + '</span>'
        : '') +
      (p.eliminated ? '<span class="pill bad" style="margin-left:6px;">eliminated</span>' : '');
    const right=document.createElement('div');
    const isTurn=idx===game.turnIndex && !game.gameOver;
    right.innerHTML=isTurn?`<span class="pill good">active</span>`:`<span class="pill">‚Äî</span>`;
    div.appendChild(left);div.appendChild(right);box.appendChild(div);
  });
}

function renderHand(game){
  const you=game.players[0];
  const box=el('handBox');box.innerHTML='';
  const sorted=[...you.hand].sort((a,b)=>a.type.localeCompare(b.type)||a.name.localeCompare(b.name));
  sorted.forEach(c=>{
    const badge=document.createElement('div');
    badge.className='pill good';badge.style.display='inline-block';badge.style.margin='4px 6px 0 0';
    badge.textContent=`${c.type}: ${displayCardName(c.type,c.name)}`;
    box.appendChild(badge);
  });
  if(!sorted.length) box.innerHTML=`<span class="pill">(no cards?)</span>`;
}

/* ================================================================================
 * [SECTION 9] UI RENDERING - NOTEBOOK
 * ================================================================================
 * Checklist rendering, note-taking interface, and probability displays
 * ================================================================================ */

function renderNotebook(game){
  // Get player initials for column headers
  const playerInitials = game.players.map(p => {
    if(p.isHuman && !game.observerMode) return 'Own';
    // Get initials from guest name
    const guest = p.guest || p.name;
    const words = guest.split(' ');
    if(words.length > 1) return words.map(w => w[0]).join('');
    return guest.substring(0, 2).toUpperCase();
  });

  // Icons
  const GST_ICON = {
    "Forest": "üé©","Brimstone": "üéñÔ∏è","Rouge": "üíã","Sapphire": "üíé","Lavender": "üéì","Weisse": "üëí"
  };
  const TSR_ICON = {
    "Portrait":"üñºÔ∏è","Ornaments":"‚öîÔ∏è","Documents":"üìú","Coins":"ü™ô","Necklace":"üìø","Watch":"‚è±Ô∏è"
  };
  const ROOM_ICON_LOCAL = {
    "Study": "üìù","Hall":"üß•","Lounge":"üõãÔ∏è","Library":"üìñ","Billiard Room":"üé±",
    "Dining Room":"üçΩÔ∏è","Conservatory":"ü™¥","Ballroom":"üíÉ","Kitchen":"ü•©"
  };

  // Load saved grid state
  const gridState = loadClueGrid();
  const gridNotes = loadClueGridNotes();

  // Render unified grid with all categories (with repeated dark header per category)
  const container = el('noteUnified');
  if(!container) return;

  const colCount = playerInitials.length + 2; // left label + players + CF
  let html = `<table class="clueGrid"><tbody>`;

  const categories = [
    { title: 'GUESTS', cards: GUESTS, type: 'Guest', icons: GST_ICON },
    { title: 'TREASURES',  cards: TREASURES,  type: 'Treasure',  icons: TSR_ICON },
    { title: 'ROOMS',    cards: ROOMS,    type: 'Room',    icons: ROOM_ICON_LOCAL }
  ];

  categories.forEach(category => {
    // --- Repeated dark header row for this category ---
    html += `<tr class="catHead">`;
    html += `<th style="text-align:left; min-width:100px;">${category.title}</th>`;
    playerInitials.forEach((initial, idx) => {
      html += `<th title="${game.players[idx].name}">${initial}</th>`;
    });
    html += `<th title="Case File (Solution)">CF</th>`;
    html += `</tr>`;

    // --- Card rows for this category ---
    category.cards.forEach(cardName => {
      const key = `${category.type}:${cardName}`;
      const icon = category.icons[cardName] || '';
      const displayName = displayCardName(category.type, cardName);

      // Main row with selects
      html += `<tr>`;
      html += `<td class="cardName"><span class="ico">${icon}</span>${displayName}</td>`;

      // Player columns
      playerInitials.forEach((initial, pIdx) => {
        const cellKey = `${key}\nP${pIdx}`;
        const value = gridState[cellKey] || '';
        html += `<td><select data-key="${cellKey}" data-type="player">
          <option value="">${value === '' ? '„ÄÄ' : ''}</option>
          <option value="‚úÖ" ${value === '‚úÖ' ? 'selected' : ''}>‚úÖ</option>
          <option value="‚úó" ${value === '‚úó' ? 'selected' : ''}>‚úó</option>
          <option value="?" ${value === '?' ? 'selected' : ''}>?</option>
        </select></td>`;
      });

      // CF column
      const cfKey = `${key}\nCF`;
      const cfValue = gridState[cfKey] || '';
      html += `<td><select data-key="${cfKey}" data-type="cf">
        <option value="">${cfValue === '' ? '„ÄÄ' : ''}</option>
        <option value="üö©" ${cfValue === 'üö©' ? 'selected' : ''}>üö©</option>
        <option value="‚úó" ${cfValue === '‚úó' ? 'selected' : ''}>‚úó</option>
        <option value="?" ${cfValue === '?' ? 'selected' : ''}>?</option>
      </select></td>`;

      html += `</tr>`;

      // Notes row (single input spanning all columns)
      const noteKey = `${key}\nnote`;
      const noteValue = gridNotes[noteKey] || '';
      html += `<tr><td colspan="${colCount}" class="notesRow">`;
      html += `<input type="text" class="noteInput" data-notekey="${noteKey}"
        value="${noteValue}" placeholder="Notes...">`;
      html += `</td></tr>`;
    });
  });

  html += `</tbody></table>`;
  container.innerHTML = html;

  // Add change listeners for selects
  container.querySelectorAll('select').forEach(select => {
    select.addEventListener('change', (e) => {
      const key = e.target.dataset.key;
      const value = e.target.value;
      const state = loadClueGrid();
      if(value === '') delete state[key];
      else state[key] = value;
      saveClueGrid(state);
    });
  });

  // Add change listeners for notes
  container.querySelectorAll('.noteInput').forEach(input => {
    input.addEventListener('input', (e) => {
      const noteKey = e.target.dataset.notekey;
      const value = e.target.value;
      const notes = loadClueGridNotes();
      if(value === '') delete notes[noteKey];
      else notes[noteKey] = value;
      saveClueGridNotes(notes);
    });
  });
}

// Grid state persistence
function loadClueGrid(){
  try{
    const s = localStorage.getItem('clueGrid');
    return s ? JSON.parse(s) : {};
  }catch(e){
    return {};
  }
}

function saveClueGrid(state){
  try{
    localStorage.setItem('clueGrid', JSON.stringify(state));
  }catch(e){
    console.warn('Could not save grid state:', e);
  }
}

function loadClueGridNotes(){
  try{
    const s = localStorage.getItem('clueGridNotes');
    return s ? JSON.parse(s) : {};
  }catch(e){
    return {};
  }
}

function saveClueGridNotes(notes){
  try{
    localStorage.setItem('clueGridNotes', JSON.stringify(notes));
  }catch(e){
    console.warn('Could not save grid notes:', e);
  }
}

function clearClueGrid(){
  try{
    localStorage.removeItem('clueGrid');
    localStorage.removeItem('clueGridNotes');
  }catch(e){}
}

function renderObserverCasebook(game){
  const focus = game.players[game.observerFocusId];

  // Replace panel header
  const rightPanel = document.querySelector('.rightPanel h2');
  if(rightPanel) rightPanel.textContent = 'Casebook';

  // Column headers: focus player shows as "Own"
  const playerInitials = game.players.map((p, idx) => {
    if(idx === game.observerFocusId) return 'Own';
    const guest = p.guest || p.name;
    const words = String(guest).split(' ');
    if(words.length > 1) return words.map(w => w[0]).join('');
    return String(guest).substring(0, 2).toUpperCase();
  });

  // Icons
  const GST_ICON = {
    "Forest": "üé©","Brimstone": "üéñÔ∏è","Rouge": "üíã","Sapphire": "üíé","Lavender": "üéì","Weisse": "üëí"
  };
  const TSR_ICON = {
    "Portrait":"üñºÔ∏è","Ornaments":"‚öîÔ∏è","Documents":"üìú","Coins":"ü™ô","Necklace":"üìø","Watch":"‚è±Ô∏è"
  };
  const ROOM_ICON_LOCAL = {
    "Study": "üìù","Hall":"üß•","Lounge":"üõãÔ∏è","Library":"üìñ","Billiard Room":"üé±",
    "Dining Room":"üçΩÔ∏è","Conservatory":"ü™¥","Ballroom":"üíÉ","Kitchen":"ü•©"
  };

  // Sherlock probability helper
  const getSolutionProb = (type, name) => {
    const key = focus.cardKey(type, name);
    if(focus.seen.has(key)) return 0;

    if(typeof focus.caseFileProbNormalized === 'function'){
      return focus.caseFileProbNormalized(type, name);
    }

    const w = focus.ownerWeights?.get(key);
    if(!w) return 0.0;
    const pCase = w.get(CASE_FILE_ID) ?? 0;
    return Math.max(0, Math.min(1, pCase));
  };

  // Coach-mode card info (read-only marks + CF + note/prob)
  const getCardInfo = (type, name) => {
    const key = focus.cardKey(type, name);
    const playerMarks = new Array(game.players.length).fill('');
    let cfMark = '';
    let noteText = '';
    let hasProb = false;
    let prob = 0;

    const ownerId = focus.knownOwners.get(key);
    const meta = focus.knowledgeMeta.get(key);

    // If another card in this category is already guilty, this one is automatically NOT CF
    const categoryList =
      (type === 'Guest') ? GUESTS :
      (type === 'Treasure')  ? TREASURES  :
                             ROOMS;

    const anotherIsGuilty = categoryList.some(cardName => {
      if(cardName === name) return false;
      const otherKey = focus.cardKey(type, cardName);
      const otherMeta = focus.knowledgeMeta.get(otherKey);
      return otherMeta?.status === 'guilty';
    });

    if(anotherIsGuilty){
      // ruled out of CF, show as eliminated everywhere
      playerMarks.fill('‚úó');
      cfMark = '‚úó';
      noteText = 'innocent';
      return { playerMarks, cfMark, noteText, hasProb: false, prob: 0 };
    }

    // BASIC: only show ‚úÖ for owned/seen and üö© for guilty
    if(game.aiDifficulty === 'basic'){
      game.players.forEach((player, pIdx) => {
        if(player.id === focus.id && focus.own.has(key)){
          playerMarks[pIdx] = '‚úÖ';
          if(noteText === '') noteText = 'own';
        } else if(ownerId === player.id && meta?.status === 'seen'){
          playerMarks[pIdx] = '‚úÖ';
          if(noteText === '') noteText = 'seen';
        }
      });

      if(meta?.status === 'guilty'){
        cfMark = 'üö©';
        noteText = 'guilty';
      }

      return { playerMarks, cfMark, noteText, hasProb: false, prob: 0 };
    }

    // SMART/SHERLOCK: full elimination logic
    // 1) If focus owns it
    if(focus.own.has(key)){
      game.players.forEach((player, pIdx) => {
        playerMarks[pIdx] = (player.id === focus.id) ? '‚úÖ' : '‚úó';
      });
      cfMark = '‚úó';
      noteText = 'own';
      return { playerMarks, cfMark, noteText, hasProb: false, prob: 0 };
    }

    // 2) If focus knows someone owns it (seen or deduced)
    if(ownerId !== undefined && ownerId !== null){
      game.players.forEach((player, pIdx) => {
        playerMarks[pIdx] = (player.id === ownerId) ? '‚úÖ' : '‚úó';
      });
      cfMark = '‚úó';
      noteText = (meta?.status === 'deduced') ? 'deduced' : 'seen';
      return { playerMarks, cfMark, noteText, hasProb: false, prob: 0 };
    }

    // 3) Mark focus as ‚úó in own column if not owned
    const focusIdx = game.players.findIndex(p => p.id === focus.id);
    if(focusIdx >= 0) playerMarks[focusIdx] = '‚úó';

    // 4) Apply notOwner eliminations (from non-refutes/capacity/etc.)
    if(focus.notOwners){
      const notOwnerSet = focus.notOwners.get(key);
      if(notOwnerSet){
        game.players.forEach((player, pIdx) => {
          if(notOwnerSet.has(player.id)) playerMarks[pIdx] = '‚úó';
        });
      }
    }

    // 5) If confirmed guilty
    if(meta?.status === 'guilty'){
      cfMark = 'üö©';
      noteText = 'guilty';
      playerMarks.fill('‚úó');
      return { playerMarks, cfMark, noteText, hasProb: false, prob: 0 };
    }

    // 6) If all players ruled out, must be CF
    const allPlayersRuledOut = playerMarks.every(mark => mark === '‚úó');
    if(allPlayersRuledOut){
      cfMark = 'üö©';
      noteText = 'guilty';
      return { playerMarks, cfMark, noteText, hasProb: false, prob: 0 };
    }

    // 7) Sherlock probability for unsolved items
    if(game.aiDifficulty === 'sherlock' && noteText === ''){
      hasProb = true;
      prob = getSolutionProb(type, name);
    }

    return { playerMarks, cfMark, noteText, hasProb, prob };
  };

  // Render unified grid with all categories (with repeated dark header per category)
  const container = el('noteUnified');
  if(!container) return;

  const colCount = playerInitials.length + 2; // left label + players + CF
  let html = `<table class="clueGrid"><tbody>`;

  const categories = [
    { title: 'GUESTS', cards: GUESTS, type: 'Guest', icons: GST_ICON },
    { title: 'TREASURES',  cards: TREASURES,  type: 'Treasure',  icons: TSR_ICON },
    { title: 'ROOMS',    cards: ROOMS,    type: 'Room',    icons: ROOM_ICON_LOCAL }
  ];

  categories.forEach(category => {
    // --- Repeated dark header row for this category ---
    html += `<tr class="catHead">`;
    html += `<th style="text-align:left; min-width:100px;">${category.title}</th>`;
    playerInitials.forEach((initial, idx) => {
      html += `<th title="${game.players[idx].name}">${initial}</th>`;
    });
    html += `<th title="Case File (Solution)">CF</th>`;
    html += `</tr>`;

    // --- Cards ---
    category.cards.forEach(cardName => {
      const icon = category.icons[cardName] || '';
      const displayName = displayCardName(category.type, cardName);
      const cardInfo = getCardInfo(category.type, cardName);

      // Single combined row ‚Äî note/prob inline with card name
      const noteColors = {own:'var(--accent)',seen:'var(--accent)',deduced:'var(--gold)',guilty:'var(--warn)',innocent:'var(--muted)'};
      const noteSpan = cardInfo.noteText
        ? `<span style="font-size:9px;color:${noteColors[cardInfo.noteText]||'var(--muted)'};margin-left:4px;opacity:0.85;">${cardInfo.noteText}</span>`
        : '';
      const probBg = (cardInfo.hasProb && cardInfo.prob !== undefined)
        ? `<span style="position:absolute;left:0;top:0;bottom:0;width:${Math.round(cardInfo.prob*100)}%;background:linear-gradient(90deg,rgba(201,151,58,0.18),rgba(201,151,58,0.08));border-radius:2px;pointer-events:none;z-index:0;"></span>`
        : '';
      const tdStyle = probBg ? ' style="position:relative;overflow:hidden;"' : '';

      html += `<tr>`;
      html += `<td class="cardName"${tdStyle}>${probBg}<span style="position:relative;z-index:1;"><span class="ico">${icon}</span>${displayName}${noteSpan}</span></td>`;

      cardInfo.playerMarks.forEach(mark => {
        html += `<td style="font-size:11px;">${mark || '„ÄÄ'}</td>`;
      });

      html += `<td style="font-size:11px;">${cardInfo.cfMark || '„ÄÄ'}</td>`;
      html += `</tr>`;
    });
  });

  html += `</tbody></table>`;
  container.innerHTML = html;

  // Deductions log visibility (Smart/Sherlock only)
  const logId = 'observerDeduceLog';
  let logBox = document.getElementById(logId);

  const showLog = (game.aiDifficulty === 'smart' || game.aiDifficulty === 'sherlock');
  if(showLog){
    if(!logBox){
      const parent = document.getElementById('noteUnified')?.parentElement;
      if(parent){
        logBox = document.createElement('div');
        logBox.id = logId;
        logBox.className = 'log';
        logBox.style.marginTop = '12px';
        logBox.style.height = '150px';
        parent.appendChild(logBox);
      }
    }
    if(logBox && game.obsLog){
      logBox.textContent = game.obsLog.join('\n');
      logBox.scrollTop = logBox.scrollHeight;
    }
  } else {
    if(logBox) logBox.remove();
  }
}

/* ================================================================================
 * [SECTION 10] UI RENDERING - BOARD
 * ================================================================================
 * Room rendering, token placement, and movement indicators
 * ================================================================================ */


/* ============================================================
   TOKEN MOVEMENT ANIMATION
   ============================================================ */

// ‚îÄ‚îÄ Token movement animation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Call queueTokenMove() BEFORE changing location data.
// Call renderBoard(game) to paint new positions.
// Call await animatePendingMoves() to play the animation and wait for it to finish.

async function animatePendingMoves() {
  await flushTokenMoves();
}


// Supports multiple simultaneous tokens (e.g. guest + treasure in a suggestion).
// Queue snapshots BEFORE location changes; flush AFTER renderBoard paints new positions.

const pendingMoves = []; // [{ selector, rect }]

function queueTokenMove(selector) {
  const board = document.getElementById('board');
  if (!board) return;
  const src = board.querySelector(selector);
  if (src) {
    const rect = src.getBoundingClientRect();
    if (rect.width > 0) pendingMoves.push({ selector, rect });
  }
}

async function flushTokenMoves() {
  if (!pendingMoves.length) return;
  const moves = pendingMoves.splice(0);
  const board = document.getElementById('board');
  if (!board) return;

  const DURATION = 680;
  const clones = [];

  for (const { selector, rect } of moves) {
    const destEl = board.querySelector(selector);
    if (!destEl) continue;

    // Suppress dest token during flight
    destEl.style.opacity = '0';
    destEl.style.animation = 'none';
    const destRect = destEl.getBoundingClientRect();
    if (destRect.left === rect.left && destRect.top === rect.top) {
      // No movement ‚Äî token already there, just reveal it
      destEl.style.opacity = '';
      destEl.style.animation = '';
      continue;
    }

    // Build fixed clone at source
    const clone = destEl.cloneNode(true);
    clone.style.cssText = [
      'position:fixed',
      'left:' + rect.left + 'px',
      'top:'  + rect.top  + 'px',
      'width:'  + rect.width  + 'px',
      'height:' + rect.height + 'px',
      'margin:0',
      'z-index:1500',
      'pointer-events:none',
      'opacity:1',
      'animation:none',
      'will-change:left,top',
      'transition:left ' + DURATION + 'ms cubic-bezier(0.4,0,0.2,1), top ' + DURATION + 'ms cubic-bezier(0.4,0,0.2,1)',
    ].join(';');
    document.body.appendChild(clone);
    clones.push({ clone, destEl, destRect });
  }

  if (!clones.length) return;

  // Two rAF to commit starting positions before transition fires
  await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  for (const { clone, destRect } of clones) {
    clone.style.left = destRect.left + 'px';
    clone.style.top  = destRect.top  + 'px';
  }

  await new Promise(r => setTimeout(r, DURATION + 40));

  for (const { clone, destEl } of clones) {
    clone.remove();
    destEl.style.opacity = '';
    destEl.style.animation = '';
    destEl.style.transform = 'scale(1.18)';
    destEl.style.transition = 'transform 0.15s ease';
    setTimeout(() => { destEl.style.transform = ''; destEl.style.transition = ''; }, 150);
  }
}
function renderBoard(game){
  const board=el('board'); if(!board) return;
  board.innerHTML='';
  const placeBox=(div,pos)=>{div.style.gridColumn=`${pos.col[0]} / ${pos.col[1]}`;div.style.gridRow=`${pos.row[0]} / ${pos.row[1]}`;};
  const activeGuests=new Set(game.players.map(p=>p.guest).filter(Boolean));
  const current=game.currentPlayer();
  const uiControlled = current.isHuman || game.isCoachFocus(current);
  const roomNames=['Study','Library','Billiard Room','Conservatory','Hall','Ballroom','Lounge','Dining Room','Kitchen'];

  const GUEST_ICON = {"Forest":"üé©","Brimstone":"üéñÔ∏è","Rouge":"üíã","Sapphire":"üíé","Lavender":"üéì","Weisse":"üëí"};
  const TREASURE_ICON = {"Portrait":"üñºÔ∏è","Ornaments":"‚öîÔ∏è","Documents":"üìú","Coins":"ü™ô","Necklace":"üìø","Watch":"‚è±Ô∏è"};

  const makeToken = (cls, icon, title, colorVar) =>
    `<span class="${cls}" data-color="1" title="${title}" style="--token-color:${colorVar}">
       <span class="ico" aria-hidden="true">${icon}</span>
     </span>`;

  roomNames.forEach(roomName=>{
    const div=document.createElement('div');
    div.className='room';
    const pos=BOARD_LAYOUT[roomName];
    if(pos) placeBox(div,pos);
    const here = uiControlled && current.location===roomName;
    const reachable = uiControlled && game.awaitingMove && game.reachable.has(roomName);
    if(here) div.classList.add('here');
    if(reachable) div.classList.add('reachable');
    if(reachable){ div.style.cursor='pointer'; div.addEventListener('click', () => game.humanMoveTo(roomName)); }

    const guestTokens = GUESTS
      .filter(s => (game.guestLoc.get(s) || 'Hall') === roomName)
      .map(s => {
        const inactive = !activeGuests.has(s);
        return makeToken(
          `token guest ${slug(s)}${inactive?' inactive':''}`,
          GUEST_ICON[s]||'üë§', displayGuest(s), `var(--gst-${slug(s)})`
        );
      });

    const treasureTokens = TREASURES
      .filter(w => (game.treasureLoc.get(w)||'') === roomName)
      .map(w => makeToken(
        `token treasure ${slug(w)}`,
        TREASURE_ICON[w]||'üì¶', w, `var(--tsr-${slug(w)})`
      ));

    const wm = ROOM_ICON[roomName] || '';
    if(wm) div.setAttribute('data-watermark', wm);
    div.innerHTML = `<div class="title">${roomName}</div>
                     <div class="tokens">${[...guestTokens,...treasureTokens].join('')}</div>`;
    board.appendChild(div);
  });

  // ‚îÄ‚îÄ Centre tile ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const center=document.createElement('div');
  center.className='room center';
  placeBox(center,CENTER_CELL);

  const makeRoomToken = (roomName) => {
    if(!roomName) return '';
    const icon = ROOM_ICON[roomName] || 'üè∑Ô∏è';
    return makeToken('token roomtok', icon, roomName, 'rgba(201,151,58,0.25)');
  };

  let centerTitle = 'CASE FILE';

  if(game.trial && (game.trial.stage==='accused'||game.trial.stage==='notguilty')){
    centerTitle = game.trial.stage==='accused' ? 'ACCUSED' : 'NOT GUILTY';
    center.classList.add(game.trial.stage);
  } else if(game.gameOver && game.convicted){
    centerTitle = 'CONVICTED';
    center.classList.add('convicted');
  }

  const holdingGst = GUESTS
    .filter(s => game.guestLoc.get(s)===HOLDING_CELL_ID)
    .map(s => makeToken(`token guest ${slug(s)}`,GUEST_ICON[s]||'üë§',displayGuest(s),`var(--gst-${slug(s)})`));

  const holdingTsr = TREASURES
    .filter(w => game.treasureLoc.get(w)===HOLDING_CELL_ID)
    .map(w => makeToken(`token treasure ${slug(w)}`,TREASURE_ICON[w]||'üì¶',w,`var(--tsr-${slug(w)})`));

  let roomToken = '';
  if(game.trial?.acc) roomToken = makeRoomToken(game.trial.acc.room);
  else if(game.gameOver && game.convicted) roomToken = makeRoomToken(game.convicted.room);

  const centerTokens=[...holdingGst,...holdingTsr,roomToken].filter(Boolean).join('');
  const centerDefault = centerTokens ? '' : `<div style="font-size:9px;letter-spacing:0.2em;color:rgba(201,151,58,0.35);margin-top:4px;font-family:'Cinzel',serif;">CONFIDENTIAL</div>`;

  center.setAttribute('data-watermark', ROOM_ICON['Case File'] || 'üïµÔ∏è');
  center.innerHTML=`<div class="title">${centerTitle}</div><div class="tokens">${centerTokens}</div>${centerDefault}`;
  board.appendChild(center);

  // pendingMoves are flushed by the caller via: await animatePendingMoves()
}

function renderAll(game){
  renderPlayers(game);
  renderHand(game);
  if(game.observerMode) renderObserverCasebook(game);
  else renderNotebook(game);
  renderBoard(game);
}

function renderWithoutBoard(game){
  renderPlayers(game);
  renderHand(game);
  if(game.observerMode) renderObserverCasebook(game);
  else renderNotebook(game);
}

/* ================================================================================
 * [SECTION 11] GAME INITIALIZATION
 * ================================================================================
 * Startup sequence, new game function, and UI reset
 * ================================================================================ */

/* Startup */
const game=new Game();
(async function start(){
  try{
    clearGameplayPrompt();
    const setup = await promptGameSetup();
    game.aiDifficulty = normDiff(setup.diff);
    game.observerMode = !!setup.observer;
    game.coachMode = !!setup.observer; // Coach mode uses observer plumbing
    game.observerFocusId = 0;

    game.resetPlayers(setup.opp);

    // In observer mode, Player 1 is AI (no human prompts during play)
    if(game.observerMode){
      game.players[0].isHuman = false; // critical: prevents "human" refute prompts
      game.players[0].name = `Player 1`; // temporary until guest assigned
    }

    // Choose focus guest (optional but recommended)
    const pick = await promptHumanGuest(GUESTS);
    // You can rename the prompt title/body if observer mode (see below)
    game.assignGuests(pick);

    // After assignGuests, set a nicer label for Player 1 in observer mode
    if(game.observerMode){
      game.players[0].name = displayGuest(game.players[0].guest); // keep consistent
    }

    game.setup();
    const ng = el('btnNewGame');
    if (ng) ng.onclick = () => startNewGame(game);

    const ngm = el('btnNewGameMobile');
    if (ngm) ngm.onclick = () => startNewGame(game);
    await game.beginTurn();
  }catch(e){
    console.error(e);
    await showInfoPrompt('Error',
      `<div style="color:#fca5a5"><b>${(e&&e.message)||'Unknown error'}</b></div>
       <div style="margin-top:8px;color:var(--muted);font-size:12px;">Check the browser console for details.</div>`);
  }
})();

/* ================================================================================
 * FULLSCREEN TOGGLE
 * ================================================================================ */
(function initFullscreenButton(){
  const btn = el('fullscreenBtn');
  if(!btn) return;

  function updateIcon(){
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    // ‚õ∂ = expand (4 arrows out), ‚Æπ = compress (4 arrows in)
    // Using Unicode: ‚õ∂ for expand, ‚§ß or ‚ó∞ for exit
    btn.textContent = isFullscreen ? '‚ó±' : '‚õ∂';
    btn.title = isFullscreen ? 'Exit Fullscreen (F11)' : 'Enter Fullscreen (F11)';
    btn.setAttribute('aria-label', isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen');
  }

  function toggleFullscreen(){
    const doc = document.documentElement;
    const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

    if(isFullscreen){
      // Exit fullscreen
      if(document.exitFullscreen) document.exitFullscreen();
      else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
      else if(document.mozCancelFullScreen) document.mozCancelFullScreen();
      else if(document.msExitFullscreen) document.msExitFullscreen();
    }else{
      // Enter fullscreen
      if(doc.requestFullscreen) doc.requestFullscreen();
      else if(doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();
      else if(doc.mozRequestFullScreen) doc.mozRequestFullScreen();
      else if(doc.msRequestFullscreen) doc.msRequestFullscreen();
    }
  }

  btn.onclick = toggleFullscreen;

  // Update icon when fullscreen state changes
  document.addEventListener('fullscreenchange', updateIcon);
  document.addEventListener('webkitfullscreenchange', updateIcon);
  document.addEventListener('mozfullscreenchange', updateIcon);
  document.addEventListener('msfullscreenchange', updateIcon);

  // Initial icon state
  updateIcon();
})();

function resetUIForSetup() {
  clearGameplayPrompt();
  const logBox = el('log'); if (logBox) logBox.textContent = '';
  // Clear observer deductions log (DOM + memory) at the same time as game log
  const deduceBox = document.getElementById('observerDeduceLog');
  if (deduceBox) deduceBox.textContent = '';
  if (deduceBox) deduceBox.remove();
  game.obsLog = [];
  const playersBox = el('playersBox'); if (playersBox) playersBox.innerHTML = '';
  const handBox = el('handBox'); if (handBox) handBox.innerHTML = '';
  const board = el('board'); if (board) board.innerHTML = '';
  // Clear unified casebook (new single-grid notebook)
  const noteUnified = el('noteUnified');
  if (noteUnified) noteUnified.innerHTML = '';
  try { clearChecklist(); clearCheckNotes(); clearClueGrid(); } catch (e) { console.warn('Checklist clear error (safe to ignore):', e); }
  const turnPill = el('turnPill'); if (turnPill) turnPill.textContent = 'Turn: ‚Äî';
  const locPill  = el('locPill');  if (locPill)  locPill.textContent  = 'Location: ‚Äî';
}


function showNewGameModal() {
  return new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'modalOverlay';
    const dialog = document.createElement('div');
    dialog.className = 'modalDialog';

    const header = document.createElement('div');
    header.className = 'modalHeader';
    header.textContent = 'Start a New Game?';

    const body = document.createElement('div');
    body.className = 'modalBody';
    body.innerHTML = `<div style="font-size:16px;margin-bottom:12px;">What would you like to do?</div>
      <div style="color:var(--muted);font-size:13px;">All current progress and casebook notes will be cleared.</div>`;

    const actions = document.createElement('div');
    actions.className = 'modalActions';

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'secondary';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.onclick = () => { document.body.removeChild(overlay); resolve(false); };

    const restartBtn = document.createElement('button');
    restartBtn.className = 'secondary';
    restartBtn.textContent = 'Restart';
    restartBtn.title = 'Start fresh with the same character and settings';
    restartBtn.onclick = () => { document.body.removeChild(overlay); resolve('restart'); };

    const hallBtn = document.createElement('button');
    hallBtn.className = 'danger';
    hallBtn.textContent = 'Return to Hapless Hall';
    hallBtn.title = 'Choose a new character and settings';
    hallBtn.onclick = () => { document.body.removeChild(overlay); resolve('hall'); };

    actions.appendChild(cancelBtn);
    actions.appendChild(restartBtn);
    actions.appendChild(hallBtn);

    dialog.appendChild(header);
    dialog.appendChild(body);
    dialog.appendChild(actions);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
  });
}

async function restartSameSettings(game) {
  // Replay with the exact same guest, difficulty, opponents and mode stored in tpState
  resetUIForSetup();
  document.getElementById('titlePages').classList.add('hidden');
  document.getElementById('gameUI').classList.add('active');
  clearGameplayPrompt();

  game.aiDifficulty = normDiff(tpState.diff);
  game.observerMode = !!tpState.observer;
  game.coachMode    = !!tpState.observer;
  game.observerFocusId = 0;
  game.resetPlayers(tpState.opp);

  if(game.observerMode){
    game.players[0].isHuman = false;
    game.players[0].name = 'Player 1';
  }

  game.assignGuests(tpState.guest);

  if(game.observerMode){
    game.players[0].name = displayGuest(game.players[0].guest);
  }

  game.setup();
  const ng = el('btnNewGame');  if(ng)  ng.onclick  = () => startNewGame(game);
  const ngm = el('btnNewGameMobile'); if(ngm) ngm.onclick = () => startNewGame(game);
  await game.beginTurn();
}

async function startNewGame(game,{skipConfirm=false,fromTitlePage=false}={}){
  if(!skipConfirm && !fromTitlePage){
    const choice = await showNewGameModal();
    if(!choice) return;
    clearGameplayPrompt();
    if(choice === 'restart'){
      // Use tpState exactly as-is ‚Äî no title pages, no prompts
      await restartSameSettings(game);
      return;
    }
  }
  resetUIForSetup();
  if(!fromTitlePage){ tpShowTitlePages(); }
  const setup = await promptGameSetup();
  game.aiDifficulty = normDiff(setup.diff);
  game.observerMode = !!setup.observer;
  game.coachMode = !!setup.observer; // Coach mode uses observer plumbing
  game.observerFocusId = 0;

  game.resetPlayers(setup.opp);

  // In observer mode, Player 1 is AI (no human prompts during play)
  if(game.observerMode){
    game.players[0].isHuman = false; // critical: prevents "human" refute prompts
    game.players[0].name = `Player 1`; // temporary until guest assigned
  }

  // Choose focus guest (optional but recommended)
  const pick = await promptHumanGuest(GUESTS);
  // You can rename the prompt title/body if observer mode (see below)
  game.assignGuests(pick);

  // After assignGuests, set a nicer label for Player 1 in observer mode
  if(game.observerMode){
    game.players[0].name = displayGuest(game.players[0].guest); // keep consistent
  }

  game.setup();
  const ng = el('btnNewGame');
  if (ng) ng.onclick = () => startNewGame(game);

  const ngm = el('btnNewGameMobile');
  if (ngm) ngm.onclick = () => startNewGame(game);
  await game.beginTurn();
}

/* ================================================================================
 * üìö QUICK REFERENCE FOR CUSTOMIZATION
 * ================================================================================
 * 
 * COMMON MODIFICATIONS AND WHERE TO FIND THEM:
 * 
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ WHAT TO CHANGE              ‚îÇ WHERE TO LOOK                             ‚îÇ
 * ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 * ‚îÇ Colors                      ‚îÇ Search: "COLOR CUSTOMIZATION"             ‚îÇ
 * ‚îÇ Game title                  ‚îÇ Search: "ClueSolo"                        ‚îÇ
 * ‚îÇ Number of AI opponents      ‚îÇ Search: "promptGameSetup"                 ‚îÇ
 * ‚îÇ AI difficulty               ‚îÇ Search: "[SECTION 5]"                     ‚îÇ
 * ‚îÇ Room names                  ‚îÇ Search: "const ROOMS"                     ‚îÇ
 * ‚îÇ Guest names                 ‚îÇ Search: "const GUESTS"                    ‚îÇ
 * ‚îÇ Treasure names              ‚îÇ Search: "const TREASURES"                 ‚îÇ
 * ‚îÇ Board layout                ‚îÇ Search: "ROOM_LAYOUT"                     ‚îÇ
 * ‚îÇ Dice roll range             ‚îÇ Search: "randInt(2, 12)"                  ‚îÇ
 * ‚îÇ Button labels               ‚îÇ Search for the exact button text          ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 * 
 * DEBUGGING TIPS:
 * ‚Ä¢ Always keep a backup copy before editing!
 * ‚Ä¢ Use Ctrl+Z (Undo) if something breaks
 * ‚Ä¢ Open browser console (F12) to see error messages
 * ‚Ä¢ Check line numbers in error messages to find problems
 * ‚Ä¢ Test changes by refreshing the browser (F5)
 * 
 * SECTION MARKERS:
 * Use Ctrl+F to search for these tags to navigate the code:
 * [SECTION 1] - Utilities & Error Handling
 * [SECTION 2] - Game Constants
 * [SECTION 3] - Player Class
 * [SECTION 4] - Main Game Class
 * [SECTION 5] - AI Logic
 * [SECTION 6] - Game Flow Functions
 * [SECTION 7] - User Interface Prompts
 * [SECTION 8] - UI Rendering - Players & Cards
 * [SECTION 9] - UI Rendering - Notebook
 * [SECTION 10] - UI Rendering - Board
 * [SECTION 11] - Game Initialization
 * 
 * ================================================================================ */
</script>
</body>
</html>
