<!doctype html>
<html lang="en">
<!--
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                        ğŸ” CLUE SOLO - v1.0                                â•‘
â•‘                     Human + AI Detective Board Game                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“– QUICK START GUIDE FOR NON-CODERS:

1. OPENING THE GAME:
   â€¢ Double-click this .html file to open it in your web browser
   â€¢ Works best in Chrome, Firefox, or Edge (latest versions)

2. FINDING THINGS IN THIS FILE:
   â€¢ Open this file in a text editor (Notepad++, VS Code, or even Notepad)
   â€¢ Press Ctrl+F (Windows) or Cmd+F (Mac) to search
   â€¢ Search for section tags like "[SECTION 5]" to jump to specific parts

3. COMMON CUSTOMIZATIONS:

   ğŸ¨ CHANGE COLORS:
      â†’ Search for "COLOR CUSTOMIZATION" (around line 10)
      â†’ Edit hex color codes like #0f172a
      â†’ Use https://htmlcolorcodes.com/color-picker/ to pick colors

   ğŸ“ CHANGE TEXT/LABELS:
      â†’ Search for the exact text you want to change
      â†’ Example: Search for "New Game" to change button text

   ğŸ² ADJUST AI DIFFICULTY:
      â†’ Search for "[SECTION 5]" to find AI logic
      â†’ Look for difficulty settings (Easy, Medium, Hard)

4. TROUBLESHOOTING:
   â€¢ If game doesn't load: Press F12 to open browser console, check for errors
   â€¢ If you broke something: Use Ctrl+Z to undo your last changes
   â€¢ Keep a backup copy of this file before making changes!

5. SAVING YOUR CHANGES:
   â€¢ File â†’ Save (or Ctrl+S)
   â€¢ Refresh your browser (F5) to see changes

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<head>
<meta charset="utf-8" />
<meta property="og:title" content="ClueSolo - Play Clue Solo with AI">
<meta property="og:description" content="Single-player Clue/Cluedo game with AI opponents. Perfect for learning deduction skills!">
<meta property="og:url" content="https://andreas-breidenthal.github.io/ClueSolo/">
<meta property="og:type" content="website">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ğŸ” ClueSolo â€” Human + AI</title>

<style>
  /* ========================================================================
   * COLOR CUSTOMIZATION
   * ========================================================================
   * To change colors, modify the hex values below.
   * Use a color picker tool: https://htmlcolorcodes.com/color-picker/
   * Example: --bg:#0f172a means background is dark blue
   * ======================================================================== */
  :root{
    /* Main interface colors */
    --bg:#0f172a;          /* Background color (dark blue-grey) */
    --panel:#111c33;       /* Panel backgrounds (slightly lighter) */
    --text:#e5e7eb;        /* Main text color (light grey) */
    --muted:#9ca3af;       /* Dimmed text (grey) */
    --accent:#60a5fa;      /* Accent/highlight color (blue) */
    --bad:#fb7185;         /* Error/negative color (red) */
    --good:#34d399;        /* Success/positive color (green) */
    --warn:#fbbf24;        /* Warning color (yellow) */
    --border:rgba(255,255,255,0.12);  /* Border color (semi-transparent white) */

    /* Suspect colors - each suspect has their own color */
    --sus-green:#2D9542;--sus-mustard:#D6AA28;--sus-peacock:#0085B7;--sus-plum:#9C51B6;--sus-scarlet:#ff2400;--sus-white:#f8fafc;
    /* Weapon colors - each weapon has its own color */
    --wep-candle:#FFD700;--wep-dagger:#BB0A1E;--wep-lead:#B7C9E2;--wep-revolver:#D8D8D8;--wep-rope:#BAA38C;--wep-wrench:#879EBF;
  }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1200px 700px at 30% 0%, #1f2a4a, var(--bg));color:var(--text)}
  header{padding:14px 18px;display:flex;align-items:baseline;gap:12px;border-bottom:1px solid var(--border);background:rgba(0,0,0,0.15)}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .layout{display:grid;grid-template-columns:360px 1fr 420px;gap:12px;padding:12px;align-items:start}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));border:1px solid var(--border);border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .panel h2{margin:0;padding:10px 12px;font-size:13px;letter-spacing:.06em;text-transform:uppercase;background:rgba(0,0,0,.2);border-bottom:1px solid var(--border);color:#cbd5e1}
  .panel .content{padding:12px}
  .leftStack{display:grid;gap:12px;grid-template-rows:auto auto 1fr}
  .rightStack{display:grid;gap:12px;grid-template-rows:auto auto 1fr}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .row.between{justify-content:space-between}
  .pill{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.05);color:var(--muted)}
  .pill.good{color:var(--good);border-color:rgba(52,211,153,.4)}
  .pill.bad{color:var(--bad);border-color:rgba(251,113,133,.4)}
  .pill.warn{color:var(--warn);border-color:rgba(251,191,36,.4)}
  button{cursor:pointer;border:1px solid var(--border);background:rgba(96,165,250,.18);color:var(--text);padding:8px 10px;border-radius:10px;font-weight:700;transition:transform .05s ease, background .2s ease}
  button:hover{background:rgba(96,165,250,.25)}button:active{transform:translateY(1px)}button.secondary{background:rgba(255,255,255,.06)}button.danger{background:rgba(251,113,133,.18)}button:disabled{opacity:.55;cursor:not-allowed}
  select{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:rgba(0,0,0,.2);color:var(--text)}
  .board{display:grid;grid-template-columns:repeat(12,minmax(0,1fr));grid-auto-rows:56px;gap:12px;padding:12px}
  .room.center{background:rgba(255,255,255,0.07);border-style:dashed}
  .room.center.convicted{border-style:solid;background:linear-gradient(180deg, rgba(52,211,153,.15), rgba(255,255,255,.04))}
  /* Accusation tension states for centre tile */
  .room.center.accused{
    border-style:solid;
    background:linear-gradient(180deg, rgba(251,191,36,.22), rgba(255,255,255,.04)); /* pale orange */
  }
  .room.center.notguilty{
    border-style:solid;
    background:linear-gradient(180deg, rgba(253,230,138,.22), rgba(255,255,255,.04)); /* pale yellow */
  }
  .room{border:1px solid var(--border);border-radius:12px;padding:10px;background:rgba(0,0,0,.15);min-height:96px;position:relative}
  .room .title{font-weight:900}.room .tokens{margin-top:8px;display:flex;flex-wrap:wrap;gap:6px}
  .room .tokens{align-items:flex-start;align-content:flex-start;}
  .room .tokens .token{align-self:flex-start;}
  .room.reachable{outline:2px solid rgba(96,165,250,.55)}.room.here{outline:2px solid rgba(52,211,153,.55)}
  .room button{position:absolute;right:10px;top:10px;padding:6px 8px;border-radius:10px;font-size:12px}
  .log{height:200px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;line-height:1.35;background:rgba(0,0,0,.18);border:1px solid var(--border);border-radius:12px;padding:10px;white-space:pre-wrap}

  .probWrap{
    position:relative;
    height:10px;
    border-radius:999px;
    border:1px solid var(--border);
    background:rgba(0,0,0,.18);
    overflow:hidden;
  }
  .probBar{
    height:100%;
    background:linear-gradient(90deg, rgba(96,165,250,.65), rgba(52,211,153,.55));
  }
  .probPct{
    position:absolute;
    top:-18px;
    right:0;
    font-size:10px;
    color:var(--muted);
  }
  
/* Ensure centre room-token doesn't inflate compared to other tokens */
  .room.center .tokens .token.room{ line-height:1.1; padding:3px 7px; }

/* â€”â€” Checklist (with per-item single-line notes) â€”â€” */
/* Wide / default: [checkbox] [label] [note input] on one line */
.noteitem{
  display:grid;
  grid-template-columns: auto auto 1fr; /* checkbox | name | input (flex) */
  column-gap:8px;
  align-items:center;         /* single-line alignment */
  padding:2px 0;
  color:var(--muted);
  font-size:12px;
}
.noteitem input[type="checkbox"]{
  grid-column:1;
  margin-top:0;
}
.noteitem .name{
  grid-column:2;
  color:var(--text);
  margin:0;
  white-space:nowrap;         /* keep the label from wrapping on wide screens */
}
.noteitem.cleared .name{
  text-decoration:line-through;
  color:#94a3b8;
}
.noteText{
  grid-column:3;              /* sits to the right of the label on wide screens */
  display:block;
  width:100%;
  box-sizing:border-box;
  margin:0;
  padding:3px 6px;
  border-radius:8px;
  border:1px solid var(--border);
  background:rgba(0,0,0,.18);
  color:var(--text);
  font-size:12px;
  min-width:160px;            /* comfortable min size next to short labels */
}

/* Hide Sherlock probability bar when an item is crossed off */
.noteitem.cleared .probWrap,
.noteitem.cleared .probPct{
  display:none !important;
}

/* Small screens: revert to stacked layout (input drops below the label) */
@media (max-width: 540px){
  .noteitem{
    grid-template-columns: auto 1fr;  /* checkbox | label on row 1 â€¦ */
    align-items:start;                /* let the input have its own row */
  }
  .noteitem .name{
    grid-column:2;
    white-space:normal;               /* allow wrapping on small screens */
  }
  .noteText{
    grid-column:1 / -1;               /* â€¦and input spans full width on row 2 */
    margin-top:6px;
  }
}

/* Container for each list (unchanged) */
.checklistStack{ display:grid; grid-template-columns:1fr; gap:10px }

/* ========================================================================
 * CLUE-STYLE DEDUCTION GRID
 * ======================================================================== */
.clueGrid {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
  margin-top: 8px;
}

.clueGrid th {
  background: rgba(0,0,0,0.3);
  padding: 6px 4px;
  border: 1px solid var(--border);
  font-weight: 700;
  text-align: center;
  color: var(--text);
  font-size: 10px;
}

.clueGrid td {
  border: 1px solid var(--border);
  padding: 0;
  text-align: center;
  background: rgba(0,0,0,0.15);
  height: 28px;
}

.clueGrid td.cardName {
  text-align: left;
  padding: 4px 8px;
  font-weight: 600;
  white-space: nowrap;
}

.clueGrid td.notesRow {
  padding: 2px 4px;
  background: rgba(0,0,0,0.25);
  height: auto;
}

.clueGrid .noteInput {
  width: 100%;
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--muted);
  font-size: 10px;
  padding: 3px 5px;
  font-style: italic;
}

.clueGrid .noteInput:focus {
  outline: 1px solid var(--accent);
  background: rgba(0,0,0,0.3);
  color: var(--text);
}

.clueGrid .noteDisplay {
  font-size: 10px;
  color: var(--muted);
  font-style: italic;
  padding: 3px 5px;
  text-align: left;
}

.clueGrid select {
  width: 100%;
  height: 100%;
  border: none;
  background: transparent;
  color: var(--text);
  text-align: center;
  font-size: 16px;
  padding: 2px;
  cursor: pointer;
  appearance: none;
}

.clueGrid select:focus {
  outline: 2px solid var(--accent);
  background: rgba(96,165,250,0.1);
}

.clueGrid .sectionHeader {
  background: rgba(96,165,250,0.15);
  font-weight: 800;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 8px;
  text-align: left;
  color: var(--accent);
  font-size: 11px;
}

/* Compact view for small screens */
@media (max-width: 540px){
  .clueGrid {
    font-size: 10px;
  }
  .clueGrid th {
    padding: 4px 2px;
    font-size: 9px;
  }
  .clueGrid td.cardName {
    font-size: 10px;
    padding: 3px 5px;
  }
  .clueGrid .noteInput,
  .clueGrid .noteDisplay {
    font-size: 9px;
    padding: 2px 3px;
  }
}

  .promptBox{border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,.12);padding:10px}
  .promptTitle{font-weight:800;margin-bottom:6px;color:#e2e8f0}
  .promptBody{margin:6px 0 10px 0}
  .promptActions{display:flex;flex-wrap:wrap;gap:8px}
  .placeholder{color:var(--muted);font-size:12px}

  .rightPanel,.leftPanel{position:sticky;top:12px;height:calc(100vh - 96px);overflow:auto}
  @media (max-width:1200px){.layout{grid-template-columns:1fr}.leftPanel,.rightPanel{position:static;height:auto;overflow:visible}}

  .token{font-size:11px;padding:3px 7px;border-radius:999px;border:2px solid rgba(255,255,255,.18);background:#000;line-height:1.1;display:inline-flex;align-items:center;gap:6px;white-space:nowrap;box-shadow:0 0 0 1px rgba(0,0,0,.35) inset}
  .token[data-color]{border-color: color-mix(in srgb, var(--token-color) 92%, transparent);color:color-mix(in srgb, var(--token-color) 92%, transparent);box-shadow:0 0 0 1px rgba(0,0,0,.35) inset,0 0 10px color-mix(in srgb, var(--token-color) 28%, transparent);text-shadow:0 1px 1px rgba(0,0,0,.85)}
  .token .dot{width:8px;height:8px;border-radius:999px;background: var(--token-color);box-shadow:0 0 0 1px rgba(0,0,0,.55), 0 0 10px color-mix(in srgb, var(--token-color) 35%, transparent)}
  .token.inactive{border-style:dashed}
.token .ico {
  margin-right: 6px;
}
  .token.suspect.green{--token-color:var(--sus-green)}.token.suspect.mustard{--token-color:var(--sus-mustard)}.token.suspect.peacock{--token-color:var(--sus-peacock)}.token.suspect.plum{--token-color:var(--sus-plum)}.token.suspect.scarlet{--token-color:var(--sus-scarlet)}.token.suspect.white{--token-color:var(--sus-white)}
  .token.weapon.candlestick{--token-color:var(--wep-candle)}.token.weapon.dagger{--token-color:var(--wep-dagger)}.token.weapon.lead-pipe{--token-color:var(--wep-lead)}.token.weapon.revolver{--token-color:var(--wep-revolver)}.token.weapon.rope{--token-color:var(--wep-rope)}.token.weapon.wrench{--token-color:var(--wep-wrench)}
.ico{ display:inline-block; margin-right:6px; line-height:1; }
/* --- Mobile stacked layout for Rooms --- */
@media (max-width: 540px){
  /* Turn the board into a simple stacked layout */
  .board{
    display:grid;
    gap:12px;
    grid-template-columns: 1fr;   /* single column on mobile */
    grid-auto-rows: auto;
  }

  /* Override the JS inline grid placement */
  .board .room{
    grid-column: auto !important;
    grid-row: auto !important;
    min-height: 120px;
  }

  /* Center â€œClassified Files / Convictedâ€ tile should also stack */
  .board .room.center{
    grid-column: auto !important;
    grid-row: auto !important;
  }
}
</style>
</head>
<body>
<header>
  <h1>ğŸ” ClueSolo</h1>
  <div class="sub">Just like the classic detective game ... but you're alone!</div>
</header>
<div class="layout">
  <div class="panel leftPanel">
    <h2>Controls</h2>
    <div class="content leftStack">
      <div class="row between" style="margin-bottom:4px;">
        <div class="row">
          <span class="pill" id="turnPill">Turn: â€”</span>
          <span class="pill" id="locPill">Location: â€”</span>
        </div>
        <button id="btnNewGame" class="secondary">New Game</button>
      </div>
      <div class="panel">
        <h2>Your Cards</h2>
        <div class="content" id="handBox"></div>
      </div>
      <div class="panel">
        <h2>Players</h2>
        <div class="content" id="playersBox"></div>
      </div>
      <div class="panel">
        <h2>Game Log</h2>
        <div class="content"><div class="log" id="log"></div></div>
      </div>
    </div>
  </div>

  <div class="panel centerPanel">
    <h2>Rooms</h2>
    <div class="content">
      <div class="board" id="board"></div>
      <div class="panel" style="margin-top:12px;">
        <div class="content">
          <div id="gameplayPromptBox" class="promptBox">
            <div class="placeholder">Game-play prompts will appear here</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel rightPanel">
    <h2>Casebook</h2>
    <div class="content rightStack">
          <div class="checklistStack">
            <div class="notebox"><h4>Suspects</h4><div id="noteSuspects"></div></div>
            <div class="notebox"><h4>Weapons</h4><div id="noteWeapons"></div></div>
            <div class="notebox"><h4>Rooms</h4><div id="noteRooms"></div></div>
          </div>
    </div>
  </div>
</div>

<script>
/* ================================================================================
 * ğŸ” CLUE SOLO - HUMAN + AI BOARD GAME
 * ================================================================================
 * 
 * HOW TO NAVIGATE THIS FILE:
 * Use your editor's Find function (Ctrl+F or Cmd+F) and search for section tags
 * Example: Search for "[SECTION 3]" to jump to AI Logic
 * 
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * TABLE OF CONTENTS
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * 
 * [SECTION 1] UTILITIES & ERROR HANDLING ........... Line ~254
 *   â€¢ Global error handlers
 *   â€¢ Random number utilities
 *   â€¢ Array shuffling
 *   â€¢ Sleep/delay functions
 * 
 * [SECTION 2] GAME CONSTANTS ....................... Line ~330
 *   â€¢ Suspects, Weapons, Rooms lists
 *   â€¢ Board layout definitions
 *   â€¢ Room connections and positions
 * 
 * [SECTION 3] PLAYER CLASS ......................... Line ~500
 *   â€¢ Player state management
 *   â€¢ Card tracking (own, seen, eliminated)
 *   â€¢ Sherlock probability calculations
 * 
 * [SECTION 4] MAIN GAME CLASS ...................... Line ~800
 *   â€¢ Game state initialization
 *   â€¢ Card dealing
 *   â€¢ Turn management
 *   â€¢ Win/lose conditions
 * 
 * [SECTION 5] AI LOGIC ............................. Line ~1100
 *   â€¢ Difficulty levels (Easy, Medium, Hard)
 *   â€¢ AI move selection
 *   â€¢ AI suggestion logic
 *   â€¢ AI accusation decisions
 * 
 * [SECTION 6] GAME FLOW FUNCTIONS .................. Line ~1400
 *   â€¢ Turn execution
 *   â€¢ Movement handling
 *   â€¢ Suggestion/refutation
 *   â€¢ Accusation/trial
 * 
 * [SECTION 7] USER INTERFACE PROMPTS ............... Line ~1700
 *   â€¢ Game setup dialog
 *   â€¢ Move selection prompts
 *   â€¢ Refutation prompts
 *   â€¢ Information dialogs
 * 
 * [SECTION 8] UI RENDERING - PLAYERS & CARDS ....... Line ~2000
 *   â€¢ Player display
 *   â€¢ Hand rendering
 *   â€¢ Card visuals
 * 
 * [SECTION 9] UI RENDERING - NOTEBOOK .............. Line ~2100
 *   â€¢ Checklist rendering
 *   â€¢ Note-taking interface
 *   â€¢ Probability displays
 * 
 * [SECTION 10] UI RENDERING - BOARD ................ Line ~2300
 *   â€¢ Room rendering
 *   â€¢ Token placement
 *   â€¢ Movement indicators
 * 
 * [SECTION 11] GAME INITIALIZATION ................. Line ~2570
 *   â€¢ Startup sequence
 *   â€¢ New game function
 *   â€¢ UI reset
 * 
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * QUICK TIPS FOR NON-CODERS:
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * 
 * ğŸ”§ TO MODIFY GAME DIFFICULTY:
 *    Search for "[SECTION 5]" â†’ Find "AI LOGIC" section
 * 
 * ğŸ¨ TO CHANGE COLORS:
 *    Scroll to top of file â†’ Find the <style> section â†’ Look for ":root" variables
 * 
 * ğŸ“ TO ADJUST TEXT/LABELS:
 *    Search for the exact text you want to change (e.g., "New Game")
 * 
 * ğŸ› TO DEBUG ISSUES:
 *    Open browser console (F12) and check for error messages
 * 
 * ================================================================================ */

/* ================================================================================
 * [SECTION 1] UTILITIES & ERROR HANDLING
 * ================================================================================ */

// --- Global error surface: log to the in-app Game Log panel ---
window.onerror = function (msg, url, line, col, err) {
  try {
    const box = document.getElementById('log');
    const where = (line != null && col != null) ? ` @ ${line}:${col}` : '';
    const text = `[BOOT ERR] ${msg}${where}\n`;
    if (box) {
      box.textContent += text;
      box.scrollTop = box.scrollHeight;
    } else {
      console.error(text);
    }
  } catch (e) {
    console.error('Error in window.onerror:', e);
  }
};
// (Optional) also surface unhandled Promise rejections
window.addEventListener('unhandledrejection', (event) => {
  try {
    const box = document.getElementById('log');
    const reason = (event.reason && (event.reason.message || event.reason)) || 'Unhandled rejection';
    const text = `[BOOT ERR] Unhandled promise rejection: ${reason}\n`;
    if (box) {
      box.textContent += text;
      box.scrollTop = box.scrollHeight;
    } else {
      console.error(text);
    }
  } catch (e) {
    console.error('Error in unhandledrejection handler:', e);
  }
});

/* Utilities */
const randInt=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const choice=arr=>arr[Math.floor(Math.random()*arr.length)];
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
// --- Sherlock helper: pick least-informative refute card (adversarial refuter) ---
function pickLeastInformativeRefuteCard(refuter, matches, suggester){
  // Lower score = less NEW information revealed to the suggester
  if(!matches || !matches.length) return null;
  if(!suggester) return choice(matches);

  const scoreCard = (c) => {
    const key = suggester.cardKey(c.type, c.name);

    // If suggester already owns it, showing it is extremely uninformative
    if(suggester.own && suggester.own.has(key)) return -100;

    // If suggester already knows refuter owns it, also extremely uninformative
    if(suggester.knownOwners && suggester.knownOwners.get(key) === refuter.id) return -90;

    // If suggester has it "seen/eliminated", showing owner is usually less useful
    if(suggester.seen && suggester.seen.has(key)) return -50;

    // If suggester has Sherlock beliefs, use them to pick the least informative card
    if(suggester.ownerWeights && typeof suggester._pOwner === 'function'){
      const pOwn  = suggester._pOwner(c, refuter.id); // how likely suggester already thinks refuter owns it
      const pCase = (typeof suggester._pCaseNorm === 'function') ? suggester._pCaseNorm(c) : 0; // how "hot" it is as solution

      // Less informative if:
      // - suggester already expects refuter to own it (high pOwn)
      // - it's unlikely to be in the case file (low pCase)
      return (1 - pOwn) + (pCase * 0.5);
    }

    // Fallback
    return 10;
  };

  let best = [], bestScore = Infinity;
  for(const c of matches){
    const s = scoreCard(c);
    if(s < bestScore){ best = [c]; bestScore = s; }
    else if(s === bestScore){ best.push(c); }
  }
  return choice(best.length ? best : matches);
}

// --- Sherlock helper: hand-size constraints (capacity) ---
function applyHandSizeConstraints(observer, players){
  // Only useful for AIs that track owners
  if(!observer || observer.isHuman) return;
  if(!observer.knownOwners || !observer.markNotOwner) return;

  // Build a quick key->card map once
  if(!applyHandSizeConstraints._keyToCard){
    applyHandSizeConstraints._keyToCard = new Map(ALL_CARDS.map(c => [`${c.type}:${c.name}`, c]));
  }
  const keyToCard = applyHandSizeConstraints._keyToCard;

  // For each player, if we already "know" they own as many cards as their hand size,
  // then they cannot own any other unknown cards.
  for(const p of players){
    if(!p) continue;
    const pid = p.id;
    const capacity = (p.hand && p.hand.length) ? p.hand.length : 0;
    if(capacity <= 0) continue;

    // All card keys observer believes are owned by pid
    const ownedKeys = [];
    for(const [k, ownerId] of observer.knownOwners.entries()){
      if(ownerId === pid) ownedKeys.push(k);
    }

    // If at capacity, mark NOT owner for every other card not already assigned to them
    if(ownedKeys.length >= capacity){
      const ownedSet = new Set(ownedKeys);
      let newlyExcluded = 0;

      for(const c of ALL_CARDS){
        const key = `${c.type}:${c.name}`;
        if(ownedSet.has(key)) continue;

        // If already known owned by someone else, ignore
        const knownOwner = observer.knownOwners.get(key);
        if(knownOwner !== undefined && knownOwner !== null && knownOwner !== pid) continue;

        // Mark "cannot own"
        // Only count/log if this is a NEW "not owner" fact
        const ckey = observer.cardKey(c.type, c.name);
        const existing = observer.notOwners.get(ckey);
        if(!existing || !existing.has(pid)){
          observer.markNotOwner(c, pid);
          newlyExcluded++;
        }

        // If Sherlock beliefs exist, also downweight pid for this card
        const w = observer.ownerWeights && observer.ownerWeights.get(key);
        if(w){
          w.set(pid, AI_CFG.sherlock.weightFloor);
          if(typeof observer.clampAndNormalizeWeights === 'function'){
            observer.clampAndNormalizeWeights(key);
          }
        }
      }

      // Log only when this capacity inference affected OTHER players (not self), and only if it created new exclusions
      if(newlyExcluded > 0 &&
         pid !== observer.id &&
         observer.gameRef &&
         observer.gameRef.observerMode &&
         observer.gameRef.aiDifficulty === 'sherlock' &&
         observer.id === observer.gameRef.observerFocusId){
        const who = players[pid]?.name ?? `P${pid}`;
        observer.gameRef.obs(`ğŸ“š Capacity inference: ${who}'s hand is full â†’ ruled out ${newlyExcluded} other cards for them.`, { byPlayerId: observer.id });
      }
    }
  }
}
const clampInt=(n,min,max,def)=>{const x=Number.parseInt(n,10); if(Number.isNaN(x)) return def; return Math.max(min,Math.min(max,x));};
const slug = s => String(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');

/* Data */
/* ================================================================================
 * [SECTION 2] GAME CONSTANTS
 * ================================================================================ */

const SUSPECTS=["Green","Mustard","Peacock","Plum","Scarlet","White"];
const SUSPECT_TITLES={Green:"Rev. Green",Mustard:"Col. Mustard",Peacock:"Mrs Peacock",Plum:"Prof. Plum",Scarlet:"Miss Scarlet",White:"Mrs White"};
const WEAPONS=["Candlestick","Dagger","Lead Pipe","Revolver","Rope","Wrench"];
const ROOMS=["Study","Hall","Lounge","Library","Billiard Room","Dining Room","Conservatory","Ballroom","Kitchen"];
const START_ROOMS=["Study","Lounge","Kitchen","Conservatory","Billiard Room","Hall"];

const displaySuspect=id=>SUSPECT_TITLES[id]||id;
const displayCardName=(type,name)=> type==='Suspect'?displaySuspect(name):name;

// Room icons for the board and casebook
const ROOM_ICON = {
  "Study": "ğŸ“",
  "Hall": "ğŸ§¥",
  "Lounge": "ğŸ›‹ï¸",
  "Library": "ğŸ“–",
  "Billiard Room": "ğŸ±",
  "Dining Room": "ğŸ½ï¸",
  "Conservatory": "ğŸª´",
  "Ballroom": "ğŸ’ƒ",
  "Kitchen": "ğŸ¥©",
  "Classified Files": "ğŸ•µï¸â€â™‚ï¸"
};

/* Movement (kept as in your current build, including passages on any dice) */
const ROOM_DICE={
  "Study":{1:["Kitchen","Hall"],2:["Kitchen","Hall","Library"],3:["Kitchen","Hall","Library","Lounge"],4:["Kitchen","Hall","Library","Lounge","Billiard Room"],5:["Kitchen","Hall","Library","Lounge","Billiard Room","Dining Room"],6:["Kitchen","Hall","Library","Lounge","Billiard Room","Dining Room","Conservatory"]},
  "Hall":{1:["Study"],2:["Study","Lounge"],3:["Study","Lounge","Library"],4:["Study","Lounge","Library","Dining Room"],5:["Study","Lounge","Library","Dining Room","Billiard Room"],6:["Study","Lounge","Library","Dining Room","Billiard Room","Kitchen"]},
  "Lounge":{1:["Conservatory","Dining Room"],2:["Conservatory","Dining Room","Hall"],3:["Conservatory","Dining Room","Hall","Kitchen"],4:["Conservatory","Dining Room","Hall","Kitchen","Study"],5:["Conservatory","Dining Room","Hall","Kitchen","Study","Ballroom"],6:["Conservatory","Dining Room","Hall","Kitchen","Study","Ballroom","Library"]},
  "Dining Room":{1:["Lounge"],2:["Lounge","Kitchen"],3:["Lounge","Kitchen","Hall"],4:["Lounge","Kitchen","Hall","Ballroom"],5:["Lounge","Kitchen","Hall","Ballroom","Study"],6:["Lounge","Kitchen","Hall","Ballroom","Study","Conservatory"]},
  "Kitchen":{1:["Study","Ballroom"],2:["Study","Ballroom","Dining Room"],3:["Study","Ballroom","Dining Room","Conservatory"],4:["Study","Ballroom","Dining Room","Conservatory","Lounge"],5:["Study","Ballroom","Dining Room","Conservatory","Lounge","Billiard Room"],6:["Study","Ballroom","Dining Room","Conservatory","Lounge","Billiard Room","Hall"]},
  "Ballroom":{1:["Kitchen"],2:["Kitchen","Conservatory"],3:["Kitchen","Conservatory","Dining Room"],4:["Kitchen","Conservatory","Dining Room","Billiard Room"],5:["Kitchen","Conservatory","Dining Room","Billiard Room","Lounge"],6:["Kitchen","Conservatory","Dining Room","Billiard Room","Lounge","Library"]},
  "Conservatory":{1:["Lounge","Billiard Room"],2:["Lounge","Billiard Room","Ballroom"],3:["Lounge","Billiard Room","Ballroom","Library"],4:["Lounge","Billiard Room","Ballroom","Library","Kitchen"],5:["Lounge","Billiard Room","Ballroom","Library","Kitchen","Study"],6:["Lounge","Billiard Room","Ballroom","Library","Kitchen","Study","Dining Room"]},
  "Billiard Room":{1:["Conservatory","Library"],2:["Conservatory","Library","Ballroom"],3:["Conservatory","Library","Ballroom","Study"],4:["Conservatory","Library","Ballroom","Study","Kitchen"],5:["Conservatory","Library","Ballroom","Study","Kitchen","Hall"],6:["Conservatory","Library","Ballroom","Study","Kitchen","Hall","Dining Room"]},
  "Library":{1:["Billiard Room"],2:["Billiard Room","Study"],3:["Billiard Room","Study","Conservatory"],4:["Billiard Room","Study","Conservatory","Hall"],5:["Billiard Room","Study","Conservatory","Hall","Ballroom"],6:["Billiard Room","Study","Conservatory","Hall","Ballroom","Lounge"]}
};
function diceReachable(room,dice){
  const d=Math.max(1,Math.min(6,dice|0));
  const t=ROOM_DICE[room];
  return new Set((t&&t[d])?t[d]:[]);
}

/* DOM */
const el=id=>document.getElementById(id);
function log(msg){
  const box=el('log');
  const t=new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  box.textContent+=`[${t}] ${msg}\n`;
  box.scrollTop=box.scrollHeight;
}

/* Prompt helpers */
/* ================================================================================
 * [SECTION 7] USER INTERFACE PROMPTS
 * ================================================================================ */

function renderPrompt({title="",bodyHTML="",actions=[]}){
  return new Promise(resolve=>{
    const box=el('gameplayPromptBox');if(!box){resolve(null);return;}
    box.innerHTML="";
    const t=document.createElement('div');t.className='promptTitle';t.textContent=title;box.appendChild(t);
    const b=document.createElement('div');b.className='promptBody';b.innerHTML=bodyHTML;box.appendChild(b);
    const a=document.createElement('div');a.className='promptActions';
    actions.forEach(act=>{
      const btn=document.createElement('button');
      btn.textContent=act.label||'OK';
      if(act.className) btn.className=act.className;
      btn.onclick=()=>resolve(act.value!==undefined?act.value:true);
      a.appendChild(btn);
    });
    box.appendChild(a);
  });
}
function setPromptMessage(title, bodyHTML){
  const box=el('gameplayPromptBox');if(!box) return;
  box.innerHTML="";
  const t=document.createElement('div');t.className='promptTitle';t.textContent=title;box.appendChild(t);
  const b=document.createElement('div');b.className='promptBody';b.innerHTML=bodyHTML;box.appendChild(b);
  const a=document.createElement('div');a.className='promptActions';box.appendChild(a);
}
function clearGameplayPrompt(){
  const box=el('gameplayPromptBox');
  if(box) box.innerHTML='<div class="placeholder">Game-play prompts will appear here</div>';
}
async function showInfoPrompt(title,html){
  const r=await renderPrompt({title,bodyHTML:html,actions:[{label:'OK',value:true}]});
  clearGameplayPrompt();return r;
}
async function showChoicePrompt(title, promptHTML, choices, { allowCancel = true } = {}){
  const buttons=choices.map(ch=>({label:ch.label,value:ch.value,className:ch.className||'secondary'}));
  if(allowCancel) buttons.push({label:'Cancel',value:null,className:'secondary'});
  const r=await renderPrompt({title,bodyHTML:promptHTML,actions:buttons});
  clearGameplayPrompt();return r;
}
async function promptPlayAgain(){
  const r=await renderPrompt({
    title:'Play Again?',
    bodyHTML:`<div>Would you like to play again?</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">Start a new game with fresh cards.</div>`,
    actions:[{label:'New Game',value:true,className:'danger'}]
  });
  clearGameplayPrompt();
  return !!r;
}

// Difficulty helpers & labels
const DIFF_LABELS = {
  basic   : 'Basic inference',
  smart   : 'Smarter inference',
  sherlock: 'Sherlock (expert + human-like quirks)',
  // Back-compat alias if old saves or code still sets "deep":
  deep    : 'Smarter inference'
};
const normDiff = (d) => (d === 'deep' ? 'smart' : d); // map old "deep" to "smart"
const isAdvancedAI = (d) => (d === 'smart' || d === 'sherlock' || d === 'deep');
const isSherlock   = (d) => (d === 'sherlock');

/* Setup prompts */
async function promptGameSetup(){
  const body = `
    <div style="margin-bottom:10px;">Choose game setup:</div>
    <div class="row" style="margin-bottom:10px;">
      <label><b>Difficulty:</b>
        <select id="diffSel">
          <option value="basic" selected>ğŸŒ Basic</option>
          <option value="smart">ğŸ§  Smart</option>
          <option value="sherlock">ğŸ” Sherlock</option>
        </select>
      </label>
    </div>
    <div class="row" style="margin-bottom:10px;">
      <label><b>Opponents:</b>
        <select id="oppCountSel">
          <option value="2" selected>2 opponents (3 players)</option>
          <option value="3">3 opponents (4 players)</option>
          <option value="4">4 opponents (5 players)</option>
          <option value="5">5 opponents (6 players)</option>
        </select>
      </label>
    </div>
    <div class="row">
      <label><b>Mode:</b>
        <select id="modeSel">
          <option value="normal" selected>Normal Play</option>
          <option value="coach">AI Coach</option>
        </select>
      </label>
    </div>
    <div style="margin-top:10px;color:var(--muted);font-size:12px;">
      <b>Normal:</b> You play as Player 1, AI controls the rest.<br>
      <b>AI Coach:</b> AI suggests moves for Player 1, you make the final choice.
    </div>
  `;
  await renderPrompt({ title:'New Game Setup', bodyHTML: body, actions:[{label:'Continue', value:true}] });
  const diffRaw = document.getElementById('diffSel')?.value || 'basic';
  const diff = normDiff(diffRaw);
  const oppRaw = document.getElementById('oppCountSel')?.value;
  const modeRaw = document.getElementById('modeSel')?.value || 'normal';
  const observer = (modeRaw === 'coach');
  
  // Use the selected number of opponents for both normal and coach mode
  const opp = clampInt(oppRaw, 2, 5, 2);
  
  clearGameplayPrompt();
  return { opp, diff, observer };
  
  clearGameplayPrompt();
  return { opp, diff, observer };
}

async function promptHumanSuspect(available){
  const opts=available.map(s=>`<option value="${s}">${displaySuspect(s)}</option>`).join("");
  const body=`<div style="margin-bottom:10px;">Pick your character:</div>
    <div class="row"><label><b>Suspect:</b> <select id="humanSusSel">${opts}</select></label></div>
    <div style="margin-top:10px;color:var(--muted);font-size:12px;">The remaining suspects will be assigned to AIs.</div>`;
  await renderPrompt({title:'Choose Your Character',bodyHTML:body,actions:[{label:'Start',value:true}]});
  const pick=document.getElementById('humanSusSel')?.value||available[0];
  clearGameplayPrompt();return pick;
}

/* Manual Checklist: ticks + per-item text notes */
const CHECKLIST_KEY='cluedo_checklist_v1'; // ticked items
const CHECK_NOTES_KEY='cluedo_checkitem_notes_v1'; // per-item note text
function loadChecklist(){try{return JSON.parse(localStorage.getItem(CHECKLIST_KEY)||'{}')}catch{return {}}}
function saveChecklist(state){localStorage.setItem(CHECKLIST_KEY,JSON.stringify(state))}
function clearChecklist(){localStorage.removeItem(CHECKLIST_KEY)}
function loadCheckNotes(){try{return JSON.parse(localStorage.getItem(CHECK_NOTES_KEY)||'{}')}catch{return {}}}
function saveCheckNotes(state){localStorage.setItem(CHECK_NOTES_KEY,JSON.stringify(state))}
function clearCheckNotes(){localStorage.removeItem(CHECK_NOTES_KEY)}

/* --- Sherlock++ tuning --- */
const AI_CFG = {
  sherlock: {
    // Learning strengths
    weightBoostShow: 3.5,           // when a specific shown card is known
    weightBoostRefutePattern: 0.35, // when someone refutes a triple containing a card
    weightPenaltyNoRefute: 0.60,    // when someone fails to refute a triple
    decay: 0.985,                   // slow belief decay

    // Weight bounds
    weightFloor: 0.01,
    weightCeil:  4.00,

    // Decision-making & mistakes
    mistakeRate: 0.00,              // never intentionally throw
    earlyAccuseMinConfidence: 0.90, // still earlier than "certain", but much smarter
    earlyAccuseChance: 1.00,        // will be controlled by smarter logic in Patch 2 (not randomness)
    explorationEpsilon: 0.12,       // randomness in suggestion targets
    pickSecondBestChance: 0.03      // fewer "human quirks" that reduce strength
  }
};

// Flattened list of all cards (for belief initialization)
const ALL_CARDS = [
  ...SUSPECTS.map(n => ({type:'Suspect', name:n})),
  ...WEAPONS.map(n => ({type:'Weapon', name:n})),
  ...ROOMS.map(n => ({type:'Room', name:n}))
];

// Case file / envelope is treated as an additional "owner" in Sherlock beliefs
const CASE_FILE_ID = -1;
const CASE_FILE_NAME = 'Case File';

/* Game Model */
/* ================================================================================
 * [SECTION 3] PLAYER CLASS
 * ================================================================================
 * Manages individual player state, card tracking, and Sherlock probability logic
 * ================================================================================ */

class Player{
  constructor(id,isHuman=false,suspect=null){
    this.id=id;this.isHuman=isHuman;this.suspect=suspect;
    this.name=suspect?displaySuspect(suspect):(isHuman?'You':`AI-${id}`);
    this.hand=[];this.location='Hall';this.eliminated=false;
    this.seen=new Set();this.own=new Set();
    this.knownOwners=new Map(); // cardKey -> playerId
    this.knowledgeMeta = new Map(); // cardKey -> { status:'own'|'seen'|'deduced'|'eliminated', ownerId?:number }
    this.gameRef = null; // set by Game.resetPlayers so Player can log in Sherlock
    this.constraints=[];this.unrefuted=[];
    this.arrivedByOpponentSuggestion=false;

    // Sherlock++ state
    this.ownerWeights = new Map();     // cardKey -> Map(playerId -> weight/prob (normalized))
    this.refutationCounts = new Map(); // cardKey -> Map(playerId -> count)
    this.notOwners = new Map();        // cardKey -> Set(playerId) known NOT to own
    this.playerCount = 0;
    this.randomJitter = Math.random() * 0.02;
  }

  cardKey(type,name){return `${type}:${name}`;}

  initKnowledge(){
  for(const c of this.hand){
    const k=this.cardKey(c.type,c.name);
    this.own.add(k);
    this.seen.add(k);
    this.knownOwners.set(k,this.id);
    this.knowledgeMeta.set(k, { status:'own', ownerId:this.id });
  }
}

  // --- Sherlock++ belief init (called after dealing)
  initBeliefs(players){
    this.playerCount = players.length;
    // uniform weights initially
    for(const c of ALL_CARDS){
      const key=this.cardKey(c.type,c.name);
      const w=new Map();

      // All players start equally likely to own the card...
      for(const p of players) w.set(p.id, 1.0);

      // ...and the case file is also a possible "owner"
      w.set(CASE_FILE_ID, 1.0);

      this.ownerWeights.set(key, w);
      this.clampAndNormalizeWeights(key);
    }

    // I own my cards with certainty (others near-floor)
    for(const c of this.hand){
      const key=this.cardKey(c.type,c.name);
      const w = this.ownerWeights.get(key);
      if (!w) continue;
      for(const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
      w.set(this.id, AI_CFG.sherlock.weightCeil);
      this.clampAndNormalizeWeights(key);
    }
  }

  clampAndNormalizeWeights(key){
    const w=this.ownerWeights.get(key); if(!w) return;
    let sum=0;
    for(const [pid,val] of w){
      const clamped=Math.max(AI_CFG.sherlock.weightFloor,Math.min(AI_CFG.sherlock.weightCeil,val));
      w.set(pid,clamped); sum+=clamped;
    }
    if(sum>0){for(const [pid,val] of w) w.set(pid,val/sum);}
  }

  decayBeliefs(){
    for(const [key,w] of this.ownerWeights){
      for(const [pid,val] of w) w.set(pid, val*AI_CFG.sherlock.decay);
      this.clampAndNormalizeWeights(key);
    }
  }

  markSeen(card,ownerId=null){
    const k=this.cardKey(card.type,card.name);
    this.seen.add(k);
    if(ownerId!==null&&ownerId!==undefined) this.knownOwners.set(k,ownerId);

    // provenance
    if(this.own.has(k)){
      this.knowledgeMeta.set(k,{status:'own',ownerId:this.id});
    }else if(ownerId!==null && ownerId!==undefined){
      this.knowledgeMeta.set(k,{status:'seen',ownerId});
    }else{
      // seen but unknown owner => treat as eliminated (not in case file)
      this.knowledgeMeta.set(k,{status:'eliminated'});
    }  
  }

  // Negative knowledge: mark someone does NOT own a card
  markNotOwner(card, playerId){
    const key=this.cardKey(card.type,card.name);
    let set=this.notOwners.get(key);
    if(!set){set=new Set(); this.notOwners.set(key,set);}
    set.add(playerId);
  }

  markEliminated(type,name){
    const key=this.cardKey(type,name);
    if(this.own.has(key)) return; // never eliminate own card
    this.seen.add(key);
    if(!this.knownOwners.has(key)){
      this.knowledgeMeta.set(key,{status:'eliminated'});
    }

    // Sherlock: eliminated means "not in case file"
    const w = this.ownerWeights?.get(key);
    if(w){
      w.set(CASE_FILE_ID, AI_CFG.sherlock.weightFloor);
      this.clampAndNormalizeWeights(key);
    }
  }

  isCleared(type,name){return this.seen.has(this.cardKey(type,name));}
  possibleSet(type){
    const list=type==='Suspect'?SUSPECTS:type==='Weapon'?WEAPONS:ROOMS;
    return list.filter(n=>!this.isCleared(type,n));
  }
  hasAnyOf(triple){
    return triple.filter(t=>this.hand.some(c=>c.type===t.type&&c.name===t.name));
  }

  addRefuteConstraint(refuterId,cards){
    const keys=new Set(cards.map(c=>this.cardKey(c.type,c.name)));
    this.constraints.push({refuterId,keys});

    // ğŸ§  Smart-level reasoning log (observer mode): "X has one of these"
    if(this.gameRef?.observerMode){
      const me = this.gameRef.players?.[this.id]?.name ?? `P${this.id}`;
      const who = this.gameRef.players?.[refuterId]?.name ?? `P${refuterId}`;
      const list = [...keys].join(', ');
      this.gameRef.obs(`ğŸ’­ Hmm! ${who} has one of ${list}`, { byPlayerId: this.id });
    }

    this.propagateConstraints();
  }

  propagateConstraints(){
    let changed=true;
    while(changed){
      changed=false;
      for(let i=this.constraints.length-1;i>=0;i--){
        const c=this.constraints[i];
        // If we already know a card owned by refuter, satisfied
        let satisfied=false;
        for(const k of c.keys){
          const owner=this.knownOwners.get(k);
          if(owner===c.refuterId){satisfied=true;break;}
        }
        if(satisfied){ this.constraints.splice(i,1); changed=true; continue; }

        // Prune keys that are owned by others, or cannot be owned by refuter (negative knowledge)
        for(const k of [...c.keys]){
          const owner=this.knownOwners.get(k);
          if(owner!==undefined&&owner!==null&&owner!==c.refuterId){
            c.keys.delete(k); changed=true; continue;
          }
          const noSet = this.notOwners.get(k);
          if (noSet && noSet.has(c.refuterId)) {
            c.keys.delete(k); changed = true;
          }
        }

        // If only one remains -> deduce ownership
        if(c.keys.size===1){
          const [onlyKey]=c.keys;

          this.seen.add(onlyKey);
          this.knownOwners.set(onlyKey,c.refuterId);

          // provenance: deduced
          if(!this.own.has(onlyKey)){
            this.knowledgeMeta.set(onlyKey,{status:'deduced',ownerId:c.refuterId});
          }

          // âœ… Smart + Sherlock deduction log (observer mode): collapse -> must own
          if(this.gameRef?.observerMode){
            const me = this.gameRef.players?.[this.id]?.name ?? `P${this.id}`;
            const ownerName = this.gameRef.players?.[c.refuterId]?.name ?? `P${c.refuterId}`;
            this.gameRef.obs(`ğŸ’¡ Aha! ${ownerName} has ${onlyKey}`, { byPlayerId: this.id });
          }

          this.constraints.splice(i,1);
          changed=true; continue;
        }

        // If impossible set -> drop
        if(c.keys.size===0){
          this.constraints.splice(i,1); changed=true;
        }
      }
    }
  }

  // Mild inference (unchanged)
  // If two of a triple are cleared, the third must be solution (eliminate all others in that category)
  // Implemented in Game.applyMildInference()

  // --- Sherlock++ learning hooks ---
  noteNoRefute(playerId,triple){
    // For each card: downweight that player as a possible owner
    for(const c of triple){
      const beforeCase = this._pCaseNorm(c);
      const beforeOwn  = this._pOwner(c, playerId);
      const key=this.cardKey(c.type,c.name);
      const w=this.ownerWeights.get(key);
      if(!w) continue;
      const cur=w.get(playerId) ?? 0;
      w.set(playerId, cur*AI_CFG.sherlock.weightPenaltyNoRefute);
      this.clampAndNormalizeWeights(key);

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[playerId]?.name ?? `P${playerId}`;
        const afterCase = this._pCaseNorm(c);
        const afterOwn  = this._pOwner(c, playerId);
      }

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[playerId]?.name ?? `P${playerId}`;
      }
    }
  }

  noteRefutePattern(refuterId,triple){
    for(const c of triple){
      const key=this.cardKey(c.type,c.name);
      const beforeCase = this._pCaseNorm(c);
      const beforeOwn  = this._pOwner(c, refuterId);
      const w=this.ownerWeights.get(key);
      if(!w) continue;
      // pattern memory
      const cntMap = this.refutationCounts.get(key) || new Map();
      cntMap.set(refuterId, (cntMap.get(refuterId) || 0) + 1);
      this.refutationCounts.set(key, cntMap);

      const cur=w.get(refuterId) ?? 0.0001;
      w.set(refuterId, cur + AI_CFG.sherlock.weightBoostRefutePattern);
      this.clampAndNormalizeWeights(key);

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[refuterId]?.name ?? `P${refuterId}`;
        const afterCase = this._pCaseNorm(c);
        const afterOwn  = this._pOwner(c, refuterId);
      }

      if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
        const who = this.gameRef.players[refuterId]?.name ?? `P${refuterId}`;
        // We log per-card after update, but need "before" â€“ so compute before at top of loop:
        // (Handled below by capturing before values per card.)
      }

    }
  }

  noteCardShown(card,ownerId){
    const key=this.cardKey(card.type,card.name);
    this.seen.add(key);
    this.knownOwners.set(key,ownerId);
    const w=this.ownerWeights.get(key);
    if(w){
      for(const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
      w.set(CASE_FILE_ID, AI_CFG.sherlock.weightFloor); // âœ… cannot be in case file if shown by a player
      w.set(ownerId, AI_CFG.sherlock.weightCeil);
      this.clampAndNormalizeWeights(key);
    }

    if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
      const ownerName = this.gameRef.players[ownerId]?.name ?? `P${ownerId}`;
      const who = this.gameRef.players[ownerId]?.name ?? `P${ownerId}`;
      const afterCase = this._pCaseNorm(card);
      const afterOwn  = this._pOwner(card, ownerId);
    }
  }

  // Sherlock beliefs: lock a specific card into the case file with near-certainty
  noteCaseFileCard(card){
    const key = this.cardKey(card.type,card.name);
    const w = this.ownerWeights.get(key);
    if(!w) return;

    // Set all owners (players) to floor, and case-file to ceil
    for(const [pid] of w) w.set(pid, AI_CFG.sherlock.weightFloor);
    w.set(CASE_FILE_ID, AI_CFG.sherlock.weightCeil);
    this.clampAndNormalizeWeights(key);

    if(this.gameRef?.observerMode && this.gameRef.aiDifficulty==='sherlock' && this.id===this.gameRef.observerFocusId){
      this.gameRef.obs(`ğŸ•µï¸â€â™‚ï¸ Right! ${key} is guilty`, { byPlayerId: this.id });
    }
  }
  // --- Sherlock: category-normalised probability that an item is in the case file ---
  // Ensures probabilities within each category (Suspect/Weapon/Room) sum to 1
  // across remaining (not cleared) candidates.
  caseFileProbNormalized(type, name){
    // If already cleared/eliminated/owned/seen, it cannot be in the case file
    if(this.isCleared(type, name)) return 0;

    const list = (type==='Suspect'?SUSPECTS : type==='Weapon'?WEAPONS : ROOMS);

    // Remaining candidates in this category (not cleared)
    const remaining = list.filter(n => !this.isCleared(type, n));

    // If only one remains, it must be the case-file item for this category
    if(remaining.length === 1){
      return (remaining[0] === name) ? 1 : 0;
    }

    // Sum raw P(case file) over remaining candidates
    let sum = 0;
    for(const n of remaining){
      const key = this.cardKey(type, n);
      const w = this.ownerWeights.get(key);
      const pCase = w ? (w.get(CASE_FILE_ID) ?? 0) : 0;
      sum += pCase;
    }

    // If everything collapsed near zero, fall back to uniform over remaining
    if(sum <= 1e-9){
      return 1 / remaining.length;
    }

    // Normalised value for this item
    const key = this.cardKey(type, name);
    const w = this.ownerWeights.get(key);
    const pCase = w ? (w.get(CASE_FILE_ID) ?? 0) : 0;

    return pCase / sum;
  }

  _pct(x){ return `${Math.round(Math.max(0, Math.min(1, x)) * 100)}%`; }

  _pCaseNorm(card){
    return this.caseFileProbNormalized(card.type, card.name);
  }

  _pOwner(card, ownerId){
    const key = this.cardKey(card.type, card.name);
    const w = this.ownerWeights.get(key);
    return w ? (w.get(ownerId) ?? 0) : 0;
  }

  // Entropy of ownership distribution for a card (higher => more uncertain/informative)
  entropyForCardKey(key){
    const w=this.ownerWeights.get(key); if(!w) return 0;
    const vals = Array.from(w.values());
    const sum = vals.reduce((a,b)=>a+b,0)||1;
    const probs = vals.map(v=>v/sum);
    return -probs.reduce((acc,p)=>acc + (p>0 ? p*Math.log(p) : 0), 0);
  }

  // Sherlock++: pick suspect & weapon that look most informative (entropy + tiny jitter)
  pickSmartSuggestionParts(){
    const pickFrom=(type)=>{
      const pool=this.possibleSet(type);
      const candidates=pool.length ? pool : (type==='Suspect'?SUSPECTS : type==='Weapon'?WEAPONS : ROOMS);
      let best=[],bestScore=-Infinity;
      for(const name of candidates){
        if(this.isCleared(type,name)) continue;
        const key=this.cardKey(type,name);
        const jitter=(Math.random()-0.5)*AI_CFG.sherlock.explorationEpsilon + this.randomJitter;
        const score=this.entropyForCardKey(key)+jitter;
        if(score>bestScore){best=[name];bestScore=score;}
        else if(score===bestScore){best.push(name);}
      }
      const pick = best.length ? choice(best) : choice(candidates);
      // sometimes pick second-best to look human
      if(Math.random()<AI_CFG.sherlock.pickSecondBestChance){
        const alt = candidates.filter(n => n!==pick);
        if(alt.length) return choice(alt);
      }
      return pick;
    };
    return {
      suspect: pickFrom('Suspect'),
      weapon : pickFrom('Weapon')
    };
  }

  // Sherlock: pick the most likely case-file item in a category using category-normalised probabilities
  beliefsTopFor(type){
    const list = (type==='Suspect'?SUSPECTS : type==='Weapon'?WEAPONS : ROOMS);

    let bestName=null, bestVal=-1, second=-1;

    for(const name of list){
      if(this.isCleared(type, name)) continue;

      const p = this.caseFileProbNormalized(type, name);

      if(p > bestVal){ second = bestVal; bestVal = p; bestName = name; }
      else if(p > second){ second = p; }
    }

    const margin = Math.max(0.0001, bestVal - Math.max(0, second));
    const confidence = Math.max(0, Math.min(1, (bestVal * 0.75) + (margin * 0.25)));

    return { name: bestName, confidence };
  }

  planAccusationWithBeliefs(){
    const s=this.beliefsTopFor('Suspect');
    const w=this.beliefsTopFor('Weapon');
    const r=this.beliefsTopFor('Room');
    const combined = Math.pow(s.confidence * w.confidence * r.confidence, 1/3);
    return { acc: { suspect:s.name, weapon:w.name, room:r.name }, confidence: combined };
  }
}

Player.prototype.isConfidentSolution = function(){
  return this.possibleSet('Suspect').length === 1
      && this.possibleSet('Weapon').length  === 1
      && this.possibleSet('Room').length    === 1;
};
Player.prototype.inferredAccusation = function(){
  return {
    suspect: this.possibleSet('Suspect')[0],
    weapon : this.possibleSet('Weapon')[0],
    room   : this.possibleSet('Room')[0]
  };
};

/* ================================================================================
 * [SECTION 4] MAIN GAME CLASS
 * ================================================================================
 * Core game state, card dealing, turn management, and win conditions
 * ================================================================================ */

class Game{
  constructor(){
    this.players=[];this.turnIndex=0;this.solution=null;
    this.suspectLoc=new Map();this.weaponLoc=new Map();
    this.dice=null;this.reachable=new Set();
    this.awaitingMove=false;this.awaitingDecision=false;this.stayedInsteadOfRoll=false;
    this.aiDifficulty='basic';this.humanTurnsStarted=0;this.gameOver=false;
    this.trial=null;
    this.observerMode = false;
    this.observerFocusId = 0;
    this.coachMode = false; // Coach mode = observer logging + human executes focus player's choices
    this.obsLog = [];
    this.obsLogMax = 250;
    this.sessionId=0;
    this.turnCounter = 0; // âœ… optional: for readable deduction log grouping
    this.resetPlayers(2);
  }

  obs(msg, { byPlayerId } = {}){
    // Rolling observer deductions log (Smart/Sherlock only)
    if(!this.observerMode) return;
    if(this.aiDifficulty === 'basic') return;

    // âœ… MUST be explicitly attributed to a player
    if(byPlayerId === undefined || byPlayerId === null) return;

    // âœ… Focus-only: only keep logs for the focused player
    if(byPlayerId !== this.observerFocusId) return;

    const t = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    this.obsLog.push(`[${t}] ${msg}`);
    if(this.obsLog.length > this.obsLogMax) this.obsLog.shift();
    // ğŸ”„ Immediately repaint the deductions log so it appears BEFORE the next action/render
    const logBox = document.getElementById('observerDeduceLog');
    if (logBox) {
      logBox.textContent = (this.obsLog && this.obsLog.length)
        ? this.obsLog.slice(-200).join('\n')
        : '(deductions log will appear here)';
      logBox.scrollTop = logBox.scrollHeight;
    }
  }

  newSession(){this.sessionId++;return this.sessionId;}
  isActiveSession(id){return id===this.sessionId;}

  // ... keep the rest of your Game methods here (initAllSuspectPawns, setup, makeSuggestion, aiTurn, etc.)
  isActiveSession(id){return id===this.sessionId;}

  initAllSuspectPawns(){
    this.suspectLoc=new Map();
    SUSPECTS.forEach((s,i)=>this.suspectLoc.set(s,START_ROOMS[i]||'Hall'));
  }
  initWeaponsOnBoard(){
    this.weaponLoc=new Map();
    const rooms=shuffle(ROOMS.slice());
    WEAPONS.forEach((w,i)=>this.weaponLoc.set(w,rooms[i%rooms.length]));
  }
  resetPlayers(n){
    n=clampInt(n,2,5,2);
    this.newSession();
    this.initAllSuspectPawns();
    this.weaponLoc=new Map();
    this.players=[new Player(0,true,null)];
    for(let i=1;i<=n;i++) this.players.push(new Player(i,false,null));

    // âœ… Link each Player back to this Game (needed for Observer logging)
    this.players.forEach(p => p.gameRef = this);

    this.players.forEach(p=>{
      p.hand=[];p.eliminated=false;p.seen=new Set();p.own=new Set();
      p.knownOwners=new Map();p.knowledgeMeta = new Map();p.constraints=[];p.unrefuted=[];
      p.arrivedByOpponentSuggestion=false;
      p.name=p.suspect?displaySuspect(p.suspect):(p.isHuman?'You':`AI-${p.id}`);
      p.location='Hall';
    });

    this.turnIndex=0;this.solution=null;this.dice=null;this.reachable=new Set();
    this.awaitingMove=false;this.awaitingDecision=false;this.stayedInsteadOfRoll=false;
    this.humanTurnsStarted=0;this.gameOver=false;
    this.trial=null;    
  }
  assignSuspects(human){
    const pool=SUSPECTS.slice();const i=pool.indexOf(human);if(i>=0) pool.splice(i,1);
    shuffle(pool);
    const me=this.players[0];me.suspect=human;me.name=displaySuspect(human);
    for(let k=1;k<this.players.length;k++){const s=pool.shift();this.players[k].suspect=s;this.players[k].name=displaySuspect(s);}
    this.players.forEach(p=>{if(p.suspect)p.location=this.suspectLoc.get(p.suspect)||'Hall';});
  }
  buildDeck(){
    const cards=[];
    for(const s of SUSPECTS) cards.push({type:'Suspect',name:s});
    for(const w of WEAPONS) cards.push({type:'Weapon',name:w});
    for(const r of ROOMS) cards.push({type:'Room',name:r});
    return cards;
  }

  setup(){
    log('Setting up gameâ€¦');
    this.solution={suspect:choice(SUSPECTS),weapon:choice(WEAPONS),room:choice(ROOMS)};
    const deck=this.buildDeck().filter(c=>{
      return !((c.type==='Suspect'&&c.name===this.solution.suspect)||
               (c.type==='Weapon'&&c.name===this.solution.weapon)||
               (c.type==='Room'&&c.name===this.solution.room));
    });
    shuffle(deck);
    this.players.forEach(p=>p.hand=[]);
    let p=0; while(deck.length) this.players[p++%this.players.length].hand.push(deck.pop());
    this.players.forEach(pl=>pl.initKnowledge());

    this.initAllSuspectPawns();
    this.players.forEach(pl=>{ if(pl.suspect) pl.location=this.suspectLoc.get(pl.suspect)||'Hall'; });
    this.initWeaponsOnBoard();

    // Sherlock++: initialize beliefs after hands are dealt
    this.players.forEach(pl=>pl.initBeliefs(this.players));

    log(`Cards dealt. Playing with ${this.players.length-1} opponents (${this.players.length} total players).`);
    log(`AI difficulty: ${DIFF_LABELS[this.aiDifficulty] || this.aiDifficulty}.`);
    renderAll(this);this.updateTurnUI();
  }

  currentPlayer(){return this.players[this.turnIndex];}
  isCoachFocus(pl){
    return !!this.coachMode && !!this.observerMode && pl && (pl.id === this.observerFocusId);
  }  
  nextTurnIndex(i){
    let x=i;for(let s=0;s<100;s++){x=(x+1)%this.players.length;if(!this.players[x].eliminated) return x;}return i;
  }
  computeReachable(start,steps){return diceReachable(start,steps);}
  updateTurnUI(){
    const pl=this.currentPlayer();
    const who = (this.observerMode && pl.id===this.observerFocusId)
      ? `Coach Focus (${pl.name})`
      : (pl.isHuman ? `You (${pl.name})` : pl.name);
    el('turnPill').textContent=`Turn: ${who}${pl.eliminated?' (eliminated)':''}`;
    el('locPill').textContent=`Location: ${pl.location}`;
    renderAll(this);
  }

  // NO-REFUTE deduction (ALL difficulties):
  // If no one refutes an AI's suggestion, then for each suggested card that the AI does NOT hold,
  // that card must be in the case file. Therefore eliminate all OTHER cards in that category.
  noRefuteDeduction(pl, { suspect, weapon, room }){
    const owns = (type, name) => pl.hand.some(c => c.type === type && c.name === name);
  
    const eliminateAllOthers = (type, keepName, list) => {
      for (const n of list) {
        if (n !== keepName) pl.markEliminated(type, n);
      }
    };
  
    // Only deduce a category if the suggester does NOT personally hold that suggested card.
    if (!owns('Suspect', suspect)) {
      eliminateAllOthers('Suspect', suspect, SUSPECTS);
      // Sherlock belief: this suspect is in the case file
      if(pl.ownerWeights && pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Suspect',name:suspect});
    }

    if (!owns('Weapon', weapon)) {
      eliminateAllOthers('Weapon', weapon, WEAPONS);
      if(pl.ownerWeights && pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Weapon',name:weapon});
    }

    if (!owns('Room', room)) {
      eliminateAllOthers('Room', room, ROOMS);
      if(pl.ownerWeights && pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Room',name:room});
    }
  
    if (this.observerMode){
      this.obs(`ğŸ§¾ NO-REFUTE deduction applied for ${pl.name}: eliminated non-matching cards in any category where ${pl.name} does not hold the suggested card.`);
    }
  }

  applyMildInference(pl){
    for(const t of pl.unrefuted){
      const s=pl.isCleared('Suspect',t.suspect),
            w=pl.isCleared('Weapon',t.weapon),
            r=pl.isCleared('Room',t.room);
      if((s?1:0)+(w?1:0)+(r?1:0)===2){
        if(!s){
          SUSPECTS.forEach(x=>{ if(x!==t.suspect) pl.markEliminated('Suspect',x); });
          if(pl.ownerWeights && pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Suspect',name:t.suspect});
        }
        if(!w){
          WEAPONS.forEach(x=>{ if(x!==t.weapon) pl.markEliminated('Weapon',x); });
          if(pl.ownerWeights && pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Weapon',name:t.weapon});
        }
        if(!r){
          ROOMS.forEach(x=>{ if(x!==t.room) pl.markEliminated('Room',x); });
          if(pl.ownerWeights && pl.noteCaseFileCard) pl.noteCaseFileCard({type:'Room',name:t.room});
        }
      }
    }
  }

  applyInference(pl){
    if(pl.isHuman) return;
    // BASIC: no inference pipeline at all.
    if(this.aiDifficulty === 'basic') return;

    // SMART / SHERLOCK: normal inference
    pl.propagateConstraints();
    this.applyMildInference(pl);

    // SHERLOCK: add capacity (hand-size) constraints
    if(this.aiDifficulty === 'sherlock'){
      applyHandSizeConstraints(pl, this.players);
      // Re-run propagation because hand-size constraints can unlock deductions
      pl.propagateConstraints();
    }
  }

  coachAccusationPlan(pl){
    if(!pl || pl.eliminated) return null;

    // Certain accusation (all difficulties) â€” matches aiTurn's "certain" branch
    if(pl.isConfidentSolution()) return pl.inferredAccusation();

    // Sherlock: belief-aware early accusation if evidence threshold met
    if(isSherlock(this.aiDifficulty)){
      const hasEvidence =
        (pl.seen.size > pl.own.size) ||
        (pl.constraints && pl.constraints.length > 0) ||
        (pl.unrefuted && pl.unrefuted.length > 0);

      if(hasEvidence && typeof pl.planAccusationWithBeliefs === 'function'){
        const plan = pl.planAccusationWithBeliefs();
        if(plan && plan.acc && plan.confidence >= AI_CFG.sherlock.earlyAccuseMinConfidence){
          return plan.acc;
        }
      }
    }
    return null;
  }

  coachStartRecommendation(pl){
    // Decide: roll / stay / accuse (stay only if arrived by opponent suggestion)
    const acc = this.coachAccusationPlan(pl);
    if(acc) return { action:'accuse', acc };

    const canStay = !!pl.arrivedByOpponentSuggestion;
    if(canStay){
      const roomCleared = pl.isCleared('Room', pl.location);
      // If room is not cleared, recommend staying to get a suggestion now
      if(!roomCleared) return { action:'stay' };
    }
    return { action:'roll' };
  }

  coachRecommendMove(pl){
    // Uses the same "pickBest" logic pattern from aiTurn, but without moving yet
    const reach = [...this.reachable];
    if(!reach.length) return pl.location;

    const possibleRooms = new Set(pl.possibleSet('Room'));
    const candidates = reach.filter(r => possibleRooms.has(r));

    const nextTurnPotential = (fromRoom) => {
      const seen = new Set();
      for(let d=1; d<=6; d++){
        const arr = (ROOM_DICE[fromRoom] && ROOM_DICE[fromRoom][d]) ? ROOM_DICE[fromRoom][d] : [];
        for(const r of arr) if(possibleRooms.has(r)) seen.add(r);
      }
      return seen.size;
    };

    const pickBest = (arr) => {
      if(!arr.length) return null;
      let best = [], bestScore = -1;
      for(const r of arr){
        const s = nextTurnPotential(r);
        if(s > bestScore){ best = [r]; bestScore = s; }
        else if(s === bestScore){ best.push(r); }
      }
      return choice(best);
    };

    let dest = candidates.length ? pickBest(candidates) : pickBest(reach);
    if(!dest) dest = pl.location;
    return dest;
  }

  async makeSuggestion(pl,suspect,weapon,room){
    const triple=[{type:'Suspect',name:suspect},{type:'Weapon',name:weapon},{type:'Room',name:room}];

    // Move suspect pawn and weapon into room as per suggestion
    const wasSus=this.suspectLoc.get(suspect);
    if(wasSus && wasSus!==room){
      this.suspectLoc.set(suspect,room);
      log(`${displaySuspect(suspect)} is moved from ${wasSus} to ${room} due to the suggestion.`);
    }else if(!wasSus){
      this.suspectLoc.set(suspect,room);
      log(`${displaySuspect(suspect)} is moved into ${room} due to the suggestion.`);
    }

    const ownerPlayer=this.players.find(p=>p.suspect===suspect);
    if(ownerPlayer){
      if(ownerPlayer.location!==room){
        const prev=ownerPlayer.location;
        ownerPlayer.location=room;
        ownerPlayer.arrivedByOpponentSuggestion=true;
        log(`${ownerPlayer.name} is moved from ${prev} to ${room} due to the suggestion.`);
      }
    }

    const wasWeap=this.weaponLoc.get(weapon);
    if(wasWeap && wasWeap!==room){
      this.weaponLoc.set(weapon,room);log(`${weapon} is moved from ${wasWeap} to ${room} due to the suggestion.`);
    }else if(!wasWeap){
      this.weaponLoc.set(weapon,room);log(`${weapon} is moved into ${room} due to the suggestion.`);
    }
    renderAll(this);
    log(`${pl.name} suggests: ${displaySuspect(suspect)} in the ${room} with the ${weapon}.`);

    // Resolve refutations in order
    const order=[];for(let i=1;i<this.players.length;i++) order.push(this.players[(this.turnIndex+i)%this.players.length]);

    for(const other of order){
      const matches=other.hasAnyOf(triple);

      if(matches.length>0){
        let shown;

        // 1) If the refuter is the real human player, give "Coach recommends" when there are multiple matches
        if(other.isHuman){
          let rec = null;

          // Only Sherlock uses adversarial "least informative" logic
          if(this.aiDifficulty === 'sherlock' && matches.length > 1){
            rec = pickLeastInformativeRefuteCard(other, matches, pl);
          }

          const opts = [
            ...(rec ? [{
              label: `Coach recommends: ${rec.type}: ${displayCardName(rec.type, rec.name)}`,
              value: rec,
              className: ''
            }] : []),
            ...matches.map(c => ({
              label: `${c.type}: ${displayCardName(c.type,c.name)}`,
              value: c,
              className: 'secondary'
            }))
          ];

          const pick = await showChoicePrompt(
            'Choose a card to show',
            `<div>You must refute <b>${pl.name}</b> by showing ONE matching card.</div>
             ${rec ? `<div style="margin-top:8px;color:var(--muted);font-size:12px;">
               Coach recommends the least-informative choice.
             </div>` : ``}`,
            opts,
            { allowCancel:false }
          );

          shown = pick;
          log(`You show a card to ${pl.name}.`);
        }

        // 2) If the refuter is the COACH FOCUS player, YOU choose which card they show (with coach advice)
        else if(this.isCoachFocus(other)){
          let rec = null;
          if(this.aiDifficulty === 'sherlock' && matches.length > 1){
            rec = pickLeastInformativeRefuteCard(other, matches, pl);
            if(rec){
              this.obs(`ğŸ‚  Coach recommends showing: ${rec.type}: ${displayCardName(rec.type, rec.name)}`, { byPlayerId: other.id });
            }
          }

          const opts = [
            ...(rec ? [{
              label: `Coach's choice: ${rec.type}: ${displayCardName(rec.type, rec.name)}`,
              value: rec,
              className: ''
            }] : []),
            ...matches.map(c => ({
              label: `${c.type}: ${displayCardName(c.type,c.name)}`,
              value: c,
              className: 'secondary'
            }))
          ];

          const pick = await showChoicePrompt(
            'Choose a card to show',
            `<div>You must refute <b>${pl.name}</b> by showing ONE matching card.</div>
             ${rec ? `<div style="margin-top:8px;color:var(--muted);font-size:12px;">
               Coach's choice is the least-informative option.
             </div>` : ``}`,
            opts,
            { allowCancel:false }
          );

          shown = pick;
          log(`${other.name} refutes the suggestion.`);
        }

        // 3) All other AI refuters: in Sherlock, be adversarial; otherwise keep random behaviour
        else{
          if(this.aiDifficulty === 'sherlock'){
            shown = pickLeastInformativeRefuteCard(other, matches, pl) || choice(matches);
          }else{
            shown = choice(matches);
          }
          log(`${other.name} refutes the suggestion.`);
        }

        // Sherlock++: learning signals
        if(isAdvancedAI(this.aiDifficulty)){
          for(const obs of this.players){
            if(obs.isHuman) continue;
            // Observers learn refuter likely owns one of the triple
            obs.noteRefutePattern(other.id, triple);
          }
          // Suggester AI actually SEES the exact shown card; lock it in
          if(!pl.isHuman && shown){ pl.noteCardShown(shown, other.id); }
        }

        // Coach mode: show the same prompt even though the focus player is not "human"
        if (pl.isHuman || this.isCoachFocus(pl)) {
          await showInfoPrompt(
            'Card Shown',
            this.isCoachFocus(pl)
              ? `<div><b>${other.name}</b> shows <b>you</b>:</div>
                <div style="margin-top:10px;font-size:18px;">
                  <b>${shown.type}: ${displayCardName(shown.type, shown.name)}</b>
                </div>`
              : `<div><b>${other.name}</b> shows <b>${pl.name}</b>:</div>
                <div style="margin-top:10px;font-size:18px;">
                  <b>${shown.type}: ${displayCardName(shown.type, shown.name)}</b>
                </div>`
          );

          // In Coach mode the focus player is still an AI, so we MUST record the knowledge
          if (!pl.isHuman) {
            pl.markSeen(shown, other.id);
          }
        } else {
          // Legacy knowledge record (still fine)
          pl.markSeen(shown, other.id);
        }

        // Constraint reasoning for Smart/Sherlock observers
        if(isAdvancedAI(this.aiDifficulty)){
          for(const obs of this.players){
            if(obs.id===pl.id) continue; if(obs.id===other.id) continue; if(obs.isHuman) continue;
            obs.addRefuteConstraint(other.id,triple);
          }
        }

        this.applyInference(pl);
        renderAll(this);
        return {refuted:true,by:other,card:shown};
      } else {
        // Negative refutation: other could not refute => they do NOT own any of the triple
        if(isAdvancedAI(this.aiDifficulty)){
          for(const obs of this.players){
            if(obs.isHuman) continue;
            for(const c of triple) { obs.markNotOwner(c, other.id); }
            obs.noteNoRefute(other.id, triple);
          }
        }

        // âœ… Smart/Sherlock reasoning log (observer mode): "X could not refute â†’ X has none of {A,B,C}"
        if(this.observerMode && (this.aiDifficulty==='smart' || this.aiDifficulty==='sherlock')){
          const cards = triple.map(c=>`${c.type}:${c.name}`).join(', ');
        }

        // continue to next 'other'
      }
    }

    // No one could refute
    log(`No one could refute ${pl.name}'s suggestion.`);
    if(this.observerMode){
      this.obs(`âœ… No one refuted ${pl.name}'s suggestion.`);
    }

    // Apply NO-REFUTE deduction for ALL difficulties (AI only).
    if(!pl.isHuman){
      this.noRefuteDeduction(pl, { suspect, weapon, room });
    }

    // Smart/Sherlock can still keep unrefuted history for mild inference later.
    // (Basic won't use it, but keeping it doesn't hurt.)
    if(!pl.isHuman){
      pl.unrefuted.push({suspect,weapon,room});
    }

        this.applyInference(pl);
        return {refuted:false};
      }

  // === Centre-tile "trial" helpers (ACCUSED â†’ NOT GUILTY â†’ revert) ===
  beginTrial(pl, acc){
    // Save previous locations so we can revert after NOT GUILTY
    const prevSus = this.suspectLoc.get(acc.suspect);
    const prevWep = this.weaponLoc.get(acc.weapon);

    this.trial = {
      stage: 'accused',
      by: pl.name,
      acc: { ...acc },
      prev: { sus: prevSus, wep: prevWep }
    };

    // Move accused suspect + weapon to the centre (Classified Files tile)
    this.suspectLoc.set(acc.suspect, HOLDING_CELL_ID);
    this.weaponLoc.set(acc.weapon, HOLDING_CELL_ID);
  }

  restoreTrial(){
    if(!this.trial) return;
    const { acc, prev } = this.trial;

    // Put pieces back where they were
    if(prev && prev.sus) this.suspectLoc.set(acc.suspect, prev.sus);
    if(prev && prev.wep) this.weaponLoc.set(acc.weapon,  prev.wep);

    // Clear centre trial state
    this.trial = null;
  }

  checkAccusation(a){
    return a.suspect===this.solution.suspect &&
           a.weapon===this.solution.weapon &&
           a.room===this.solution.room;
  }

  async accuse(pl,acc){
    // 1) Move pieces to centre + show "ACCUSED" prompt first (tension)
    log(`${pl.name} ACCUSES: ${displaySuspect(acc.suspect)} in the ${acc.room} with the ${acc.weapon}!`);

    // Start the centre "trial" display (orange ACCUSED)
    this.beginTrial(pl, acc);
    renderAll(this);

    // Prompt describing the accusation (AI: this appears before end-of-turn summary)
    await showInfoPrompt('Accusation',
      `<div><b>${pl.name}</b> makes an accusation:</div>
       <div style="margin-top:10px;font-size:16px;">
         <b>${displaySuspect(acc.suspect)}</b> in the <b>${acc.room}</b> with the <b>${acc.weapon}</b>
       </div>
       <div style="margin-top:10px;color:var(--muted);font-size:12px;">Click OK to reveal the verdictâ€¦</div>`
    );

    if(this.observerMode){
      this.obs(`âš–ï¸ ${pl.name} ACCUSES: ${displaySuspect(acc.suspect)} / ${acc.weapon} / ${acc.room}`);
    }

    // 2) Determine verdict
    const ok = this.checkAccusation(acc);

    if(ok){
      // === CORRECT: CONVICTED (keep tokens in centre, including ROOM token) ===
      this.gameOver=true;
      this.convicted={suspect:acc.suspect,weapon:acc.weapon,room:acc.room,winner:pl.name};

      // Keep suspect + weapon in centre (already there); clear trial state (we'll use convicted UI)
      this.trial = null;

      renderAll(this);

      if(this.observerMode){
        this.obs(`ğŸ‘®â€â™‚ï¸ CONVICTED: ${pl.name} wins.`);
      }

      await showInfoPrompt('Game Over',
        `<div><b>${pl.name}</b> wins!</div>
         <div style="margin-top:10px;">Solution was: <b>${displaySuspect(this.solution.suspect)}</b> in the <b>${this.solution.room}</b> with the <b>${this.solution.weapon}</b>.</div>`
      );

      const again=await promptPlayAgain();
      if(again){ await startNewGame(game,{skipConfirm:true}); }
      return { correct:true };
    }

    // === WRONG: NOT GUILTY (keep tokens in centre temporarily, then revert) ===
    log(`âŒ Wrong accusation. ${pl.name} is eliminated from taking turns (but can still refute).`);
    pl.eliminated=true;

    // Switch centre tile to NOT GUILTY (pale yellow), keep tokens there for the prompt/summary
    if(this.trial) this.trial.stage = 'notguilty';
    renderAll(this);

    if(this.observerMode){
      this.obs(`ğŸ•Š NOT GUILTY: ${pl.name} eliminated from taking turns.`);
    }

    if(pl.isHuman){
      // Human: use the existing Wrong Accusation prompt (plus the revert behaviour after OK)
      await showInfoPrompt('Wrong Accusation',
        `<div>That accusation was <b>incorrect</b>.</div>
         <div style="margin-top:10px;">Verdict: <b>ğŸ•Š NOT GUILTY</b>.</div>
         <div style="margin-top:10px;">You are eliminated from taking turns, but you will still be asked to refute suggestions.</div>
         <div style="margin-top:10px;color:var(--muted);font-size:12px;">Click OK to continue. The pieces will return to their previous positions.</div>`
      );

      // After dismissing the prompt: revert centre + pieces
      this.restoreTrial();
      renderAll(this);
      return { correct:false };
    }

    // AI: do NOT show another prompt here.
    // The NOT GUILTY display should remain visible during the end-of-turn summary,
    // and we will restore after the summary is dismissed (handled in aiTurn()).
    return { correct:false, revertAfterSummary:true };
  }

/* ================================================================================
 * [SECTION 6] GAME FLOW FUNCTIONS
 * ================================================================================
 * Turn execution, movement, suggestions, refutations, and accusations
 * ================================================================================ */

  async beginTurn(){
    if(this.gameOver) return;
    const pl=this.currentPlayer();
    this.dice=null;this.reachable=new Set();
    this.awaitingMove=false;this.awaitingDecision=!!pl.arrivedByOpponentSuggestion;
    this.stayedInsteadOfRoll=false;
    this.updateTurnUI();

    if(pl.eliminated){ await this.endTurn(); return; }
    if(pl.isHuman || this.isCoachFocus(pl)){
      this.humanTurnsStarted++;
      await this.showRollPromptForHuman();
    }else {
      await this.aiTurn(pl);
    }
  }

  async showRollPromptForHuman(){
    const pl=this.currentPlayer();
    if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver || pl.eliminated) return;
    const firstEver=(this.humanTurnsStarted===1);
    const movedHere=this.awaitingDecision;
    let actions=[];
    if(movedHere){
      actions=[{label:'Roll Dice',value:'roll'},{label:'Stay',value:'stay',className:'secondary'},{label:'Make Accusation',value:'accuse',className:'danger'}];
    }else if(firstEver){
      actions=[{label:'Roll Dice',value:'roll'}];
    }else{
      actions=[{label:'Roll Dice',value:'roll'},{label:'Make Accusation',value:'accuse',className:'danger'}];
    }
    let body=movedHere?`<div>You were moved to <b>${pl.location}</b> by an opponent's suggestion.</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">Choose what to do this turn.</div>`
                        :`<div>It's your turn in <b>${pl.location}</b>.</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">Roll the dice to move.</div>`;
    // Coach mode: compute & log recommendation, and add a Coach's choice button
    let coachRec = null;
    if(this.isCoachFocus(pl)){
      coachRec = this.coachStartRecommendation(pl);

      const label =
        coachRec.action === 'accuse' ? 'ACCUSE' :
        coachRec.action === 'stay'   ? 'STAY'   : 'ROLL';

      // Log what Coach's choice will do
      this.obs(`ğŸ¯ Coach's choice: ${label}`, { byPlayerId: pl.id });

      // Also show it in the prompt body so the user can see it before clicking
      body += `<div style="margin-top:10px;color:var(--accent);font-size:12px;">
                <b>Coach recommends:</b> ${label}
              </div>`;

      // Put Coach's choice first
      actions = [{ label:"Coach's choice", value:'coach' }, ...actions];
    }

    const pick=await renderPrompt({title:'Your Turn',bodyHTML:body,actions});
    clearGameplayPrompt();
    if(pick==='coach' && this.isCoachFocus(pl)){
      const rec = this.coachStartRecommendation(pl);

      if(rec.action === 'accuse'){
        await this.humanAccuse({
          prefill: rec.acc,
          onCancel: () => this.showRollPromptForHuman()
        });
        return;
      }
      if(rec.action === 'stay'){
        await this.humanStayAndSuggest();
        return;
      }
      // default: roll
      await this.humanRollAndMove();
      return;
    }
    if(pick==='accuse'){ await this.humanAccuse({onCancel:()=>this.showRollPromptForHuman()}); return; }
    if(pick==='stay'){ await this.humanStayAndSuggest(); return; }
    if(pick==='roll'){ await this.humanRollAndMove(); return; }
  }

  async humanRollAndMove(){
    const pl=this.currentPlayer();
    if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver || pl.eliminated) return;
    if(this.stayedInsteadOfRoll) return;
    if(this.awaitingDecision){ this.awaitingDecision=false; pl.arrivedByOpponentSuggestion=false; }
    this.dice=randInt(1,6);
    this.reachable=this.computeReachable(pl.location,this.dice);
    this.awaitingMove=true;
    log(`You rolled a ${this.dice}. Choose a reachable room to move.`);
    this.updateTurnUI();
    setPromptMessage('Dice Result',`<div>You rolled a <b>${this.dice}</b>.</div><div style="margin-top:8px;">Now click <b>Move</b> on a highlighted room.</div>`);
    // Coach mode: recommend a room and provide a Coach's choice button to auto-move
    if(this.isCoachFocus(pl)){
      const dest = this.coachRecommendMove(pl);
      this.obs(`ğŸ§­ Coach's choice: MOVE to ${dest}`, { byPlayerId: pl.id });

      // Add a button into the currently button-less move prompt
      const box = el('gameplayPromptBox');
      const actionsDiv = box ? box.querySelector('.promptActions') : null;
      if(actionsDiv){
        actionsDiv.innerHTML = '';
        const btn = document.createElement('button');
        btn.textContent = "Coach's choice";
        btn.onclick = () => this.humanMoveTo(dest);
        actionsDiv.appendChild(btn);
      }

      // Also show the recommendation in the prompt body
      const bodyDiv = box ? box.querySelector('.promptBody') : null;
      if(bodyDiv){
        bodyDiv.innerHTML += `<div style="margin-top:10px;color:var(--accent);font-size:12px;">
                                <b>Coach recommends:</b> Move to <b>${dest}</b>
                              </div>`;
      }
    }
  }

  async humanStayAndSuggest(){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver || pl.eliminated) return;
    if(!this.awaitingDecision) return;
    this.awaitingDecision=false; this.stayedInsteadOfRoll=true; pl.arrivedByOpponentSuggestion=false;
    log(`You chose to stay in ${pl.location} (no roll).`);
    this.updateTurnUI();
    await this.openSuggestionPromptAuto();
  }

  async humanMoveTo(room){
    const pl=this.currentPlayer();
    if(!(pl.isHuman || this.isCoachFocus(pl)) || !this.awaitingMove) return;
    if(!this.reachable.has(room)) return;
    pl.location=room; if(pl.suspect) this.suspectLoc.set(pl.suspect,room);
    this.awaitingMove=false; pl.arrivedByOpponentSuggestion=false;
    log(`You moved to ${room}.`);
    this.updateTurnUI();
    await this.openSuggestionPromptAuto();
  }

  async openSuggestionPromptAuto(){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || pl.eliminated || this.gameOver) return;
    if(this.awaitingMove) return;
    const room = pl.location;

    // Coach mode: compute recommendation and log it
    let coachPick = null;
    if(this.isCoachFocus(pl)){
      if(isSherlock(this.aiDifficulty)){
        // Mirror the same "thinking" text aiTurn uses (so the log stays the same style)
        const rankEntropy = (type, list) => {
          const arr = list.map(n => ({ n, e: pl.entropyForCardKey(pl.cardKey(type, n)) }));
          arr.sort((a,b)=>b.e-a.e);
          return arr.slice(0,3);
        };
        const susPool = pl.possibleSet('Suspect');
        const wepPool = pl.possibleSet('Weapon');
        const susCands = susPool.length ? susPool : SUSPECTS;
        const wepCands = wepPool.length ? wepPool : WEAPONS;
        const topSus = rankEntropy('Suspect', susCands);
        const topWep = rankEntropy('Weapon', wepCands);

        const pick = pl.pickSmartSuggestionParts();
        coachPick = { suspect: pick.suspect, weapon: pick.weapon };

        this.obs(
          `ğŸ” Let's see... top suspects are ${topSus.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')} and top weapons are ${topWep.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')}. I'll check out ${coachPick.suspect} and ${coachPick.weapon} in the ${room}.`,
          { byPlayerId: pl.id }
        );
      } else {
        // Smart/basic style recommendation (same message format as aiTurn uses for smart)
        const sC = pl.possibleSet('Suspect');
        const wC = pl.possibleSet('Weapon');
        const susCands = sC.length ? sC : SUSPECTS;
        const wepCands = wC.length ? wC : WEAPONS;

        coachPick = { suspect: choice(susCands), weapon: choice(wepCands) };

        if(this.aiDifficulty==='smart'){
          this.obs(
            `ğŸ” Let's see... suspects remaining are ${susCands.length} and weapons remaining are ${wepCands.length}. I'll check out ${coachPick.suspect} and ${coachPick.weapon} in the ${room}.`,
            { byPlayerId: pl.id }
          );
        }
      }
    }

    const sus = SUSPECTS.map(s =>
      `<option value="${s}" ${(coachPick && coachPick.suspect===s) ? 'selected' : ''}>${displaySuspect(s)}</option>`
    ).join("");

    const wep = WEAPONS.map(w =>
      `<option value="${w}" ${(coachPick && coachPick.weapon===w) ? 'selected' : ''}>${w}</option>`
    ).join("");
    const html=`<div><b>Room:</b> ${room}</div>
      <div style="margin-top:10px;" class="row">
        <label>Suspect: <select id="selSuspect">${sus}</select></label>
        <label>Weapon: <select id="selWeapon">${wep}</select></label>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px;">Pick a suspect and weapon to make a suggestion.</div>`;
    const go=await renderPrompt({title:'Make a Suggestion',bodyHTML:html,actions:[{label:'Suggest',value:true}]});
    const suspect=document.getElementById('selSuspect')?.value;
    const weapon=document.getElementById('selWeapon')?.value;
    clearGameplayPrompt();
    if(go&&suspect&&weapon){
      const result = await this.makeSuggestion(pl,suspect,weapon,room);

      // Coach mode: after suggestion resolves (refuted or not), if threshold met then auto-open accusation prompt
      if(this.isCoachFocus(pl)){
        const acc = this.coachAccusationPlan(pl);
        if(acc){
          this.obs(`ğŸ›‘ Coach's choice: ACCUSE ${acc.suspect} / ${acc.weapon} / ${acc.room}`, { byPlayerId: pl.id });

          await this.humanAccuse({
            prefill: acc,
            onCancel: () => this.showPostSuggestionPrompt(result,{suspect,weapon,room})
          });

          // If the accusation ended the game, stop here
          if(this.gameOver) return;
        }
      }

      await this.showPostSuggestionPrompt(result,{suspect,weapon,room});
    }else{
      await this.endTurn();
    }
  }

  async showPostSuggestionPrompt(result,triple){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || this.gameOver) return;
    const title=result.refuted?'Suggestion Result':'No One Could Refute!';
    const body=result.refuted
      ?`<div>Your suggestion has been <b>refuted</b>.</div><div style="margin-top:8px;color:var(--muted);font-size:12px;">What would you like to do next?</div>`
      :`<div><b>No one</b> could refute your suggestion:</div>
        <div style="margin-top:8px;"><b>${displaySuspect(triple.suspect)}</b> in the <b>${triple.room}</b> with the <b>${triple.weapon}</b>.</div>
        <div style="margin-top:8px;color:var(--muted);font-size:12px;">What would you like to do next?</div>`;
    const pick=await renderPrompt({title,bodyHTML:body,actions:[
      {label:'End Turn',value:'end',className:'secondary'},
      {label:'Make Accusation',value:'accuse',className:'danger'}
    ]});
    clearGameplayPrompt();
    if(pick==='accuse'){ await this.humanAccuse({onCancel:()=>this.showPostSuggestionPrompt(result,triple)}); }
    else await this.endTurn();
  }

  async humanAccuse({onCancel, prefill=null}={}){
    const pl=this.currentPlayer(); if(!(pl.isHuman || this.isCoachFocus(pl)) || pl.eliminated || this.gameOver) return;
    if(this.awaitingMove) return;
    const sus = SUSPECTS.map(s =>
      `<option value="${s}" ${(prefill && prefill.suspect===s) ? 'selected' : ''}>${displaySuspect(s)}</option>`
    ).join("");

    const wep = WEAPONS.map(w =>
      `<option value="${w}" ${(prefill && prefill.weapon===w) ? 'selected' : ''}>${w}</option>`
    ).join("");

    const rms = ROOMS.map(r =>
      `<option value="${r}" ${(prefill && prefill.room===r) ? 'selected' : ''}>${r}</option>`
    ).join("");
    const html=`<div style="color:var(--warn)"><b>Warning:</b> If you are wrong, you will be eliminated from taking turns.</div>
      <div style="margin-top:10px;" class="row">
        <label>Suspect: <select id="accSus">${sus}</select></label>
        <label>Weapon: <select id="accWeap">${wep}</select></label>
        <label>Room: <select id="accRoom">${rms}</select></label>
      </div>`;
    const go=await renderPrompt({title:'Make an Accusation',bodyHTML:html,actions:[
      {label:'Cancel',value:false,className:'secondary'},
      {label:'Accuse',value:true,className:'danger'}
    ]});
    const acc={suspect:document.getElementById('accSus')?.value,weapon:document.getElementById('accWeap')?.value,room:document.getElementById('accRoom')?.value};
    clearGameplayPrompt();
    if(go&&acc.suspect&&acc.weapon&&acc.room){
      await this.accuse(pl,acc);
      if(!this.gameOver) await this.endTurn();
    }else{
      if(this.gameOver) return;
      if(typeof onCancel==='function'){ await onCancel(); return; }
      if(this.awaitingMove){
        setPromptMessage('Choose a Room',`<div>Click <b>Move</b> on a highlighted room.</div>`);
      }else{
        await this.showRollPromptForHuman();
      }
    }
  }

  roomsOptionsHTML(){ return ROOMS.map(r => `<option value="${r}">${r}</option>`).join(""); }

  async endTurn(){
    if(this.gameOver) return;
    this.turnIndex=this.nextTurnIndex(this.turnIndex);
    this.updateTurnUI();
    await this.beginTurn();
  }

/* ================================================================================
 * [SECTION 5] AI LOGIC
 * ================================================================================
 * AI difficulty levels, move selection, suggestions, and accusation decisions
 * ================================================================================ */

  async aiTurn(pl){
    const sid=this.sessionId;
    if(this.gameOver) return;

    const summary=[];
    log(`${pl.name}'s turnâ€¦`);
    summary.push('Turn started.');
    await sleep(650);
    if(!this.isActiveSession(sid)) return;

    let choseStay=false;

    // Stay vs Roll decision (Sherlock a bit more intentional)
    if (pl.arrivedByOpponentSuggestion) {
      const roomCleared=pl.isCleared('Room',pl.location);
      const roomsLeft=pl.possibleSet('Room');
      if(roomCleared){
        choseStay=false;
      }else if(isSherlock(this.aiDifficulty)){
        const isKeyRoom=roomsLeft.includes(pl.location);
        choseStay=isKeyRoom?(Math.random()<0.72):(Math.random()<0.28);
      }else if(isAdvancedAI(this.aiDifficulty)){
        const isKeyRoom=roomsLeft.includes(pl.location);
        choseStay=isKeyRoom?(Math.random()<0.65):(Math.random()<0.35);
      }else{
        choseStay=(Math.random()<0.45);
      }
      summary.push(choseStay?`Chose to STAY in ${pl.location} (no roll).`:`Chose to ROLL (was eligible to stay).`);
      pl.arrivedByOpponentSuggestion=false;
      await sleep(450);
      if(!this.isActiveSession(sid)) return;
    }

    if(!choseStay){
      // Roll and compute reachables
      this.dice = randInt(1,6);
      this.reachable = this.computeReachable(pl.location, this.dice);
      log(`${pl.name} rolled ${this.dice}.`);
      summary.push(`Rolled a ${this.dice}.`);
      await sleep(650);
      if(!this.isActiveSession(sid)) return;

      const reach=[...this.reachable];
      const possibleRooms=new Set(pl.possibleSet('Room'));

      const candidates=reach.filter(r=>possibleRooms.has(r));
      const nextTurnPotential=(fromRoom)=>{
        const seen=new Set();
        for(let d=1;d<=6;d++){
          const arr=(ROOM_DICE[fromRoom]&&ROOM_DICE[fromRoom][d])?ROOM_DICE[fromRoom][d]:[];
          for(const r of arr) if(possibleRooms.has(r)) seen.add(r);
        }
        return seen.size;
      };
      const pickBest=(arr)=>{
        if(!arr.length) return null;
        let best=[],bestScore=-1;
        for(const r of arr){
          const s=nextTurnPotential(r);
          if(s>bestScore){best=[r];bestScore=s;}
          else if(s===bestScore){best.push(r);}
        }
        return choice(best);
      };

      let dest=candidates.length?pickBest(candidates):pickBest(reach);

      // Sherlock â€œsecond-bestâ€ flavor: compute after base dest, before moving
      if(isSherlock(this.aiDifficulty)){
        if(Math.random()<0.12){
          const scored = reach.map(r=>({ r, s:(possibleRooms.has(r)?2:0)+Math.random()*0.5 }))
                              .sort((a,b)=>b.s-a.s);
          if(scored.length>1) dest=scored[1].r;
        }
      }

      // Defensive fallback
      if(!dest) dest=pl.location;

      const from=pl.location;
      pl.location=dest;
      if(pl.suspect) this.suspectLoc.set(pl.suspect, dest);

      log(`${pl.name} moved from ${from} to ${dest}.`);
      summary.push(`Moved from ${from} to ${dest}.`);
      renderAll(this);
      await sleep(650);
      if(!this.isActiveSession(sid)) return;
    } else {
      // Chose to stay
      this.dice=null; this.reachable=new Set();
      renderAll(this);
    }

    // Sherlock++: suggestion target selection + thought process logging
    let suspect, weapon;
    const room = pl.location;

    if (isSherlock(this.aiDifficulty)) {
      // Compute top entropy candidates (informative picks)
      const rankEntropy = (type, list) => {
        const arr = list.map(n => ({
          n,
          e: pl.entropyForCardKey(pl.cardKey(type, n))
        }));
        arr.sort((a,b)=>b.e-a.e);
        return arr.slice(0,3);
      };

      const susPool = pl.possibleSet('Suspect');
      const wepPool = pl.possibleSet('Weapon');

      const susCands = susPool.length ? susPool : SUSPECTS;
      const wepCands = wepPool.length ? wepPool : WEAPONS;

      const topSus = rankEntropy('Suspect', susCands);
      const topWep = rankEntropy('Weapon',  wepCands);

      const pick = pl.pickSmartSuggestionParts();
      suspect = pick.suspect;
      weapon  = pick.weapon;

      if(this.observerMode){
        this.obs(`ğŸ” Let's see... top suspects are ${topSus.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')} and top weapons are ${topWep.map(x=>`${x.n}(${x.e.toFixed(2)})`).join(', ')}. I'll check out ${suspect} and ${weapon} in the ${room}.`, { byPlayerId: pl.id });
      }

    } else {
      // Smart/basic: pick from remaining (uncleared) candidates
      const sC = pl.possibleSet('Suspect');
      const wC = pl.possibleSet('Weapon');

      const susCands = sC.length ? sC : SUSPECTS;
      const wepCands = wC.length ? wC : WEAPONS;

      suspect = choice(susCands);
      weapon  = choice(wepCands);

      if(this.observerMode && this.aiDifficulty==='smart'){
        this.obs(`ğŸ” Let's see... suspects remaining are ${susCands.length} and weapons remaining are ${wepCands.length}. I'll check out ${suspect} and ${weapon} in the ${room}.`, { byPlayerId: pl.id });
      }
    }

    summary.push(`Suggested: ${displaySuspect(suspect)} in the ${room} with the ${weapon}.`);
    const result=await this.makeSuggestion(pl,suspect,weapon,room);
    if(!this.isActiveSession(sid)) return;
    summary.push(result.refuted?`Refuted by ${result.by?.isHuman ? 'You' : (result.by?.name ?? 'another player')}.`:'No one could refute the suggestion.');

    // Sherlock++: beliefs decay each AI turn
    if (isSherlock(this.aiDifficulty)) pl.decayBeliefs();

    // === Accusation logic ===
    let accused=false;
    let accOutcome=null; // used to revert NOT GUILTY display after summary (AI only)    

    // A) Certain accusation (all difficulties)
    if(!pl.eliminated && pl.isConfidentSolution()){
      await sleep(650);
      if(!this.isActiveSession(sid)) return;
      const acc=pl.inferredAccusation();

      if(this.observerMode){
        this.obs(`ğŸ›‘ Time to act! Accusing ${acc.suspect} with the ${acc.weapon} in the ${acc.room}.`, { byPlayerId: pl.id });
      }

      summary.push(`Accused (certain): ${displaySuspect(acc.suspect)} in the ${acc.room} with the ${acc.weapon}.`);
      accOutcome = await this.accuse(pl,acc);
      accused=true;
      if(accOutcome && accOutcome.correct===false){
        summary.push('Verdict: ğŸ•Š NOT GUILTY (eliminated).');
      }
    }
    // B) Sherlock++: belief-aware early accusation (bold, sometimes wrong)
    else if(!pl.eliminated && isSherlock(this.aiDifficulty)){
      const plan = pl.planAccusationWithBeliefs();
      if(this.observerMode && plan){
        this.obs(`â“ Do I have enough evidence? Was it ${plan.acc.suspect} with the ${plan.acc.weapon} in the ${plan.acc.room}? I'll only accuse if the evidence holds.`, { byPlayerId: pl.id });
      }

      const hasEvidence = (pl.seen.size > pl.own.size) || pl.constraints.length > 0 || pl.unrefuted.length > 0;
      if (hasEvidence && plan && plan.confidence >= AI_CFG.sherlock.earlyAccuseMinConfidence) {
        if (Math.random() < AI_CFG.sherlock.earlyAccuseChance) {
          await sleep(650);
          if(!this.isActiveSession(sid)) return;
          summary.push(`Accused (early, conf=${plan.confidence.toFixed(2)}): ${displaySuspect(plan.acc.suspect)} in the ${plan.acc.room} with the ${plan.acc.weapon}.`);
          accOutcome = await this.accuse(pl, plan.acc);
          accused = true;
          if(accOutcome && accOutcome.correct===false){
            summary.push('Verdict: ğŸ•Š NOT GUILTY (eliminated).');
          }
        }
      } else if (hasEvidence && Math.random() < AI_CFG.sherlock.mistakeRate) {
        // Rare outright mistake to feel human
        await sleep(650);
        if(!this.isActiveSession(sid)) return;
        const b = pl.planAccusationWithBeliefs();
        summary.push(`Accused (mistake): ${displaySuspect(b.acc.suspect)} in the ${b.acc.room} with the ${b.acc.weapon}.`);
        accOutcome = await this.accuse(pl, b.acc);
        accused = true;
        if(accOutcome && accOutcome.correct===false){
          summary.push('Verdict: ğŸ•Š NOT GUILTY (eliminated).');
        }
      }
    }

    if (accused) {
      if (!this.isActiveSession(sid)) return;
      if (this.gameOver) return;
    }

    summary.push('Turn ended.');
    await this.showOpponentTurnSummary(pl,summary);
    // If AI made a wrong accusation, revert the centre display AFTER the summary is dismissed
    if(accOutcome && accOutcome.revertAfterSummary){
      this.restoreTrial();
      renderAll(this);
    }

    if(!this.isActiveSession(sid)) return;
    await this.endTurn();
  }

  async showOpponentTurnSummary(player,lines){
    const pretty=lines.map(l=>`â€¢ ${l}`).join('\n');
    const html=`<div style="margin-bottom:8px;"><b>${player.name}</b> finished their turn.</div>
      <div style="color:var(--muted);font-size:12px;margin-bottom:10px;">Click OK to continue.</div>
      <div style="background:rgba(0,0,0,0.18);border:1px solid var(--border);border-radius:12px;padding:10px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;line-height:1.35;white-space:pre-wrap;">${pretty}</div>`;
    await showInfoPrompt('Opponent Turn Summary',html);
  }
}

/* Rendering */
const HOLDING_CELL_ID='HoldingCell';
const BOARD_LAYOUT={
  'Study':{col:[1,5],row:[1,3]},
  'Library':{col:[1,5],row:[3,5]},
  'Billiard Room':{col:[1,5],row:[5,7]},
  'Conservatory':{col:[1,5],row:[7,9]},
  'Hall':{col:[5,9],row:[1,4]},
  'Ballroom':{col:[5,9],row:[6,9]},
  'Lounge':{col:[9,13],row:[1,4]},
  'Dining Room':{col:[9,13],row:[4,7]},
  'Kitchen':{col:[9,13],row:[7,9]}
};
const CENTER_CELL={col:[5,9],row:[4,6]};

/* ================================================================================
 * [SECTION 8] UI RENDERING - PLAYERS & CARDS
 * ================================================================================
 * Display player information, hands, and card visuals
 * ================================================================================ */

function renderPlayers(game){
  const box=el('playersBox');box.innerHTML='';
  game.players.forEach((p,idx)=>{
    const div=document.createElement('div');
    div.style.display='flex';div.style.justifyContent='space-between';
    div.style.alignItems='center';div.style.padding='6px 0';
    div.style.borderBottom='1px solid rgba(255,255,255,.06)';
    const left=document.createElement('div');
    let label;
    if(game.observerMode && p.id===game.observerFocusId) label = `Coach Focus (${p.name})`;
    else label = p.isHuman ? `You (${p.name})` : p.name;
    left.innerHTML =
      '<b>' + label + '</b> ' +
      '<span style="color:var(--muted);font-size:12px;">@ ' + p.location + '</span>' +
      (game.aiDifficulty === 'sherlock'
        ? ' <span style="color:var(--muted);font-size:12px;margin-left:8px;">Cards: ' + (p.hand ? p.hand.length : 0) + '</span>'
        : '') +
      (p.eliminated ? '<span class="pill bad" style="margin-left:6px;">eliminated</span>' : '');
    const right=document.createElement('div');
    const isTurn=idx===game.turnIndex && !game.gameOver;
    right.innerHTML=isTurn?`<span class="pill good">active</span>`:`<span class="pill">â€”</span>`;
    div.appendChild(left);div.appendChild(right);box.appendChild(div);
  });
}

function renderHand(game){
  const you=game.players[0];
  const box=el('handBox');box.innerHTML='';
  const sorted=[...you.hand].sort((a,b)=>a.type.localeCompare(b.type)||a.name.localeCompare(b.name));
  sorted.forEach(c=>{
    const badge=document.createElement('div');
    badge.className='pill good';badge.style.display='inline-block';badge.style.margin='4px 6px 0 0';
    badge.textContent=`${c.type}: ${displayCardName(c.type,c.name)}`;
    box.appendChild(badge);
  });
  if(!sorted.length) box.innerHTML=`<span class="pill">(no cards?)</span>`;
}

/* ================================================================================
 * [SECTION 9] UI RENDERING - NOTEBOOK
 * ================================================================================
 * Checklist rendering, note-taking interface, and probability displays
 * ================================================================================ */

function renderNotebook(game){
  // Get player initials for column headers
  const playerInitials = game.players.map(p => {
    if(p.isHuman && !game.observerMode) return 'Own';
    // Get initials from suspect name
    const suspect = p.suspect || p.name;
    const words = suspect.split(' ');
    if(words.length > 1) return words.map(w => w[0]).join('');
    return suspect.substring(0, 2).toUpperCase();
  });

  // Icons
  const SUS_ICON = {
    "Green": "ğŸ©","Mustard": "ğŸ–ï¸","Scarlet": "ğŸ’‹","Peacock": "ğŸ’","Plum": "ğŸ’¼","White": "ğŸ‘œ"
  };
  const WEP_ICON = {
    "Candlestick":"ğŸ•¯ï¸","Dagger":"ğŸ—¡ï¸","Lead Pipe":"ğŸ¦¯","Revolver":"ğŸ”«","Rope":"ğŸª¢","Wrench":"ğŸ”§"
  };
  const ROOM_ICON = {
    "Study": "ğŸ“","Hall":"ğŸ§¥","Lounge":"ğŸ›‹ï¸","Library":"ğŸ“–","Billiard Room":"ğŸ±",
    "Dining Room":"ğŸ½ï¸","Conservatory":"ğŸª´","Ballroom":"ğŸ’ƒ","Kitchen":"ğŸ¥©"
  };

  // Load saved grid state
  const gridState = loadClueGrid();
  const gridNotes = loadClueGridNotes();

  const renderGrid = (containerId, sectionTitle, cardList, cardType, iconMap) => {
    const container = el(containerId);
    if(!container) return;

    let html = `<table class="clueGrid"><thead><tr>`;
    html += `<th style="text-align:left; min-width:100px;">Card</th>`;
    
    // Player columns
    playerInitials.forEach((initial, idx) => {
      html += `<th title="${game.players[idx].name}">${initial}</th>`;
    });
    
    // Classified Files column
    html += `<th title="Classified Files (Solution)">CF</th>`;
    html += `</tr></thead><tbody>`;

    // Section header row
    html += `<tr><td colspan="${playerInitials.length + 2}" class="sectionHeader">${sectionTitle}</td></tr>`;

    // Card rows
    cardList.forEach(cardName => {
      const key = `${cardType}:${cardName}`;
      const icon = iconMap[cardName] || '';
      const displayName = displayCardName(cardType, cardName);
      
      // Main row with checkboxes
      html += `<tr>`;
      html += `<td class="cardName"><span class="ico">${icon}</span>${displayName}</td>`;
      
      // Player columns
      playerInitials.forEach((initial, pIdx) => {
        const cellKey = `${key}|P${pIdx}`;
        const value = gridState[cellKey] || '';
        html += `<td><select data-key="${cellKey}" data-type="player">
          <option value="">${value === '' ? 'ã€€' : ''}</option>
          <option value="âœ“" ${value === 'âœ“' ? 'selected' : ''}>âœ“</option>
          <option value="âœ—" ${value === 'âœ—' ? 'selected' : ''}>âœ—</option>
          <option value="?" ${value === '?' ? 'selected' : ''}>?</option>
        </select></td>`;
      });
      
      // CF column - different options
      const cfKey = `${key}|CF`;
      const cfValue = gridState[cfKey] || '';
      html += `<td><select data-key="${cfKey}" data-type="cf">
        <option value="">${cfValue === '' ? 'ã€€' : ''}</option>
        <option value="?" ${cfValue === '?' ? 'selected' : ''}>?</option>
        <option value="!" ${cfValue === '!' ? 'selected' : ''}>!</option>
      </select></td>`;
      
      html += `</tr>`;

      // Notes row (spans all columns)
      const noteKey = `${key}|note`;
      const noteValue = gridNotes[noteKey] || '';
      html += `<tr><td colspan="${playerInitials.length + 2}" class="notesRow">`;
      html += `<input type="text" class="noteInput" data-notekey="${noteKey}" 
               value="${noteValue}" placeholder="Notes...">`;
      html += `</td></tr>`;
    });

    html += `</tbody></table>`;
    container.innerHTML = html;

    // Add change listeners for checkboxes
    container.querySelectorAll('select').forEach(select => {
      select.addEventListener('change', (e) => {
        const key = e.target.dataset.key;
        const value = e.target.value;
        const state = loadClueGrid();
        if(value === '') delete state[key];
        else state[key] = value;
        saveClueGrid(state);
      });
    });

    // Add change listeners for notes
    container.querySelectorAll('.noteInput').forEach(input => {
      input.addEventListener('input', (e) => {
        const noteKey = e.target.dataset.notekey;
        const value = e.target.value;
        const notes = loadClueGridNotes();
        if(value === '') delete notes[noteKey];
        else notes[noteKey] = value;
        saveClueGridNotes(notes);
      });
    });
  };

  renderGrid('noteSuspects', 'SUSPECTS', SUSPECTS, 'Suspect', SUS_ICON);
  renderGrid('noteWeapons', 'WEAPONS', WEAPONS, 'Weapon', WEP_ICON);
  renderGrid('noteRooms', 'ROOMS', ROOMS, 'Room', ROOM_ICON);
}

// Grid state persistence
function loadClueGrid(){
  try{
    const s = localStorage.getItem('clueGrid');
    return s ? JSON.parse(s) : {};
  }catch(e){
    return {};
  }
}

function saveClueGrid(state){
  try{
    localStorage.setItem('clueGrid', JSON.stringify(state));
  }catch(e){
    console.warn('Could not save grid state:', e);
  }
}

function loadClueGridNotes(){
  try{
    const s = localStorage.getItem('clueGridNotes');
    return s ? JSON.parse(s) : {};
  }catch(e){
    return {};
  }
}

function saveClueGridNotes(notes){
  try{
    localStorage.setItem('clueGridNotes', JSON.stringify(notes));
  }catch(e){
    console.warn('Could not save grid notes:', e);
  }
}

function clearClueGrid(){
  try{
    localStorage.removeItem('clueGrid');
    localStorage.removeItem('clueGridNotes');
  }catch(e){}
}

function renderObserverCasebook(game){
  const focus = game.players[game.observerFocusId];
  
  // Replace panel header
  const rightPanel = document.querySelector('.rightPanel h2');
  if(rightPanel) rightPanel.textContent = 'Coach Casebook';

  // Get player initials for column headers
  const playerInitials = game.players.map((p, idx) => {
    if(idx === game.observerFocusId) return 'Own'; // Focus player is "Own"
    const suspect = p.suspect || p.name;
    const words = suspect.split(' ');
    if(words.length > 1) return words.map(w => w[0]).join('');
    return suspect.substring(0, 2).toUpperCase();
  });

  // Icons
  const SUS_ICON = {
    "Green": "ğŸ©","Mustard": "ğŸ–ï¸","Scarlet": "ğŸ’‹","Peacock": "ğŸ’","Plum": "ğŸ’¼","White": "ğŸ‘œ"
  };
  const WEP_ICON = {
    "Candlestick":"ğŸ•¯ï¸","Dagger":"ğŸ—¡ï¸","Lead Pipe":"ğŸ¦¯","Revolver":"ğŸ”«","Rope":"ğŸª¢","Wrench":"ğŸ”§"
  };
  const ROOM_ICON = {
    "Study": "ğŸ“","Hall":"ğŸ§¥","Lounge":"ğŸ›‹ï¸","Library":"ğŸ“–","Billiard Room":"ğŸ±",
    "Dining Room":"ğŸ½ï¸","Conservatory":"ğŸª´","Ballroom":"ğŸ’ƒ","Kitchen":"ğŸ¥©"
  };

  const playersById = new Map(game.players.map(p=>[p.id,p.name]));

  // Helper to get card info for each player column and CF column
  const getCardInfo = (type, name) => {
    const key = focus.cardKey(type,name);
    const playerMarks = new Array(game.players.length).fill('');
    let cfMark = '';
    let noteText = '';
    let hasProb = false;
    let prob = 0;

    // Get metadata once for this card
    const ownerId = focus.knownOwners.get(key);
    const meta = focus.knowledgeMeta.get(key);

    // Check each player to see if they own this card
    game.players.forEach((player, pIdx) => {
      if(player.id === focus.id && focus.own.has(key)) {
        // Focus player owns it
        playerMarks[pIdx] = 'âœ“';
        if(noteText === '') noteText = 'own';
      } else if(ownerId === player.id) {
        // Focus knows this player owns it
        playerMarks[pIdx] = 'âœ“';
        if(meta?.status === 'seen') {
          if(noteText === '') noteText = 'seen';
        } else if(meta?.status === 'deduced' && game.aiDifficulty !== 'basic') {
          // Only show "deduced" in Smart/Sherlock modes
          if(noteText === '') noteText = 'deduced';
        } else {
          if(noteText === '') noteText = 'seen';
        }
      }
    });

    // Check if card is in classified files (guaranteed guilty)
    if(meta?.status === 'eliminated') {
      cfMark = '!';
      noteText = 'guaranteed guilty';
    } else if(focus.seen.has(key) && !focus.knownOwners.has(key)) {
      // Ruled out but not assigned to anyone = must be in CF
      cfMark = '!';
      noteText = 'guaranteed guilty';
    }

    // Sherlock mode: show probability for unsolved cards
    if(game.aiDifficulty === 'sherlock' && noteText === '') {
      // No status yet - show probability
      hasProb = true;
      prob = getSolutionProb(type, name);
    }

    return { playerMarks, cfMark, noteText, hasProb, prob };
  };

  // Get Sherlock probability
  const getSolutionProb = (type, name) => {
    const key = focus.cardKey(type,name);
    if(focus.seen.has(key)) return 0;
    
    if(typeof focus.caseFileProbNormalized === 'function'){
      return focus.caseFileProbNormalized(type, name);
    }
    
    const w = focus.ownerWeights?.get(key);
    if(!w) return 0.0;
    const pCase = w.get(CASE_FILE_ID) ?? 0;
    return Math.max(0, Math.min(1, pCase));
  };

  const renderGrid = (containerId, sectionTitle, cardList, cardType, iconMap) => {
    const container = el(containerId);
    if(!container) return;

    let html = `<table class="clueGrid"><thead><tr>`;
    html += `<th style="text-align:left; min-width:100px;">Card</th>`;
    
    // Player columns
    playerInitials.forEach((initial, idx) => {
      html += `<th title="${game.players[idx].name}">${initial}</th>`;
    });
    
    // Classified Files column
    html += `<th title="Classified Files (Solution)">CF</th>`;
    html += `</tr></thead><tbody>`;

    // Section header row
    html += `<tr><td colspan="${playerInitials.length + 2}" class="sectionHeader">${sectionTitle}</td></tr>`;

    // Card rows
    cardList.forEach(cardName => {
      const key = `${cardType}:${cardName}`;
      const icon = iconMap[cardName] || '';
      const displayName = displayCardName(cardType, cardName);
      const cardInfo = getCardInfo(cardType, cardName);
      
      // Main row with checkmarks (read-only in coach mode)
      html += `<tr>`;
      html += `<td class="cardName"><span class="ico">${icon}</span>${displayName}</td>`;
      
      // Player columns - show marks where applicable
      cardInfo.playerMarks.forEach((mark) => {
        html += `<td style="font-size:16px;">${mark || 'ã€€'}</td>`;
      });
      
      // CF column
      html += `<td style="font-size:16px;">${cardInfo.cfMark || 'ã€€'}</td>`;
      
      html += `</tr>`;

      // Notes row - auto-populated based on difficulty
      html += `<tr><td colspan="${playerInitials.length + 2}" class="notesRow">`;
      
      if(cardInfo.hasProb && cardInfo.prob !== undefined) {
        // Sherlock mode: show probability bar for unsolved cards
        const pct = Math.round(cardInfo.prob * 100);
        html += `<div class="probWrap" style="position:relative; margin:2px 0;">
          <div class="probBar" style="width:${pct}%;"></div>
          <span class="probPct" style="position:absolute; right:4px; top:-18px;">${pct}%</span>
        </div>`;
      } else {
        // Show status text
        html += `<div class="noteDisplay">${cardInfo.noteText || 'ã€€'}</div>`;
      }
      
      html += `</td></tr>`;
    });

    html += `</tbody></table>`;
    container.innerHTML = html;
  };

  renderGrid('noteSuspects', 'SUSPECTS', SUSPECTS, 'Suspect', SUS_ICON);
  renderGrid('noteWeapons', 'WEAPONS', WEAPONS, 'Weapon', WEP_ICON);
  renderGrid('noteRooms', 'ROOMS', ROOMS, 'Room', ROOM_ICON);

  // Manage deduction log visibility
  const logId = 'observerDeduceLog';
  let logBox = document.getElementById(logId);
  
  // Show deduction log for Smart and Sherlock, hide for Basic
  const showLog = (game.aiDifficulty === 'smart' || game.aiDifficulty === 'sherlock');
  
  if(showLog){
    // Create log if it doesn't exist
    if(!logBox){
      const parent = document.getElementById('noteRooms')?.parentElement;
      if(parent){
        logBox = document.createElement('div');
        logBox.id = logId;
        logBox.className = 'log';
        logBox.style.marginTop = '12px';
        logBox.style.height = '150px';
        parent.appendChild(logBox);
      }
    }
    // Populate it
    if(logBox && game.obsLog){
      logBox.textContent = game.obsLog.join('\n');
      logBox.scrollTop = logBox.scrollHeight;
    }
  } else {
    // Hide/remove log for basic mode
    if(logBox) logBox.remove();
  }
}

function renderBoard(game){
  const board=el('board');board.innerHTML='';
  const placeBox=(div,pos)=>{div.style.gridColumn=`${pos.col[0]} / ${pos.col[1]}`;div.style.gridRow=`${pos.row[0]} / ${pos.row[1]}`;};
  const activeSuspects=new Set(game.players.map(p=>p.suspect).filter(Boolean));
  const current=game.currentPlayer();
  const roomNames=['Study','Library','Billiard Room','Conservatory','Hall','Ballroom','Lounge','Dining Room','Kitchen'];

  roomNames.forEach(roomName=>{
    const div=document.createElement('div');
    div.className='room';
    const pos=BOARD_LAYOUT[roomName];
    if(pos) placeBox(div,pos);
    const here=current.isHuman && current.location===roomName;
    const reachable=current.isHuman && game.awaitingMove && game.reachable.has(roomName);
    if(here) div.classList.add('here');
    if(reachable) div.classList.add('reachable');

    const SUSPECT_ICON = {"Green":"ğŸ©","Mustard":"ğŸ–ï¸","Scarlet":"ğŸ’‹","Peacock":"ğŸ’","Plum":"ğŸ’¼","White":"ğŸ‘œ"};
    const suspectTokens = SUSPECTS
      .filter(s => (game.suspectLoc.get(s) || 'Hall') === roomName)
      .map(s => {
        const inactive = !activeSuspects.has(s);
        const cls = `token suspect ${slug(s)}${inactive ? ' inactive' : ''}`;
        const icon = SUSPECT_ICON[s] || "";
        const label = displaySuspect(s);
        return `<span class="${cls}" data-color="1" title="${label}">
                  <span class="ico" aria-hidden="true">${icon}</span>${label}
                </span>`;
      });

    const WEAPON_ICON = {"Candlestick":"ğŸ•¯ï¸","Dagger":"ğŸ—¡ï¸","Lead Pipe":"ğŸ¦¯","Revolver":"ğŸ”«","Rope":"ğŸª¢","Wrench":"ğŸ”§"};
    const weaponTokens = WEAPONS
      .filter(w => (game.weaponLoc.get(w) || '') === roomName)
      .map(w => {
        const cls = `token weapon ${slug(w)}`;
        const icon = WEAPON_ICON[w] || "";
        return `<span class="${cls}" data-color="1" title="${w}">
                  <span class="ico" aria-hidden="true">${icon}</span>${w}
                </span>`;
      });

    const tokensHTML=[...suspectTokens,...weaponTokens].join('')||`<span class="token" style="opacity:.6;">(empty)</span>`;
    const roomIcon = ROOM_ICON[roomName] || "";
    div.innerHTML = `<div class="title"><span class="ico" aria-hidden="true">${roomIcon}</span>${roomName}</div>
                     <div class="tokens">${tokensHTML}</div>`;
    if(current.isHuman && game.awaitingMove && reachable){
      const btn=document.createElement('button');btn.textContent='Move';
      btn.setAttribute('aria-label',`Move to ${roomName}`);btn.tabIndex=0;
      btn.onclick=()=>game.humanMoveTo(roomName);
      btn.onkeydown=(e)=>{if(e.key==='Enter'||e.key===' ') btn.click();};
      div.appendChild(btn);
    }
    board.appendChild(div);
  });

  const center=document.createElement('div');center.className='room center';placeBox(center,CENTER_CELL);

  const makeRoomToken = (roomName) => {
    if(!roomName) return '';
    const icon = ROOM_ICON[roomName] || 'ğŸ·ï¸';
    // Render like other tokens to keep consistent sizing
    return `<span class="token roomtok" data-color="1" title="${roomName}"
                  style="--token-color: rgba(248,250,252,.85);">
              <span class="ico" aria-hidden="true">${icon}</span>${roomName}
            </span>`;
  };

  // Default centre tile
  let centerTitle = `<span class="ico" aria-hidden="true">${ROOM_ICON["Classified Files"] || "ğŸ•µï¸â€â™‚ï¸"}</span>CLASSIFIED FILES`;
  let centerBody  = `<span class="token" style="opacity:.6;">(sealed)</span>`;

  // Determine centre state:
  // 1) Trial states (ACCUSED / NOT GUILTY)
  // 2) Game over (CONVICTED)
  if(game.trial && (game.trial.stage==='accused' || game.trial.stage==='notguilty')){
    const st = game.trial.stage;
    const { acc, by } = game.trial;

    if(st==='accused'){
      center.classList.add('accused');
      centerTitle = `<span class="ico" aria-hidden="true">ğŸ‘¨â€âš–ï¸</span>ACCUSED`;
      centerBody = `<div style="margin-top:6px;font-size:12px;color:var(--muted)">
        ${by ? `<div><b>By:</b> ${by}</div>` : ''}
        <div><b>Suspect:</b> ${displaySuspect(acc.suspect)}</div>
        <div><b>Weapon:</b> ${acc.weapon}</div>
        <div><b>Room:</b> ${acc.room}</div>
      </div>`;
    } else {
      center.classList.add('notguilty');
      centerTitle = `<span class="ico" aria-hidden="true">ğŸ•Š</span>NOT GUILTY`;
      centerBody = `<div style="margin-top:6px;font-size:12px;color:var(--muted)">
        ${by ? `<div><b>By:</b> ${by}</div>` : ''}
        <div><b>Suspect:</b> ${displaySuspect(acc.suspect)}</div>
        <div><b>Weapon:</b> ${acc.weapon}</div>
        <div><b>Room:</b> ${acc.room}</div>
      </div>`;
    }
  }
  else if (game.gameOver && game.convicted) {
    const { suspect, weapon, room, winner } = game.convicted;
    center.classList.add('convicted');
    centerTitle = `<span class="ico" aria-hidden="true">ğŸ‘®â€â™‚ï¸</span>CONVICTED`;
    centerBody = `<div style="margin-top:6px;font-size:12px;color:var(--muted)">
      ${winner ? `<div><b>By:</b> ${winner}</div>` : ''}
      <div><b>Suspect:</b> ${displaySuspect(suspect)}</div>
      <div><b>Weapon:</b> ${weapon}</div>
      <div><b>Room:</b> ${room}</div>
    </div>`;
  }

  // Tokens currently held in centre (suspect + weapon moved via HOLDING_CELL_ID)
  // Render using the SAME icon style as room tiles (no dots)

  const SUSPECT_ICON = {
    "Green":"ğŸ©","Mustard":"ğŸ–ï¸","Scarlet":"ğŸ’‹",
    "Peacock":"ğŸ’","Plum":"ğŸ’¼","White":"ğŸ‘œ"
  };

  const WEAPON_ICON = {
    "Candlestick":"ğŸ•¯ï¸","Dagger":"ğŸ—¡ï¸","Lead Pipe":"ğŸ¦¯",
    "Revolver":"ğŸ”«","Rope":"ğŸª¢","Wrench":"ğŸ”§"
  };

  const holdingSus = SUSPECTS
    .filter(s => game.suspectLoc.get(s) === HOLDING_CELL_ID)
    .map(s => `
      <span class="token suspect ${slug(s)}" data-color="1" title="${displaySuspect(s)}">
        <span class="ico" aria-hidden="true">${SUSPECT_ICON[s] || ""}</span>${displaySuspect(s)}
      </span>
    `);

  const holdingWep = WEAPONS
    .filter(w => game.weaponLoc.get(w) === HOLDING_CELL_ID)
    .map(w => `
      <span class="token weapon ${slug(w)}" data-color="1" title="${w}">
        <span class="ico" aria-hidden="true">${WEAPON_ICON[w] || ""}</span>${w}
      </span>
    `);

  // Room token for trial or convicted state
  let roomToken = '';
  if(game.trial && game.trial.acc) roomToken = makeRoomToken(game.trial.acc.room);
  else if(game.gameOver && game.convicted) roomToken = makeRoomToken(game.convicted.room);

  const centerTokens=[...holdingSus,...holdingWep, roomToken].filter(Boolean).join('');

  center.innerHTML=`<div class="title">${centerTitle}</div><div class="tokens">${centerTokens||centerBody}</div>`;
  board.appendChild(center);
}

function renderAll(game){
  renderPlayers(game);
  renderHand(game);
  if(game.observerMode) renderObserverCasebook(game);
  else renderNotebook(game);
  renderBoard(game);
}

/* ================================================================================
 * [SECTION 11] GAME INITIALIZATION
 * ================================================================================
 * Startup sequence, new game function, and UI reset
 * ================================================================================ */

/* Startup */
const game=new Game();
(async function start(){
  try{
    clearGameplayPrompt();
    const setup = await promptGameSetup();
    game.aiDifficulty = normDiff(setup.diff);
    game.observerMode = !!setup.observer;
    game.coachMode = !!setup.observer; // Coach mode uses observer plumbing
    game.observerFocusId = 0;

    game.resetPlayers(setup.opp);

    // In observer mode, Player 1 is AI (no human prompts during play)
    if(game.observerMode){
      game.players[0].isHuman = false; // critical: prevents "human" refute prompts
      game.players[0].name = `Player 1`; // temporary until suspect assigned
    }

    // Choose focus suspect (optional but recommended)
    const pick = await promptHumanSuspect(SUSPECTS);
    // You can rename the prompt title/body if observer mode (see below)
    game.assignSuspects(pick);

    // After assignSuspects, set a nicer label for Player 1 in observer mode
    if(game.observerMode){
      game.players[0].name = displaySuspect(game.players[0].suspect); // keep consistent
    }

    game.setup();
    el('btnNewGame').onclick=()=>startNewGame(game);
    await game.beginTurn();
  }catch(e){
    console.error(e);
    await showInfoPrompt('Error',
      `<div style="color:#fca5a5"><b>${(e&&e.message)||'Unknown error'}</b></div>
       <div style="margin-top:8px;color:var(--muted);font-size:12px;">Check the browser console for details.</div>`);
  }
})();

function resetUIForSetup() {
  clearGameplayPrompt();
  const logBox = el('log'); if (logBox) logBox.textContent = '';
  // Clear observer deductions log (DOM + memory) at the same time as game log
  const deduceBox = document.getElementById('observerDeduceLog');
  if (deduceBox) deduceBox.textContent = '';
  game.obsLog = [];
  const playersBox = el('playersBox'); if (playersBox) playersBox.innerHTML = '';
  const handBox = el('handBox'); if (handBox) handBox.innerHTML = '';
  const board = el('board'); if (board) board.innerHTML = '';
  ['noteSuspects','noteWeapons','noteRooms'].forEach(id => {
    const box = el(id); if (box) box.innerHTML = '';
  });
  try { clearChecklist(); clearCheckNotes(); clearClueGrid(); } catch (e) { console.warn('Checklist clear error (safe to ignore):', e); }
  const turnPill = el('turnPill'); if (turnPill) turnPill.textContent = 'Turn: â€”';
  const locPill  = el('locPill');  if (locPill)  locPill.textContent  = 'Location: â€”';
}

async function startNewGame(game,{skipConfirm=false}={}){
  let ok=true;
  if(!skipConfirm){
    ok=await renderPrompt({
      title:'Start a New Game?',
      bodyHTML:`<div>This will restart the game and redeal all cards.</div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px;">
      Any current turn progress will be lost.
      </div>`,
      actions:[
        {label:'Cancel',value:false,className:'secondary'},
        {label:'New Game',value:true,className:'danger'}
      ]
    });
    clearGameplayPrompt();
  }
  if(!ok) return;

  resetUIForSetup();
  const setup = await promptGameSetup();
  game.aiDifficulty = normDiff(setup.diff);
  game.observerMode = !!setup.observer;
  game.coachMode = !!setup.observer; // Coach mode uses observer plumbing
  game.observerFocusId = 0;

  game.resetPlayers(setup.opp);

  // In observer mode, Player 1 is AI (no human prompts during play)
  if(game.observerMode){
    game.players[0].isHuman = false; // critical: prevents "human" refute prompts
    game.players[0].name = `Player 1`; // temporary until suspect assigned
  }

  // Choose focus suspect (optional but recommended)
  const pick = await promptHumanSuspect(SUSPECTS);
  // You can rename the prompt title/body if observer mode (see below)
  game.assignSuspects(pick);

  // After assignSuspects, set a nicer label for Player 1 in observer mode
  if(game.observerMode){
    game.players[0].name = displaySuspect(game.players[0].suspect); // keep consistent
  }

  game.setup();
  el('btnNewGame').onclick=()=>startNewGame(game);
  await game.beginTurn();
}

/* ================================================================================
 * ğŸ“š QUICK REFERENCE FOR CUSTOMIZATION
 * ================================================================================
 * 
 * COMMON MODIFICATIONS AND WHERE TO FIND THEM:
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ WHAT TO CHANGE              â”‚ WHERE TO LOOK                             â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ Colors                      â”‚ Search: "COLOR CUSTOMIZATION"             â”‚
 * â”‚ Game title                  â”‚ Search: "ClueSolo"                        â”‚
 * â”‚ Number of AI opponents      â”‚ Search: "promptGameSetup"                 â”‚
 * â”‚ AI difficulty               â”‚ Search: "[SECTION 5]"                     â”‚
 * â”‚ Room names                  â”‚ Search: "const ROOMS"                     â”‚
 * â”‚ Suspect names               â”‚ Search: "const SUSPECTS"                  â”‚
 * â”‚ Weapon names                â”‚ Search: "const WEAPONS"                   â”‚
 * â”‚ Board layout                â”‚ Search: "ROOM_LAYOUT"                     â”‚
 * â”‚ Dice roll range             â”‚ Search: "randInt(2, 12)"                  â”‚
 * â”‚ Button labels               â”‚ Search for the exact button text          â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 * 
 * DEBUGGING TIPS:
 * â€¢ Always keep a backup copy before editing!
 * â€¢ Use Ctrl+Z (Undo) if something breaks
 * â€¢ Open browser console (F12) to see error messages
 * â€¢ Check line numbers in error messages to find problems
 * â€¢ Test changes by refreshing the browser (F5)
 * 
 * SECTION MARKERS:
 * Use Ctrl+F to search for these tags to navigate the code:
 * [SECTION 1] - Utilities & Error Handling
 * [SECTION 2] - Game Constants
 * [SECTION 3] - Player Class
 * [SECTION 4] - Main Game Class
 * [SECTION 5] - AI Logic
 * [SECTION 6] - Game Flow Functions
 * [SECTION 7] - User Interface Prompts
 * [SECTION 8] - UI Rendering - Players & Cards
 * [SECTION 9] - UI Rendering - Notebook
 * [SECTION 10] - UI Rendering - Board
 * [SECTION 11] - Game Initialization
 * 
 * ================================================================================ */
</script>
</body>
</html>
